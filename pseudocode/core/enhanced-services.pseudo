# Enhanced Go Services for Bidirectional Bulgarian-German Learning App

PACKAGE bidirectionallearning

IMPORT (
    "math"
    "time"
    "sort"
)

# Enhanced spaced repetition service with language direction support
SERVICE SpacedRepetitionService {

    # Calculate next review with language direction consideration
    FUNCTION CalculateNextReview(correct bool, state ReviewState, difficulty int) (time.Time, ReviewState) {
        """
        Enhanced SM-2 algorithm that considers:
        - Language direction difficulty
        - Item-specific difficulty rating
        - User's success rate in current direction
        """
        
        # Base quality score adjusted for difficulty
        var quality int
        if correct {
            quality = 5
            # Bonus for difficult items
            if difficulty >= 4 {
                quality = 5
            }
        } else {
            quality = 2
            # Penalty for easy items failed
            if difficulty <= 2 {
                quality = 1
            }
        }
        
        newState := ReviewState{
            ItemID:       state.ItemID,
            LearningMode: state.LearningMode,
            SourceLang:   state.SourceLang,
            TargetLang:   state.TargetLang,
            Interval:     state.Interval,
            EaseFactor:   state.EaseFactor,
            Repetitions:  state.Repetitions,
            LastReview:   time.Now(),
            TotalReviews: state.TotalReviews + 1,
        }
        
        # Update success rate
        if correct {
            newState.CorrectStreak = state.CorrectStreak + 1
        } else {
            newState.CorrectStreak = 0
        }
        
        newState.SuccessRate = float64(newState.CorrectStreak) / float64(newState.TotalReviews)
        
        # SM-2 algorithm with direction-specific adjustments
        if quality < 3 {
            newState.Repetitions = 0
            newState.Interval = 1
        } else {
            newState.Repetitions = newState.Repetitions + 1
            
            if newState.Repetitions == 1 {
                newState.Interval = 1
            } else if newState.Repetitions == 2 {
                newState.Interval = 6
            } else {
                newState.Interval = int(math.Round(float64(newState.Interval) * newState.EaseFactor))
            }
        }
        
        # Language direction difficulty multiplier
        directionMultiplier := GetDirectionDifficultyMultiplier(state.SourceLang, state.TargetLang)
        newState.Interval = int(float64(newState.Interval) * directionMultiplier)
        
        # Update ease factor
        q := float64(quality)
        newState.EaseFactor = newState.EaseFactor + (0.1 - (5.0-q)*(0.08+(5.0-q)*0.02))
        newState.EaseFactor = math.Max(1.3, newState.EaseFactor)
        
        nextReview := time.Now().AddDate(0, 0, newState.Interval)
        newState.NextReview = nextReview
        
        return nextReview, newState
    }
    
    # Get difficulty multiplier based on language direction
    FUNCTION GetDirectionDifficultyMultiplier(sourceLang, targetLang string) float64 {
        """
        Returns difficulty multiplier for different learning directions:
        - Bulgarian → German: 1.2 (cases, compounds)
        - German → Bulgarian: 1.1 (aspects, definite articles)
        """
        
        if sourceLang == "bg" && targetLang == "de" {
            return 1.2  # Bulgarian to German is harder
        } else if sourceLang == "de" && targetLang == "bg" {
            return 1.1  # German to Bulgarian is moderately harder
        }
        return 1.0
    }
    
    # Get items due for review in specific language direction
    FUNCTION GetDueItemsByDirection(reviewStates []ReviewState, learningMode string) []ReviewState {
        var dueItems []ReviewState
        now := time.Now()
        
        for _, state := range reviewStates {
            # Filter by learning mode
            if learningMode != "both" && state.LearningMode != learningMode {
                continue
            }
            
            if state.NextReview.IsZero() || state.NextReview.Before(now) {
                dueItems = append(dueItems, state)
            }
        }
        
        return dueItems
    }
}

# Language toggle and direction management service
SERVICE LanguageDirectionService {
    
    # Toggle between learning directions
    FUNCTION ToggleLearningDirection(currentMode string) string {
        switch currentMode {
        case "bg_to_de":
            return "de_to_bg"
        case "de_to_bg":
            return "bg_to_de"
        default:
            return "bg_to_de"  # Default to Bulgarian to German
        }
    }
    
    # Get vocabulary items for specific learning direction
    FUNCTION GetVocabularyByDirection(items []VocabularyItem, direction string, level string) []VocabularyItem {
        var filtered []VocabularyItem
        
        for _, item := range items {
            # Check if item supports the requested direction
            if (direction == "bg_to_de" && item.SourceLang == "bg" && item.TargetLang == "de") ||
               (direction == "de_to_bg" && item.SourceLang == "de" && item.TargetLang == "bg") ||
               direction == "both" {
                
                # Filter by level if specified
                if level == "" || item.Level == level {
                    filtered = append(filtered, item)
                }
            }
        }
        
        return filtered
    }
    
    # Create reverse vocabulary item for bidirectional learning
    FUNCTION CreateReverseItem(item VocabularyItem) VocabularyItem {
        return VocabularyItem{
            ID:              item.ID + "_reverse",
            Word:            item.Translation,
            Translation:     item.Word,
            SourceLang:      item.TargetLang,
            TargetLang:      item.SourceLang,
            Level:           item.Level,
            Category:        item.Category,
            Etymology:       item.Etymology,
            CulturalNote:    item.CulturalNote,
            LinguisticNote:  item.LinguisticNote,
            Difficulty:      item.Difficulty,
            Frequency:       item.Frequency,
            Tags:           item.Tags,
        }
    }
}

# Cultural context service
SERVICE CulturalContextService {
    
    # Get cultural notes based on language direction
    FUNCTION GetCulturalContext(item VocabularyItem, userNativeLanguage string) string {
        """
        Returns appropriate cultural context based on user's native language
        """
        
        if userNativeLanguage == "bg" && item.TargetLang == "de" {
            # Bulgarian learning German - focus on German cultural context
            return item.CulturalNote + " [German cultural context]"
        } else if userNativeLanguage == "de" && item.TargetLang == "bg" {
            # German learning Bulgarian - focus on Bulgarian cultural context
            return item.CulturalNote + " [Bulgarian cultural context]"
        }
        
        return item.CulturalNote
    }
    
    # Get etymology explanation based on user's background
    FUNCTION GetEtymologyExplanation(item VocabularyItem, userNativeLanguage string) string {
        """
        Provides etymology explanation relevant to user's linguistic background
        """
        
        if userNativeLanguage == "bg" {
            # Explain German word origins to Bulgarian speakers
            return "German etymology: " + item.Etymology
        } else if userNativeLanguage == "de" {
            # Explain Bulgarian word origins to German speakers
            return "Bulgarian etymology: " + item.Etymology
        }
        
        return item.Etymology
    }
}

# Session management service for bidirectional learning
SERVICE LearningSessionService {
    
    # Create optimized learning session
    FUNCTION CreateLearningSession(preferences UserPreferences, availableItems []VocabularyItem) LearningSession {
        session := LearningSession{
            UserID:            preferences.UserID,
            SessionID:         GenerateSessionID(),
            LearningMode:      preferences.PreferredDirection,
            TargetLevel:       preferences.CurrentLevel,
            Categories:        preferences.PreferredCategories,
            MaxItems:          20, # Default session length
            ShowCulturalNotes: preferences.ShowCulturalNotes,
            StartTime:         time.Now(),
        }
        
        return session
    }
    
    # Select items for session based on spaced repetition and difficulty
    FUNCTION SelectSessionItems(session LearningSession, reviewStates []ReviewState, items []VocabularyItem) []VocabularyItem {
        # Get due items first
        dueItems := GetDueItemsByDirection(reviewStates, session.LearningMode)
        
        # Sort by priority (overdue items first, then by difficulty)
        sort.Slice(dueItems, func(i, j int) bool {
            return dueItems[i].NextReview.Before(dueItems[j].NextReview)
        })
        
        var sessionItems []VocabularyItem
        
        # Add due items up to session limit
        for i := 0; i < len(dueItems) && i < session.MaxItems; i++ {
            # Find corresponding vocabulary item
            for _, item := range items {
                if item.ID == dueItems[i].ItemID {
                    sessionItems = append(sessionItems, item)
                    break
                }
            }
        }
        
        # Fill remaining slots with new items if needed
        if len(sessionItems) < session.MaxItems {
            newItems := GetNewItemsForSession(items, reviewStates, session)
            remaining := session.MaxItems - len(sessionItems)
            
            for i := 0; i < len(newItems) && i < remaining; i++ {
                sessionItems = append(sessionItems, newItems[i])
            }
        }
        
        return sessionItems
    }
    
    # Get new items for learning session
    FUNCTION GetNewItemsForSession(items []VocabularyItem, reviewStates []ReviewState, session LearningSession) []VocabularyItem {
        # Create map of reviewed items
        reviewedItems := make(map[string]bool)
        for _, state := range reviewStates {
            reviewedItems[state.ItemID] = true
        }
        
        var newItems []VocabularyItem
        
        for _, item := range items {
            # Skip already reviewed items
            if reviewedItems[item.ID] {
                continue
            }
            
            # Filter by learning mode and level
            if (session.LearningMode == "bg_to_de" && item.SourceLang == "bg") ||
               (session.LearningMode == "de_to_bg" && item.SourceLang == "de") ||
               session.LearningMode == "both" {
                
                if item.Level == session.TargetLevel {
                    newItems = append(newItems, item)
                }
            }
        }
        
        # Sort by difficulty and frequency
        sort.Slice(newItems, func(i, j int) bool {
            if newItems[i].Difficulty == newItems[j].Difficulty {
                return newItems[i].Frequency > newItems[j].Frequency  # Higher frequency first
            }
            return newItems[i].Difficulty < newItems[j].Difficulty  # Easier items first
        })
        
        return newItems
    }
}

# Utility functions
FUNCTION GenerateSessionID() string {
    return fmt.Sprintf("session_%d", time.Now().Unix())
}
