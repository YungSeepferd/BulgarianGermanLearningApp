
> bulgarian-german-learning-app@1.0.0 lint:js
> eslint assets/js/ scripts/ --ext .js,.mjs,.ts --format=json

[{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/app.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[618,621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[618,621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[696,699],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[696,699],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[768,771],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[768,771],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[793,796],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[793,796],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1429,1432],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1429,1432],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1455,1458],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1455,1458],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1514,1517],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1514,1517],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1680,1683],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1680,1683],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":53,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":53,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1746,1749],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1746,1749],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1816,1819],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1816,1819],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1991,1994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1991,1994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2118,2121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2118,2121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2243,2246],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2243,2246],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":70,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":70,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2378,2381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2378,2381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":75,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2482,2485],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2482,2485],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3272,3275],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3272,3275],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3804,3807],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3804,3807],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":115,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":115,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3931,3934],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3931,3934],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"unicorn/no-array-for-each","severity":2,"message":"Use `for…of` instead of `.forEach(…)`.","line":118,"column":12,"nodeType":"Identifier","messageId":"no-array-for-each/error","endLine":118,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":131,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":131,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4492,4495],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4492,4495],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"unicorn/no-array-for-each","severity":2,"message":"Use `for…of` instead of `.forEach(…)`.","line":135,"column":18,"nodeType":"Identifier","messageId":"no-array-for-each/error","endLine":135,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":149,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5062,5065],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5062,5065],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"unicorn/no-array-for-each","severity":2,"message":"Use `for…of` instead of `.forEach(…)`.","line":153,"column":16,"nodeType":"Identifier","messageId":"no-array-for-each/error","endLine":153,"endColumn":23},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":159,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5507,5510],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5507,5510],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5637,5640],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5637,5640],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":176,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6002,6005],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6002,6005],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"unicorn/no-array-for-each","severity":2,"message":"Use `for…of` instead of `.forEach(…)`.","line":180,"column":19,"nodeType":"Identifier","messageId":"no-array-for-each/error","endLine":180,"endColumn":26},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":184,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":184,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6352,6355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6352,6355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":190,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":190,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6482,6485],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6482,6485],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":199,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":199,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6842,6845],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6842,6845],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":215,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7369,7372],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7369,7372],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":219,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7575,7578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7575,7578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":220,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7618,7621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7618,7621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":220,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7677,7680],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7677,7680],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7817,7820],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7817,7820],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7891,7894],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7891,7894],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-spread","severity":2,"message":"Use the spread operator instead of '.apply()'.","line":232,"column":39,"nodeType":"CallExpression","messageId":"preferSpread","endLine":232,"endColumn":61},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":236,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8130,8133],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8130,8133],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":236,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8204,8207],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8204,8207],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"prefer-spread","severity":2,"message":"Use the spread operator instead of '.apply()'.","line":240,"column":7,"nodeType":"CallExpression","messageId":"preferSpread","endLine":240,"endColumn":29},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":249,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":249,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8586,8589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8586,8589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":6,"fatalErrorCount":0,"warningCount":35,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Main application entry point\n */\n\n// Declare global BgDeApp interface\ninterface BgDeAppNamespace {\n  init: () => void;\n  initNavigation: () => void;\n  initLanguageToggle: () => void;\n  initPerformanceMonitor: () => void;\n  initVocabulary: () => void;\n  initGrammar: () => void;\n  initPracticeSession: () => void;\n  initProgressDashboard: () => void;\n  updateLanguageText: (lang: string) => void;\n  startPractice: (level: string, category: string) => void;\n  initChart: (container: HTMLElement, chartType: string) => void;\n  handleError: (error: Error, context: string) => void;\n  debounce: <T extends (...args: any[]) => void>(func: T, wait: number) => T;\n  throttle: <T extends (...args: any[]) => void>(func: T, limit: number) => T;\n  vocabulary: {\n    data: any[];\n    filteredData: any[];\n    selectedWords: Set<string>;\n    filters: {\n      level: string;\n      category: string;\n      search: string;\n    };\n  };\n  loadVocabularyData: () => void;\n  bindVocabularyEvents: () => void;\n  renderVocabulary: () => void;\n  updateVocabularyStats: () => void;\n  applyVocabularyFilters: () => void;\n  clearAllVocabularyFilters: () => void;\n  bindCardSelectionEvents: () => void;\n  toggleWordSelection: (word: string, cardElement: HTMLElement) => void;\n  flipVocabularyCard: (cardElement: HTMLElement) => void;\n  startPracticeWithSelected: () => void;\n  shuffleArray: <T>(array: T[]) => T[];\n}\n\n// Global namespace\n(window as any).BgDeApp = (window as any).BgDeApp || {};\n\n// Initialize application\n((window as any).BgDeApp as BgDeAppNamespace).init = function(): void {\n  console.log('BulgarianGermanLearningApp initialized');\n  \n  // Initialize various modules\n  ((window as any).BgDeApp as BgDeAppNamespace).initNavigation();\n  ((window as any).BgDeApp as BgDeAppNamespace).initLanguageToggle();\n  ((window as any).BgDeApp as BgDeAppNamespace).initPerformanceMonitor();\n  \n  // Initialize specific page functionality\n  if (document.querySelector('#vocabulary-grid')) {\n    ((window as any).BgDeApp as BgDeAppNamespace).initVocabulary();\n  }\n  \n  if (document.querySelector('#grammar-content')) {\n    ((window as any).BgDeApp as BgDeAppNamespace).initGrammar();\n  }\n  \n  if (document.querySelector('#practice-session')) {\n    ((window as any).BgDeApp as BgDeAppNamespace).initPracticeSession();\n  }\n  \n  if (document.querySelector('#progress-dashboard')) {\n    ((window as any).BgDeApp as BgDeAppNamespace).initProgressDashboard();\n  }\n};\n\n// Initialize navigation\n((window as any).BgDeApp as BgDeAppNamespace).initNavigation = function(): void {\n  const mobileMenuToggle = document.querySelector('#mobile-menu-toggle');\n  const mobileMenu = document.querySelector('#mobile-menu');\n  \n  if (mobileMenuToggle && mobileMenu) {\n    mobileMenuToggle.addEventListener('click', function(): void {\n      mobileMenu.classList.toggle('active');\n    });\n  }\n  \n  // Close mobile menu when clicking outside\n  document.addEventListener('click', function(e: Event): void {\n    const target = e.target as HTMLElement;\n    if (mobileMenu && mobileMenu.classList.contains('active') && \n        !target.closest('#mobile-menu') && \n        !target.closest('#mobile-menu-toggle')) {\n      mobileMenu.classList.remove('active');\n    }\n  });\n};\n\n// Initialize language toggle\n((window as any).BgDeApp as BgDeAppNamespace).initLanguageToggle = function(): void {\n  const languageToggle = document.querySelector('#language-toggle');\n  \n  if (languageToggle) {\n    languageToggle.addEventListener('click', function(): void {\n      const currentLang = document.documentElement.lang || 'en';\n      const newLang = currentLang === 'en' ? 'de' : 'en';\n      \n      document.documentElement.lang = newLang;\n      localStorage.setItem('bgde:language', newLang);\n      \n      // Update UI text based on language\n      ((window as any).BgDeApp as BgDeAppNamespace).updateLanguageText(newLang);\n    });\n  }\n};\n\n// Update UI text based on language\n((window as any).BgDeApp as BgDeAppNamespace).updateLanguageText = function(lang: string): void {\n  const elements = document.querySelectorAll('[data-lang-en], [data-lang-de]');\n  \n  elements.forEach(function(element: Element): void {\n    const enText = element.dataset.langEn;\n    const deText = element.dataset.langDe;\n    \n    if (lang === 'en' && enText) {\n      (element as HTMLElement).textContent = enText;\n    } else if (lang === 'de' && deText) {\n      (element as HTMLElement).textContent = deText;\n    }\n  });\n};\n\n// Initialize grammar functionality\n((window as any).BgDeApp as BgDeAppNamespace).initGrammar = function(): void {\n  // Grammar-specific initialization\n  const grammarToggles = document.querySelectorAll('.grammar-toggle');\n  \n  grammarToggles.forEach(function(toggle: Element): void {\n    toggle.addEventListener('click', function(): void {\n      const targetId = toggle.dataset.target;\n      if (targetId) {\n        const target = document.querySelector(`#${targetId}`);\n        if (target) {\n          target.classList.toggle('active');\n        }\n      }\n    });\n  });\n};\n\n// Initialize practice session\n((window as any).BgDeApp as BgDeAppNamespace).initPracticeSession = function(): void {\n  // Practice session initialization\n  const startButtons = document.querySelectorAll('.start-practice');\n  \n  startButtons.forEach(function(button: Element): void {\n    button.addEventListener('click', function(): void {\n      const level = button.dataset.level;\n      const category = button.dataset.category;\n      \n      if (level && category) {\n        ((window as any).BgDeApp as BgDeAppNamespace).startPractice(level, category);\n      }\n    });\n  });\n};\n\n// Start practice session\n((window as any).BgDeApp as BgDeAppNamespace).startPractice = function(level: string, category: string): void {\n  // Store practice settings\n  localStorage.setItem('bgde:practice_level', level);\n  localStorage.setItem('bgde:practice_category', category);\n  \n  // Navigate to practice page\n  window.location.href = '/practice/';\n};\n\n// Initialize progress dashboard\n((window as any).BgDeApp as BgDeAppNamespace).initProgressDashboard = function(): void {\n  // Progress dashboard initialization\n  const chartContainers = document.querySelectorAll('.chart-container');\n  \n  chartContainers.forEach(function(container: Element): void {\n    const chartType = container.dataset.chartType;\n    \n    if (chartType) {\n      ((window as any).BgDeApp as BgDeAppNamespace).initChart(container as HTMLElement, chartType);\n    }\n  });\n};\n\n// Initialize chart\n((window as any).BgDeApp as BgDeAppNamespace).initChart = function(container: HTMLElement, chartType: string): void {\n  // Chart initialization logic\n  console.log(`Initializing ${chartType} chart in`, container);\n  \n  // Placeholder for chart initialization\n  // This would typically use a charting library like Chart.js\n};\n\n// Initialize performance monitor\n((window as any).BgDeApp as BgDeAppNamespace).initPerformanceMonitor = function(): void {\n  // Performance monitoring initialization\n  if (typeof performance !== 'undefined') {\n    performance.mark('app-init-start');\n  }\n  \n  // Monitor key performance metrics\n  window.addEventListener('load', function(): void {\n    if (typeof performance !== 'undefined') {\n      performance.mark('app-load-complete');\n      performance.measure('app-initialization', 'app-init-start', 'app-load-complete');\n    }\n  });\n};\n\n// Error handling\n((window as any).BgDeApp as BgDeAppNamespace).handleError = function(error: Error, context: string): void {\n  console.error(`Error in ${context}:`, error);\n  \n  // Send error to analytics if available\n  if ((window as any).gtag !== undefined) {\n    ((window as any).gtag as (command: string, eventName: string, params?: any) => void)('event', 'exception', {\n      description: error.message,\n      fatal: false\n    });\n  }\n};\n\n// Utility functions\n((window as any).BgDeApp as BgDeAppNamespace).debounce = function<T extends (...args: any[]) => void>(func: T, wait: number): T {\n  let timeout: number;\n  return function(...args: Parameters<T>): void {\n    clearTimeout(timeout);\n    timeout = window.setTimeout(() => func.apply(null, args), wait);\n  } as T;\n};\n\n((window as any).BgDeApp as BgDeAppNamespace).throttle = function<T extends (...args: any[]) => void>(func: T, limit: number): T {\n  let inThrottle: boolean;\n  return function(...args: Parameters<T>): void {\n    if (!inThrottle) {\n      func.apply(null, args);\n      inThrottle = true;\n      setTimeout(() => inThrottle = false, limit);\n    }\n  } as T;\n};\n\n// Initialize when DOM is ready\ndocument.addEventListener('DOMContentLoaded', function(): void {\n  ((window as any).BgDeApp as BgDeAppNamespace).init();\n});\n\n// Export for module usage if needed\nexport {};","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/bidirectional-flashcards.ts","messages":[{"ruleId":"unicorn/consistent-function-scoping","severity":2,"message":"Move arrow function 'handleDirectionChange' to the outer scope.","line":25,"column":56,"nodeType":"ArrowFunctionExpression","messageId":"consistent-function-scoping","endLine":25,"endColumn":58},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5960,5963],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5960,5963],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6001,6004],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6001,6004],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6076,6079],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6076,6079],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":210,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7099,7102],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7099,7102],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":210,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":210,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7140,7143],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7140,7143],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":211,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":211,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7208,7211],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7208,7211],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":228,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":228,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7878,7881],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7878,7881],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Bidirectional Flashcard System\n * Integrates with existing language toggle to provide direction-aware flashcards\n */\n\ntype Direction = 'bg-de' | 'de-bg';\n\n// SetDirectionOptions interface removed as it's unused\n\nclass BiDirectionalFlashcards {\n  private currentDirection: Direction;\n\n  constructor() {\n    this.currentDirection = this.readDirection();\n    this.init();\n  }\n\n  init(): void {\n    this.bindLanguageToggle();\n    this.updateFlashcardDirection();\n    this.observeFlashcards();\n  }\n\n  private bindLanguageToggle(): void {\n    const handleDirectionChange = (event: CustomEvent) => {\n      const detail = event?.detail;\n      const nextDirection = this.normalizeDirection(detail?.direction);\n\n      if (!nextDirection) {\n        return;\n      }\n\n      this.currentDirection = nextDirection;\n      this.updateFlashcardDirection();\n    };\n\n    document.addEventListener('language-direction-changed', handleDirectionChange as EventListener);\n    document.addEventListener('languageDirectionChanged', handleDirectionChange as EventListener);\n    window.addEventListener('learning-direction-changed', handleDirectionChange as EventListener);\n\n    window.addEventListener('storage', (event: StorageEvent) => {\n      if (event.key === 'bgde:language-direction') {\n        const nextDirection = this.normalizeDirection(event.newValue);\n        if (nextDirection) {\n          this.currentDirection = nextDirection;\n          this.updateFlashcardDirection();\n        }\n      } else if (event.key === 'bgde:learning_direction') {\n        const migrated = this.normalizeDirection(event.newValue);\n        if (migrated) {\n          localStorage.removeItem('bgde:learning_direction');\n          localStorage.setItem('bgde:language-direction', migrated);\n          this.currentDirection = migrated;\n          this.updateFlashcardDirection();\n        }\n      }\n    });\n  }\n\n  private updateFlashcardDirection(): void {\n    const flashcards = document.querySelectorAll('.flashcard-item');\n    const isReversed = this.currentDirection === 'de-bg';\n\n    for (const flashcard of flashcards) {\n      this.updateSingleFlashcard(flashcard, isReversed);\n    }\n\n    // Update UI language indicators\n    this.updateLanguageIndicators(isReversed);\n  }\n\n  private updateSingleFlashcard(flashcard: Element, isReversed: boolean): void {\n    const wordElement = flashcard.querySelector('.word');\n    const translationElement = flashcard.querySelector('.translation');\n        \n    if (!wordElement || !translationElement) {\n      return;\n    }\n\n    // Get original data\n    const originalWord = wordElement.dataset.originalWord || wordElement.textContent || '';\n    const originalTranslation = translationElement.dataset.originalTranslation || translationElement.textContent || '';\n\n    // Store original data if not already stored\n    if (!wordElement.dataset.originalWord) {\n      wordElement.dataset.originalWord = originalWord;\n      wordElement.dataset.originalLang = 'bg';\n    }\n    if (!translationElement.dataset.originalTranslation) {\n      translationElement.dataset.originalTranslation = originalTranslation;\n      translationElement.dataset.originalLang = 'de';\n    }\n\n    if (isReversed) {\n      // DE → BG: Show German word, Bulgarian translation\n      wordElement.textContent = originalTranslation;\n      wordElement.dataset.lang = 'de';\n      translationElement.textContent = originalWord;\n      translationElement.dataset.lang = 'bg';\n    } else {\n      // BG → DE: Show Bulgarian word, German translation\n      wordElement.textContent = originalWord;\n      wordElement.dataset.lang = 'bg';\n      translationElement.textContent = originalTranslation;\n      translationElement.dataset.lang = 'de';\n    }\n\n    // Update flashcard class for styling\n    flashcard.classList.toggle('reversed', isReversed);\n  }\n\n  private updateLanguageIndicators(isReversed: boolean): void {\n    // Update button text based on direction\n    const flipButtons = document.querySelectorAll('.flip-button');\n    for (const button of flipButtons) {\n      const bgText = button.querySelector('.btn-text-bg');\n      const deText = button.querySelector('.btn-text-de');\n            \n      if (bgText && deText) {\n        if (isReversed) {\n          (bgText as HTMLElement).style.display = 'none';\n          (deText as HTMLElement).style.display = 'inline';\n        } else {\n          (bgText as HTMLElement).style.display = 'inline';\n          (deText as HTMLElement).style.display = 'none';\n        }\n      }\n    }\n\n    // Update response buttons\n    const responseButtons = document.querySelectorAll('.response-buttons button');\n    for (const button of responseButtons) {\n      const text = button.textContent || '';\n      if (text.includes('Falsch') && text.includes('Грешно')) {\n        button.innerHTML = isReversed ? \n          '✗ Грешно / Falsch' : \n          '✗ Falsch / Грешно';\n      } else if (text.includes('Richtig') && text.includes('Правилно')) {\n        button.innerHTML = isReversed ? \n          '✓ Правилно / Richtig' : \n          '✓ Richtig / Правилно';\n      }\n    }\n  }\n\n  private observeFlashcards(): void {\n    // Watch for dynamically added flashcards\n    const observer = new MutationObserver((mutations) => {\n      for (const mutation of mutations) {\n        for (const node of mutation.addedNodes) {\n          if (node.nodeType === Node.ELEMENT_NODE) {\n            const flashcards = (node as Element).querySelectorAll ? \n              (node as Element).querySelectorAll('.flashcard-item') : \n              ((node as Element).classList?.contains('flashcard-item') ? [node] : []);\n                        \n            for (const flashcard of flashcards) {\n              this.updateSingleFlashcard(flashcard as Element, this.currentDirection === 'de-bg');\n            }\n          }\n        }\n      }\n    });\n\n    observer.observe(document.body, {\n      childList: true,\n      subtree: true\n    });\n  }\n\n  private readDirection(): Direction {\n    if ((window as any).languageToggle && typeof (window as any).languageToggle.getDirection === 'function') {\n      return (window as any).languageToggle.getDirection();\n    }\n\n    const stored =\n            localStorage.getItem('bgde:language-direction') ||\n            localStorage.getItem('bgde:learning_direction');\n\n    return this.normalizeDirection(stored) || 'de-bg';\n  }\n\n  private normalizeDirection(value: string | null): Direction | null {\n    if (!value) {\n      return null;\n    }\n\n    const normalized = value.toString().toLowerCase();\n\n    if (normalized === 'bg-de' || normalized === 'bg_to_de') {\n      return 'bg-de';\n    }\n\n    if (normalized === 'de-bg' || normalized === 'de_to_bg') {\n      return 'de-bg';\n    }\n\n    return normalized === 'bg-de' || normalized === 'de-bg' ? normalized as Direction : null;\n  }\n\n  // Public method to manually trigger direction update\n  setDirection(direction: Direction): void {\n    const normalized = this.normalizeDirection(direction);\n    if (!normalized) {\n      return;\n    }\n\n    const changed = normalized !== this.currentDirection;\n    this.currentDirection = normalized;\n\n    if ((window as any).languageToggle && typeof (window as any).languageToggle.setDirection === 'function') {\n      (window as any).languageToggle.setDirection(normalized, { announce: true });\n    } else {\n      localStorage.setItem('bgde:language-direction', normalized);\n      const detail = { direction: normalized, source: 'bidirectional-flashcards' };\n      document.dispatchEvent(new CustomEvent('language-direction-changed', { detail }));\n      document.dispatchEvent(new CustomEvent('languageDirectionChanged', { detail }));\n      window.dispatchEvent(new CustomEvent('learning-direction-changed', { detail }));\n    }\n\n    if (changed) {\n      this.updateFlashcardDirection();\n    }\n  }\n}\n\n// Initialize when DOM is ready\ndocument.addEventListener('DOMContentLoaded', () => {\n  (window as any).biDirectionalFlashcards = new BiDirectionalFlashcards();\n});\n\nexport default BiDirectionalFlashcards;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/code.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/error-handler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":276,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":276,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7315,7318],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7315,7318],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":279,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":279,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7398,7401],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7398,7401],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Global Error Handler for Bulgarian-German Learning App\n *\n * Provides centralized error handling, logging, and user notifications\n * for production-ready error management.\n */\n\ninterface ErrorInfo {\n  message: string;\n  stack?: string;\n  type: string;\n  timestamp: string;\n  filename?: string;\n  lineno?: number;\n  colno?: number;\n}\n\ninterface ErrorStats {\n  total: number;\n  byType: Record<string, number>;\n  recent: ErrorInfo[];\n}\n\nclass ErrorHandler {\n  private errors: ErrorInfo[];\n  private maxErrors: number;\n  private isProduction: boolean;\n\n  constructor() {\n    this.errors = [];\n    this.maxErrors = 50; // Keep last 50 errors\n    this.isProduction = !window.location.hostname.includes('localhost');\n    this.setupGlobalHandlers();\n  }\n\n  /**\n   * Setup global error handlers\n   */\n  private setupGlobalHandlers(): void {\n    // Catch unhandled promise rejections\n    window.addEventListener('unhandledrejection', (event: PromiseRejectionEvent) => {\n      this.handleError({\n        message: event.reason?.message || 'Unhandled Promise Rejection',\n        stack: event.reason?.stack,\n        type: 'unhandledrejection',\n        timestamp: new Date().toISOString()\n      });\n\n      // Prevent default browser error reporting\n      event.preventDefault();\n    });\n\n    // Catch global errors\n    window.addEventListener('error', (event: ErrorEvent) => {\n      this.handleError({\n        message: event.message || 'Global Error',\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        stack: event.error?.stack,\n        type: 'error',\n        timestamp: new Date().toISOString()\n      });\n    });\n  }\n\n  /**\n   * Handle and log errors\n   * @param error - Error object\n   */\n  handleError(error: ErrorInfo): void {\n    // Add to error log\n    this.errors.push(error);\n    if (this.errors.length > this.maxErrors) {\n      this.errors.shift(); // Remove oldest error\n    }\n\n    // Log to console in development\n    if (!this.isProduction) {\n      console.error('[ErrorHandler]', error);\n    }\n\n    // Store in localStorage for debugging (last 10 errors only)\n    try {\n      const recentErrors = this.errors.slice(-10);\n      localStorage.setItem('bgde:errors', JSON.stringify(recentErrors));\n    } catch (error_) {\n      console.warn('Could not store errors in localStorage:', error_);\n    }\n\n    // Show user-friendly notification for critical errors\n    if (error.type === 'error' || error.type === 'unhandledrejection') {\n      this.showUserNotification(error);\n    }\n  }\n\n  /**\n   * Show user-friendly error notification\n   * @param error - Error object\n   */\n  private showUserNotification(error: ErrorInfo): void {\n    // Check if we should show notification (not too many errors in short time)\n    const recentErrors = this.errors.filter(e => {\n      const errorTime = new Date(e.timestamp).getTime();\n      const now = Date.now();\n      return now - errorTime < 30_000; // Last 30 seconds\n    });\n\n    // Don't spam user with notifications\n    if (recentErrors.length > 3) {\n      return;\n    }\n\n    // Create notification element\n    const notification = document.createElement('div');\n    notification.className = 'error-notification';\n    notification.setAttribute('role', 'alert');\n    notification.innerHTML = `\n      <div class=\"error-notification-content\">\n        <strong>⚠️ Ein Fehler ist aufgetreten / Възникна грешка</strong>\n        <p>${this.getUserFriendlyMessage(error)}</p>\n        <button class=\"error-notification-close\" aria-label=\"Close\">×</button>\n      </div>\n    `;\n\n    // Add styles if not already present\n    if (!document.querySelector('#error-handler-styles')) {\n      const style = document.createElement('style');\n      style.id = 'error-handler-styles';\n      style.textContent = `\n        .error-notification {\n          position: fixed;\n          top: 20px;\n          right: 20px;\n          max-width: 400px;\n          background: #fff3cd;\n          border: 1px solid #ffc107;\n          border-radius: 8px;\n          padding: 16px;\n          box-shadow: 0 4px 12px rgba(0,0,0,0.15);\n          z-index: 10000;\n          animation: slideIn 0.3s ease-out;\n        }\n\n        .error-notification-content {\n          position: relative;\n        }\n\n        .error-notification strong {\n          display: block;\n          margin-bottom: 8px;\n          color: #856404;\n        }\n\n        .error-notification p {\n          margin: 0;\n          color: #856404;\n          font-size: 14px;\n        }\n\n        .error-notification-close {\n          position: absolute;\n          top: -8px;\n          right: -8px;\n          background: #ffc107;\n          border: none;\n          border-radius: 50%;\n          width: 24px;\n          height: 24px;\n          cursor: pointer;\n          font-size: 18px;\n          line-height: 1;\n          color: #856404;\n        }\n\n        .error-notification-close:hover {\n          background: #e0a800;\n        }\n\n        @keyframes slideIn {\n          from {\n            transform: translateX(100%);\n            opacity: 0;\n          }\n          to {\n            transform: translateX(0);\n            opacity: 1;\n          }\n        }\n      `;\n      document.head.append(style);\n    }\n\n    // Add to page\n    document.body.append(notification);\n\n    // Setup close button\n    const closeBtn = notification.querySelector('.error-notification-close');\n    closeBtn?.addEventListener('click', () => {\n      notification.remove();\n    });\n\n    // Auto-remove after 10 seconds\n    setTimeout(() => {\n      if (notification.parentNode) {\n        notification.remove();\n      }\n    }, 10_000);\n  }\n\n  /**\n   * Get user-friendly error message\n   * @param error - Error object\n   * @returns User-friendly message\n   */\n  private getUserFriendlyMessage(error: ErrorInfo): string {\n    const message = error.message || '';\n\n    // Network errors\n    if (message.includes('fetch') || message.includes('network')) {\n      return 'Bitte überprüfen Sie Ihre Internetverbindung / Моля, проверете интернет връзката си.';\n    }\n\n    // Storage errors\n    if (message.includes('localStorage') || message.includes('storage')) {\n      return 'Speicherproblem. Bitte löschen Sie den Browser-Cache / Проблем със съхранението. Моля, изчистете кеша на браузъра.';\n    }\n\n    // Generic error\n    return 'Die Seite wird neu geladen... / Страницата ще се презареди...';\n  }\n\n  /**\n   * Get error statistics\n   * @returns Error statistics\n   */\n  getStats(): ErrorStats {\n    const errorsByType: Record<string, number> = {};\n    for (const error of this.errors) {\n      errorsByType[error.type] = (errorsByType[error.type] || 0) + 1;\n    }\n\n    return {\n      total: this.errors.length,\n      byType: errorsByType,\n      recent: this.errors.slice(-5)\n    };\n  }\n\n  /**\n   * Clear error log\n   */\n  clearErrors(): void {\n    this.errors = [];\n    localStorage.removeItem('bgde:errors');\n  }\n\n  /**\n   * Export errors for debugging\n   * @returns JSON string of errors\n   */\n  exportErrors(): string {\n    return JSON.stringify({\n      errors: this.errors,\n      timestamp: new Date().toISOString(),\n      userAgent: navigator.userAgent,\n      url: window.location.href\n    }, null, 2);\n  }\n}\n\n// Create global error handler instance\nconst errorHandler = new ErrorHandler();\n\n// Make available globally for debugging\n(window as any).bgdeErrorHandler = errorHandler;\n\n// Log initialization\nif (!(errorHandler as any).isProduction) {\n  console.log('[ErrorHandler] Initialized. Access via window.bgdeErrorHandler');\n  console.log('[ErrorHandler] Commands: .getStats(), .clearErrors(), .exportErrors()');\n}\n\nexport default errorHandler;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/flashcards.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":660,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":660,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21105,21108],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21105,21108],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":791,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":791,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24470,24473],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24470,24473],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file flashcards.ts\n * @description Core flashcard practice system with SM-2 spaced repetition integration\n * @status ACTIVE\n * @dependencies spaced-repetition.ts, language-toggle.ts, speech-recognition.ts\n * @used_by layouts/practice/single.html\n * @features\n *   - Flip animations with CSS transitions\n *   - Keyboard shortcuts (Space/Enter to flip, 0-5 to grade)\n *   - Progress tracking and session statistics\n *   - Bidirectional learning (Bulgarian↔German)\n *   - Speech recognition integration\n *   - localStorage persistence via bgde: prefix\n * @see docs/ARCHITECTURE.md for system design\n * @version 2.0.0\n * @updated October 2025\n */\n\nimport UnifiedSpacedRepetition from './unified-spaced-repetition';\nimport { languageToggle } from './language-toggle';\nimport SpeechPractice from './speech-recognition';\n\ninterface VocabularyItem {\n  word: string;\n  translation: string;\n  category?: string;\n  level?: string;\n  notes?: string;\n  notes_bg_to_de?: string;\n  notes_de_to_bg?: string;\n}\n\ninterface SessionStats {\n  startTime: Date | null;\n  endTime: Date | null;\n  totalCards: number;\n  reviewedCards: number;\n  correctAnswers: number;\n  grades: number[];\n}\n\ninterface CardText {\n  frontText: string;\n  backText: string;\n}\n\n// SpeechPracticeOptions interface removed as it's unused\n\nexport class Flashcards {\n  private container: HTMLElement;\n  private vocabularyData: VocabularyItem[] = [];\n  private sessionCards: VocabularyItem[] = [];\n  private currentIndex = 0;\n  private currentCard: VocabularyItem | null = null;\n  private isFlipped = false;\n  private languageDirection: string;\n  private sessionStats: SessionStats = {\n    startTime: null,\n    endTime: null,\n    totalCards: 0,\n    reviewedCards: 0,\n    correctAnswers: 0,\n    grades: []\n  };\n  private spacedRepetition: UnifiedSpacedRepetition;\n\n  // Configuration from shortcode parameters\n  private category: string;\n  private level: string;\n  private limit: number;\n  private mode: string;\n  private shuffle: boolean;\n\n  // DOM elements\n  private stage: HTMLElement | null;\n  private flashcard: HTMLElement | null;\n  private wordText: HTMLElement | null;\n  private translationText: HTMLElement | null;\n  private wordMeta: HTMLElement | null;\n  private wordNotes: HTMLElement | null;\n  private reviewStats: HTMLElement | null;\n  private gradingControls: HTMLElement | null;\n  private sessionComplete: HTMLElement | null;\n  private loading: HTMLElement | null;\n  private error: HTMLElement | null;\n  // speechControls removed as it's unused\n  private speechBtn: HTMLElement | null;\n  private speechFeedback: HTMLElement | null;\n\n  // Progress elements\n  private progressFill: HTMLElement | null;\n  private sessionProgress: HTMLElement | null;\n  private sessionAccuracy: HTMLElement | null;\n\n  // Control buttons\n  private pauseBtn: HTMLElement | null;\n  private endBtn: HTMLElement | null;\n  private retryBtn: HTMLElement | null;\n\n  // Cache bound handlers to avoid duplicate listeners on retries\n  private onGlobalKeydown: (e: KeyboardEvent) => void;\n  private onLanguageDirectionChanged: (e: CustomEvent) => void;\n  private globalKeyListenerAttached = false;\n  private languageListenerAttached = false;\n  private eventsBound = false;\n  private speechPractice: SpeechPractice | null = null;\n  private speechPracticeAvailable = false;\n  private expectedSpeech = '';\n  private isListening = false;\n  private lastSpeechTone = 'info';\n  \n  constructor(container: HTMLElement) {\n    this.container = container;\n    this.languageDirection = languageToggle.getDirection();\n    this.spacedRepetition = new UnifiedSpacedRepetition();\n\n    // Configuration from shortcode parameters\n    this.category = container.dataset.category || '';\n    this.level = container.dataset.level || '';\n    this.limit = Number.parseInt(container.dataset.limit || '20');\n    this.mode = container.dataset.mode || 'practice';\n    this.shuffle = container.dataset.shuffle === 'true';\n\n    // DOM elements\n    this.stage = container.querySelector('#flashcard-stage');\n    this.flashcard = container.querySelector('#current-flashcard');\n    this.wordText = container.querySelector('#word-text');\n    this.translationText = container.querySelector('#translation-text');\n    this.wordMeta = container.querySelector('#word-meta');\n    this.wordNotes = container.querySelector('#word-notes');\n    this.reviewStats = container.querySelector('#review-stats');\n    this.gradingControls = container.querySelector('#grading-controls');\n    this.sessionComplete = container.querySelector('#session-complete');\n    this.loading = container.querySelector('#flashcards-loading');\n    this.error = container.querySelector('#flashcards-error');\n    // speechControls removed as it's unused\n    this.speechBtn = container.querySelector('#start-pronunciation');\n    this.speechFeedback = container.querySelector('#speech-feedback');\n\n    // Progress elements\n    this.progressFill = container.querySelector('#progress-fill');\n    this.sessionProgress = container.querySelector('#session-progress');\n    this.sessionAccuracy = container.querySelector('#session-accuracy');\n\n    // Control buttons\n    this.pauseBtn = container.querySelector('#pause-session');\n    this.endBtn = container.querySelector('#end-session');\n    this.retryBtn = container.querySelector('#retry-flashcards');\n\n    // Cache bound handlers to avoid duplicate listeners on retries\n    this.onGlobalKeydown = this.handleGlobalKeyboard.bind(this);\n    this.onLanguageDirectionChanged = this.handleLanguageDirectionChange.bind(this);\n\n    this.init();\n  }\n\n  getCardNote(vocab: VocabularyItem): string {\n    if (this.languageDirection === 'bg-de') {\n      return vocab.notes_bg_to_de || vocab.notes || '';\n    }\n    return vocab.notes_de_to_bg || vocab.notes || '';\n  }\n  \n  async init(): Promise<void> {\n    try {\n      this.bindEvents();\n      this.showLoading(true);\n      \n      await this.loadVocabulary();\n      await this.prepareSession();\n      \n      this.startSession();\n      \n    } catch (error) {\n      console.error('Failed to initialize flashcards:', error);\n      this.showError(true, (error as Error).message);\n    }\n  }\n\n  readInlineVocabulary(): VocabularyItem[] | null {\n    const inlineElement = document.querySelector('#practice-vocabulary-data');\n    if (!inlineElement) {\n      return null;\n    }\n\n    const rawContent = inlineElement.textContent;\n    if (!rawContent) {\n      console.warn('Embedded vocabulary JSON is empty.');\n      return null;\n    }\n\n    try {\n      const parsed = JSON.parse(rawContent);\n      if (!Array.isArray(parsed)) {\n        console.warn('Embedded vocabulary JSON is not an array.');\n        return null;\n      }\n      return parsed as VocabularyItem[];\n    } catch (error) {\n      console.warn('Failed to parse embedded vocabulary JSON, falling back to network fetch.', error);\n      return null;\n    }\n  }\n  \n  bindEvents(): void {\n    if (this.eventsBound) {\n      return;\n    }\n    this.eventsBound = true;\n\n    // Card flip events\n    if (this.flashcard) {\n      this.flashcard.addEventListener('click', () => this.handleCardClick());\n      this.flashcard.addEventListener('keydown', (e) => this.handleCardKeyboard(e));\n    }\n    \n    // Grade button events\n    const gradeButtons = this.container.querySelectorAll('.grade-btn');\n    for (const btn of gradeButtons) {\n      btn.addEventListener('click', (e) => {\n        const target = e.currentTarget as HTMLElement;\n        const grade = Number.parseInt(target.dataset.grade || '0');\n        this.handleGrade(grade);\n      });\n    }\n    \n    // Control button events\n    if (this.pauseBtn) {\n      this.pauseBtn.addEventListener('click', () => this.pauseSession());\n    }\n    \n    if (this.endBtn) {\n      this.endBtn.addEventListener('click', () => this.endSession());\n    }\n    \n    if (this.retryBtn) {\n      this.retryBtn.addEventListener('click', () => {\n        this.stopSpeechPractice();\n        this.init();\n      });\n    }\n    \n    // Session complete actions\n    const newSessionBtn = this.container.querySelector('#new-session');\n    const reviewMistakesBtn = this.container.querySelector('#review-mistakes');\n    const backToVocabBtn = this.container.querySelector('#back-to-vocab');\n    \n    if (newSessionBtn) {\n      newSessionBtn.addEventListener('click', () => this.startNewSession());\n    }\n    \n    if (reviewMistakesBtn) {\n      reviewMistakesBtn.addEventListener('click', () => this.reviewMistakes());\n    }\n    \n    if (backToVocabBtn) {\n      backToVocabBtn.addEventListener('click', () => this.backToVocabulary());\n    }\n    \n    // Listen for language direction changes (use bound handler for cleanup)\n    if (!this.languageListenerAttached) {\n      document.addEventListener('language-direction-changed', this.onLanguageDirectionChanged);\n      this.languageListenerAttached = true;\n    }\n\n    // Attach global keyboard listener (use bound handler for cleanup)\n    if (!this.globalKeyListenerAttached) {\n      document.addEventListener('keydown', this.onGlobalKeydown);\n      this.globalKeyListenerAttached = true;\n    }\n\n    this.setupSpeechControls();\n  }\n\n  setupSpeechControls(): void {\n    if (!this.speechBtn) {\n      return;\n    }\n\n    if (!SpeechPractice || !SpeechPractice.isSupported()) {\n      this.speechPracticeAvailable = false;\n      this.speechBtn.setAttribute('disabled', 'disabled');\n      this.speechBtn.setAttribute('aria-disabled', 'true');\n      const label = this.speechBtn.querySelector('.label');\n      if (label) {\n        label.textContent = 'Speech Not Supported';\n      }\n      if (this.speechFeedback) {\n        this.speechFeedback.dataset.tone = 'warning';\n        this.speechFeedback.textContent = 'Speech recognition is not supported in this browser.';\n      }\n      return;\n    }\n\n    try {\n      this.speechPractice = new SpeechPractice({\n        onStatus: (status: string) => this.updateSpeechStatus(status),\n        onResult: (transcript: string) => this.handleSpeechResult(transcript),\n        onError: (message: string) => this.updateSpeechFeedback(message, 'error')\n      });\n      this.speechPracticeAvailable = true;\n      this.speechBtn.addEventListener('click', () => this.toggleSpeechPractice());\n      this.updateSpeechFeedback('Ready to practice pronunciation.', 'info');\n    } catch (error) {\n      this.speechPracticeAvailable = false;\n      this.speechBtn.setAttribute('disabled', 'disabled');\n      this.speechBtn.setAttribute('aria-disabled', 'true');\n      const label = this.speechBtn.querySelector('.label');\n      if (label) {\n        label.textContent = 'Speech Not Supported';\n      }\n      if (this.speechFeedback) {\n        this.speechFeedback.dataset.tone = 'error';\n        this.speechFeedback.textContent = error instanceof Error ? error.message : 'Speech recognition unavailable.';\n      }\n    }\n  }\n\n  toggleSpeechPractice(): void {\n    if (!this.speechPracticeAvailable || !this.speechPractice) {\n      return;\n    }\n\n    if (!this.currentCard) {\n      this.updateSpeechFeedback('Load a card before practicing pronunciation.', 'warning');\n      return;\n    }\n\n    if (this.isListening) {\n      this.stopSpeechPractice();\n      return;\n    }\n\n    const prompt = this.getCardText(this.currentCard).frontText;\n    this.expectedSpeech = prompt;\n    const langCode = this.languageDirection === 'bg-de' ? 'bg-BG' : 'de-DE';\n\n    this.updateSpeechFeedback(`Listening... say \"${prompt}\"`, 'info');\n    this.speechPractice.start({ lang: langCode });\n  }\n\n  stopSpeechPractice(): void {\n    if (this.speechPractice && this.isListening) {\n      this.speechPractice.stop();\n    }\n    this.isListening = false;\n    if (this.speechBtn) {\n      this.speechBtn.setAttribute('aria-pressed', 'false');\n      const label = this.speechBtn.querySelector('.label');\n      if (label) {\n        label.textContent = 'Practice Pronunciation';\n      }\n    }\n  }\n\n  resetSpeechPracticeForNextCard(): void {\n    this.expectedSpeech = '';\n    this.stopSpeechPractice();\n    if (this.speechPracticeAvailable && this.speechFeedback) {\n      this.lastSpeechTone = 'info';\n      this.speechFeedback.dataset.tone = 'info';\n    }\n  }\n\n  updateSpeechStatus(status: string): void {\n    this.isListening = status === 'listening';\n\n    if (this.speechBtn) {\n      this.speechBtn.setAttribute('aria-pressed', this.isListening ? 'true' : 'false');\n      const label = this.speechBtn.querySelector('.label');\n      if (label) {\n        label.textContent = this.isListening ? 'Stop Listening' : 'Practice Pronunciation';\n      }\n    }\n\n    if (status === 'listening') {\n      this.lastSpeechTone = 'info';\n      if (this.speechFeedback) {\n        this.speechFeedback.dataset.tone = 'info';\n        this.speechFeedback.textContent = 'Listening...';\n      }\n    } else if (status === 'idle' && this.lastSpeechTone === 'info' && this.speechPracticeAvailable) {\n      this.updateSpeechFeedback('Microphone ready.', 'info');\n    }\n  }\n\n  updateSpeechFeedback(message: string, tone = 'info'): void {\n    if (!this.speechFeedback) {\n      return;\n    }\n    this.lastSpeechTone = tone;\n    this.speechFeedback.dataset.tone = tone;\n    this.speechFeedback.textContent = message;\n  }\n\n  handleSpeechResult(transcript: string): void {\n    if (!transcript) {\n      this.updateSpeechFeedback('No audio detected. Please try again.', 'warning');\n      return;\n    }\n\n    const expected = this.normalizeSpeechText(this.expectedSpeech);\n    this.expectedSpeech = '';\n    const heard = this.normalizeSpeechText(transcript);\n\n    this.stopSpeechPractice();\n\n    if (!expected) {\n      this.updateSpeechFeedback(`Heard \"${transcript}\".`, 'info');\n      return;\n    }\n\n    const match =\n      heard.includes(expected) ||\n      expected.includes(heard);\n\n    if (match) {\n      this.updateSpeechFeedback(`Heard \"${transcript}\". Great pronunciation!`, 'success');\n      if (!this.isFlipped) {\n        this.flipCard();\n      }\n      setTimeout(() => this.handleGrade(5), 400);\n    } else {\n      this.updateSpeechFeedback(`Heard \"${transcript}\". Let's try again.`, 'warning');\n    }\n  }\n\n  normalizeSpeechText(value: string): string {\n    if (!value) {\n      return '';\n    }\n    return value\n      .toString()\n      .toLowerCase()\n      .normalize('NFD')\n      .replaceAll(/[\\u0300-\\u036F]/g, '')\n      .replaceAll(/[^\\p{Letter}\\p{Number}\\s]/gu, '')\n      .replaceAll(/\\s+/g, ' ')\n      .trim();\n  }\n\n  updateSpeechPrompt(): void {\n    if (!this.speechPracticeAvailable || !this.speechFeedback || !this.currentCard) {\n      return;\n    }\n\n    const prompt = this.getCardText(this.currentCard).frontText;\n    if (!prompt || this.isListening) {\n      return;\n    }\n\n    this.lastSpeechTone = 'info';\n    this.speechFeedback.dataset.tone = 'info';\n    this.speechFeedback.textContent = `Ready to practice \"${prompt}\" when you press the microphone button.`;\n  }\n\n  async loadVocabulary(): Promise<void> {\n    try {\n      const inlineData = this.readInlineVocabulary();\n      if (inlineData && inlineData.length > 0) {\n        this.vocabularyData = inlineData;\n        return;\n      }\n\n      // Try to load from modular vocabulary API first\n      try {\n        const { vocabularyAPI } = await import('./modules/vocabulary-api.js');\n        const allEntries = await vocabularyAPI.loadAll();\n        \n        if (Array.isArray(allEntries) && allEntries.length > 0) {\n          this.vocabularyData = allEntries;\n          console.log(`[Flashcards] Loaded ${allEntries.length} entries via modular API`);\n          return;\n        }\n      } catch (apiError) {\n        console.warn('[Flashcards] Modular API not available, falling back to fetch:', apiError);\n      }\n\n      // Fallback to fetching from Hugo's data directory\n      let response = await fetch('/data/vocabulary.json');\n\n      // Fallback to static directory if data directory fails\n      if (!response.ok) {\n        response = await fetch('/static/data/vocabulary.json');\n      }\n      \n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n      \n      this.vocabularyData = await response.json();\n      \n      if (!Array.isArray(this.vocabularyData) || this.vocabularyData.length === 0) {\n        throw new Error('Invalid or empty vocabulary data');\n      }\n      \n    } catch (error) {\n      console.error('Failed to load vocabulary:', error);\n      throw new Error(`Failed to load vocabulary: ${(error as Error).message}`);\n    }\n  }\n  \n  async prepareSession(): Promise<void> {\n    let filteredData = this.vocabularyData.filter(item => {\n      const categoryMatch = !this.category || item.category === this.category;\n      const levelMatch = !this.level || item.level === this.level;\n      return categoryMatch && levelMatch;\n    });\n    \n    // Apply mode-specific filtering\n    if (this.mode === 'due') {\n      const dueItems = this.spacedRepetition.getDueItems();\n      filteredData = filteredData.filter(item =>\n        dueItems.some(dueItem => dueItem.itemId === this.generateWordId(item.word))\n      );\n    } else if (this.mode === 'review') {\n      // Filter items that have been reviewed before\n      filteredData = filteredData.filter(item => {\n        const wordId = this.generateWordId(item.word);\n        const state = this.spacedRepetition.loadState(wordId);\n        return state && state.totalReviews > 0;\n      });\n    }\n    \n    if (filteredData.length === 0) {\n      throw new Error(`No vocabulary items found for ${this.mode} mode with current filters`);\n    }\n    \n    // Shuffle if requested\n    if (this.shuffle) {\n      filteredData = this.shuffleArray([...filteredData]);\n    }\n    \n    // Limit session size\n    this.sessionCards = filteredData.slice(0, this.limit);\n    this.sessionStats.totalCards = this.sessionCards.length;\n  }\n  \n  startSession(): void {\n    this.sessionStats.startTime = new Date();\n    this.currentIndex = 0;\n    this.showLoading(false);\n    this.showCard(0);\n    this.updateProgress();\n    \n    // Announce session start to screen readers\n    this.announceToScreenReader(`Starting flashcard session with ${this.sessionStats.totalCards} cards`);\n  }\n  \n  showCard(index: number): void {\n    if (index >= this.sessionCards.length) {\n      this.completeSession();\n      return;\n    }\n    \n    this.currentIndex = index;\n    this.currentCard = this.sessionCards[index] || null;\n    this.isFlipped = false;\n    this.resetSpeechPracticeForNextCard();\n    \n    // Reset card state\n    if (this.flashcard) {\n      this.flashcard.classList.remove('flipped');\n    }\n    if (this.gradingControls) {\n      this.gradingControls.style.display = 'none';\n    }\n    if (this.stage) {\n      this.stage.style.display = 'block';\n    }\n    \n    // Update card content\n    this.updateCardContent();\n    this.updateSpeechPrompt();\n    this.updateProgress();\n    \n    // Focus the card for keyboard navigation\n    if (this.flashcard) {\n      this.flashcard.focus();\n    }\n  }\n  \n  updateCardContent(): void {\n    if (!this.currentCard) {\n      return;\n    }\n    \n    const stats = this.spacedRepetition.getStats();\n    \n    // Get display text based on language direction\n    const { frontText, backText } = this.getCardText(this.currentCard);\n    \n    // Front of card\n    if (this.wordText) {\n      this.wordText.textContent = frontText;\n    }\n    \n    // Meta information\n    const categorySpan = this.wordMeta?.querySelector('.word-category');\n    const levelSpan = this.wordMeta?.querySelector('.word-level');\n    \n    if (categorySpan) {\n      categorySpan.textContent = this.currentCard.category || '';\n      categorySpan.style.display = this.currentCard.category ? 'inline' : 'none';\n    }\n    \n    if (levelSpan) {\n      levelSpan.textContent = this.currentCard.level || '';\n      levelSpan.style.display = this.currentCard.level ? 'inline' : 'none';\n    }\n    \n    // Back of card\n    if (this.translationText) {\n      this.translationText.textContent = backText;\n    }\n    \n    // Notes\n    if (this.wordNotes) {\n      const noteText = this.getCardNote(this.currentCard);\n      this.wordNotes.textContent = noteText || '';\n      this.wordNotes.style.display = noteText ? 'block' : 'none';\n    }\n    \n    // Review statistics\n    this.updateReviewStats(stats);\n    \n    // Update card accessibility\n    if (this.flashcard) {\n      this.flashcard.setAttribute('aria-label', \n        `Flashcard ${this.currentIndex + 1} of ${this.sessionStats.totalCards}: ${frontText}`\n      );\n    }\n  }\n  \n  getCardText(vocab: VocabularyItem): CardText {\n    // Return appropriate text based on language direction\n    if (this.languageDirection === 'bg-de') {\n      // Bulgarian to German: show Bulgarian word, translate to German\n      return {\n        frontText: vocab.word || '',\n        backText: vocab.translation || ''\n      };\n    }\n\n    // German to Bulgarian: show German word, translate to Bulgarian\n    return {\n      frontText: vocab.translation || '',\n      backText: vocab.word || ''\n    };\n  }\n  \n  renderCurrentCard(): void {\n    // Re-render the current card with updated language direction\n    if (this.currentCard) {\n      this.updateCardContent();\n      this.updateSpeechPrompt();\n    }\n  }\n  \n  updateReviewStats(stats: any): void {\n    if (!this.reviewStats) {\n      return;\n    }\n    \n    const totalReviews = this.reviewStats.querySelector('#total-reviews');\n    const wordAccuracy = this.reviewStats.querySelector('#word-accuracy');\n    const wordStreak = this.reviewStats.querySelector('#word-streak');\n    \n    if (totalReviews) {\n      totalReviews.textContent = stats.totalReviews;\n    }\n    if (wordAccuracy) {\n      wordAccuracy.textContent = `${stats.accuracy}%`;\n    }\n    if (wordStreak) {\n      wordStreak.textContent = stats.streak;\n    }\n  }\n  \n  handleCardClick(): void {\n    if (!this.isFlipped) {\n      this.flipCard();\n    }\n  }\n  \n  handleCardKeyboard(e: KeyboardEvent): void {\n    if (e.key === 'Enter' || e.key === ' ') {\n      e.preventDefault();\n      if (!this.isFlipped) {\n        this.flipCard();\n      }\n    }\n  }\n  \n  handleLanguageDirectionChange(e: CustomEvent): void {\n    this.languageDirection = e.detail.direction;\n    this.renderCurrentCard(); // Re-render current card with new direction\n  }\n\n  handleGlobalKeyboard(e: KeyboardEvent): void {\n    // Only handle if flashcards are active\n    if (!this.stage || this.stage.style.display === 'none') {\n      return;\n    }\n\n    // Grade shortcuts (0-5)\n    if (e.key >= '0' && e.key <= '5' && this.isFlipped) {\n      e.preventDefault();\n      const grade = Number.parseInt(e.key);\n      this.handleGrade(grade);\n      return;\n    }\n\n    // Navigation shortcuts\n    switch (e.key) {\n    case 'Escape': {\n      e.preventDefault();\n      this.pauseSession();\n      break;\n    }\n    case 'f':\n    case 'F': {\n      if (!this.isFlipped) {\n        e.preventDefault();\n        this.flipCard();\n      }\n      break;\n    }\n    }\n  }\n  \n  flipCard(): void {\n    if (this.isFlipped) {\n      return;\n    }\n    \n    this.isFlipped = true;\n    if (this.flashcard) {\n      this.flashcard.classList.add('flipped');\n    }\n    \n    // Show grading controls after flip animation\n    setTimeout(() => {\n      if (this.gradingControls) {\n        this.gradingControls.style.display = 'block';\n        \n        // Focus first grade button for keyboard navigation\n        const firstGradeBtn = this.gradingControls.querySelector('.grade-btn');\n        if (firstGradeBtn) {\n          (firstGradeBtn as HTMLElement).focus();\n        }\n      }\n    }, 300);\n    \n    this.announceToScreenReader('Card flipped. Rate your knowledge using buttons or keys 0-5.');\n  }\n  \n  handleGrade(grade: number): void {\n    if (!this.isFlipped || grade < 0 || grade > 5) {\n      return;\n    }\n    \n    const wordId = this.generateWordId(this.currentCard!.word);\n    \n    // Get or initialize review state\n    let reviewState = this.spacedRepetition.loadState(wordId);\n    if (!reviewState) {\n      reviewState = this.spacedRepetition.initReviewState(wordId);\n    }\n    \n    // Update spaced repetition state\n    const updatedState = this.spacedRepetition.scheduleNext(reviewState, grade);\n    \n    // Update session statistics\n    this.sessionStats.reviewedCards++;\n    this.sessionStats.grades.push(grade);\n    \n    if (grade >= 3) {\n      this.sessionStats.correctAnswers++;\n    }\n    \n    // Provide visual feedback\n    this.showGradeFeedback(grade, updatedState);\n    \n    // Move to next card after delay\n    setTimeout(() => {\n      this.showCard(this.currentIndex + 1);\n    }, 1500);\n  }\n  \n  showGradeFeedback(grade: number, reviewState: any): void {\n    const gradeBtn = this.gradingControls?.querySelector(`[data-grade=\"${grade}\"]`);\n    if (gradeBtn) {\n      gradeBtn.classList.add('selected');\n    }\n    \n    // Create feedback message\n    const feedback = document.createElement('div');\n    feedback.className = 'grade-feedback';\n    feedback.innerHTML = `\n      <div class=\"feedback-grade\">Grade: ${grade}</div>\n      <div class=\"feedback-next\">Next review: ${this.formatNextReview(reviewState.nextReviewDate)}</div>\n      <div class=\"feedback-interval\">Interval: ${reviewState.interval} day${reviewState.interval === 1 ? '' : 's'}</div>\n    `;\n    \n    if (this.gradingControls) {\n      this.gradingControls.append(feedback);\n    }\n    \n    // Remove feedback after animation\n    setTimeout(() => {\n      if (feedback.parentNode) {\n        feedback.remove();\n      }\n    }, 1400);\n  }\n  \n  formatNextReview(dateString: string): string {\n    const date = new Date(dateString);\n    const now = new Date();\n    const diffTime = date.getTime() - now.getTime();\n    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));\n    \n    if (diffDays === 0) {\n      return 'Today';\n    }\n    if (diffDays === 1) {\n      return 'Tomorrow';\n    }\n    if (diffDays < 7) {\n      return `In ${diffDays} days`;\n    }\n    if (diffDays < 30) {\n      return `In ${Math.ceil(diffDays / 7)} weeks`;\n    }\n    return `In ${Math.ceil(diffDays / 30)} months`;\n  }\n  \n  updateProgress(): void {\n    const progress = this.sessionStats.totalCards > 0 ? \n      (this.sessionStats.reviewedCards / this.sessionStats.totalCards) * 100 : 0;\n    \n    if (this.progressFill) {\n      this.progressFill.style.width = `${progress}%`;\n    }\n    \n    if (this.sessionProgress) {\n      this.sessionProgress.textContent = \n        `${this.sessionStats.reviewedCards} / ${this.sessionStats.totalCards}`;\n    }\n    \n    if (this.sessionAccuracy) {\n      const accuracy = this.sessionStats.reviewedCards > 0 ? \n        Math.round((this.sessionStats.correctAnswers / this.sessionStats.reviewedCards) * 100) : 0;\n      this.sessionAccuracy.textContent = `${accuracy}% accuracy`;\n    }\n  }\n  \n  pauseSession(): void {\n    this.stopSpeechPractice();\n    // Implementation for pause functionality\n    const pauseOverlay = document.createElement('div');\n    pauseOverlay.className = 'pause-overlay';\n    pauseOverlay.innerHTML = `\n      <div class=\"pause-content\">\n        <h3>Session Paused</h3>\n        <p>Take a break and come back when you're ready.</p>\n        <button class=\"flashcard-btn primary\" id=\"resume-session\">Resume</button>\n        <button class=\"flashcard-btn secondary\" id=\"end-paused-session\">End Session</button>\n      </div>\n    `;\n    \n    this.container.append(pauseOverlay);\n    \n    // Bind resume events\n    const resumeBtn = pauseOverlay.querySelector('#resume-session');\n    const endBtn = pauseOverlay.querySelector('#end-paused-session');\n    \n    if (resumeBtn) {\n      resumeBtn.addEventListener('click', () => {\n        pauseOverlay.remove();\n        if (this.flashcard) {\n          this.flashcard.focus();\n        }\n      });\n    }\n    \n    if (endBtn) {\n      endBtn.addEventListener('click', () => {\n        pauseOverlay.remove();\n        this.endSession();\n      });\n    }\n  }\n  \n  endSession(): void {\n    this.stopSpeechPractice();\n    this.cleanup(); // Remove event listeners\n    this.sessionStats.endTime = new Date();\n    this.completeSession();\n  }\n\n  completeSession(): void {\n    this.stopSpeechPractice();\n    this.sessionStats.endTime = this.sessionStats.endTime || new Date();\n\n    // Hide main interface\n    if (this.stage) {\n      this.stage.style.display = 'none';\n    }\n    if (this.gradingControls) {\n      this.gradingControls.style.display = 'none';\n    }\n\n    // Show completion screen\n    this.showSessionComplete();\n\n    this.announceToScreenReader('Flashcard session completed');\n  }\n\n  /**\n   * Cleanup method to remove event listeners\n   * Prevents keyboard event persistence issues (P1 bug fix)\n   */\n  cleanup(): void {\n    // Remove global keyboard listener\n    if (this.globalKeyListenerAttached) {\n      document.removeEventListener('keydown', this.onGlobalKeydown);\n      this.globalKeyListenerAttached = false;\n    }\n\n    // Remove language direction listener\n    if (this.languageListenerAttached) {\n      document.removeEventListener('language-direction-changed', this.onLanguageDirectionChanged);\n      this.languageListenerAttached = false;\n    }\n\n    // Stop speech practice if active\n    this.stopSpeechPractice();\n  }\n  \n  showSessionComplete(): void {\n    const duration = this.sessionStats.endTime!.getTime() - this.sessionStats.startTime!.getTime();\n    const minutes = Math.round(duration / (1000 * 60));\n    \n    const finalCards = this.container.querySelector('#final-cards');\n    const finalAccuracy = this.container.querySelector('#final-accuracy');\n    const finalTime = this.container.querySelector('#final-time');\n    \n    if (finalCards) {\n      finalCards.textContent = this.sessionStats.reviewedCards.toString();\n    }\n    if (finalAccuracy) {\n      const accuracy = this.sessionStats.reviewedCards > 0 ? \n        Math.round((this.sessionStats.correctAnswers / this.sessionStats.reviewedCards) * 100) : 0;\n      finalAccuracy.textContent = `${accuracy}%`;\n    }\n    if (finalTime) {\n      finalTime.textContent = `${minutes}m`;\n    }\n    \n    // Show/hide review mistakes button\n    const reviewMistakesBtn = this.container.querySelector('#review-mistakes');\n    if (reviewMistakesBtn) {\n      const hasIncorrect = this.sessionStats.grades.some(grade => grade < 3);\n      (reviewMistakesBtn as HTMLElement).style.display = hasIncorrect ? 'inline-block' : 'none';\n    }\n    \n    if (this.sessionComplete) {\n      this.sessionComplete.style.display = 'block';\n    }\n  }\n  \n  startNewSession(): void {\n    this.stopSpeechPractice();\n    // Reset session state\n    this.currentIndex = 0;\n    this.sessionStats = {\n      startTime: null,\n      endTime: null,\n      totalCards: this.sessionStats.totalCards,\n      reviewedCards: 0,\n      correctAnswers: 0,\n      grades: []\n    };\n    \n    // Hide completion screen\n    if (this.sessionComplete) {\n      this.sessionComplete.style.display = 'none';\n    }\n    \n    // Restart session\n    this.startSession();\n  }\n  \n  reviewMistakes(): void {\n    this.stopSpeechPractice();\n    // Filter cards that were graded < 3\n    const mistakeIndices: number[] = [];\n    for (const [index, grade] of this.sessionStats.grades.entries()) {\n      if (grade < 3) {\n        mistakeIndices.push(index);\n      }\n    }\n    \n    if (mistakeIndices.length === 0) {\n      return;\n    }\n    \n    // Create new session with only mistake cards\n    this.sessionCards = mistakeIndices.map(index => this.sessionCards[index]).filter((item): item is VocabularyItem => item !== undefined);\n    this.startNewSession();\n  }\n  \n  backToVocabulary(): void {\n    this.stopSpeechPractice();\n    // Navigate back to vocabulary page\n    window.location.href = '/vocabulary/';\n  }\n  \n  showLoading(show: boolean): void {\n    if (this.loading) {\n      this.loading.style.display = show ? 'flex' : 'none';\n    }\n  }\n  \n  showError(show: boolean, message = ''): void {\n    if (this.error) {\n      this.error.style.display = show ? 'block' : 'none';\n      \n      if (show && message) {\n        const errorMessage = this.error.querySelector('#error-message');\n        if (errorMessage) {\n          errorMessage.textContent = message;\n        }\n      }\n    }\n  }\n  \n  generateWordId(word: string): string {\n    return word.toLowerCase()\n      .replaceAll(/[^\\s\\w-]/g, '')\n      .replaceAll(/\\s+/g, '-')\n      .slice(0, 50);\n  }\n  \n  shuffleArray<T>(array: T[]): T[] {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      const temp = shuffled[i];\n      shuffled[i] = shuffled[j]!;\n      shuffled[j] = temp!;\n    }\n    return shuffled;\n  }\n  \n  announceToScreenReader(message: string): void {\n    const announcement = document.createElement('div');\n    announcement.setAttribute('aria-live', 'polite');\n    announcement.setAttribute('aria-atomic', 'true');\n    announcement.className = 'sr-only';\n    announcement.textContent = message;\n    \n    document.body.append(announcement);\n    \n    setTimeout(() => {\n      announcement.remove();\n    }, 1000);\n  }\n}\n\nexport default Flashcards;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/grammar.ts","messages":[{"ruleId":"unicorn/prefer-query-selector","severity":2,"message":"Prefer `.querySelector()` over `.getElementById()`.","line":320,"column":35,"nodeType":"Identifier","messageId":"prefer-query-selector","endLine":320,"endColumn":49},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":445,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":445,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14025,14028],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14025,14028],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":445,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":445,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14066,14069],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14066,14069],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":446,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":446,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14143,14146],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14143,14146],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":479,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":479,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15098,15101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15098,15101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Grammar management and filtering\ninterface GrammarItem {\n  title: string;\n  description: string;\n  level: string;\n  examples?: string[];\n  notes_bg_to_de?: string;\n  notes_de_to_bg?: string;\n}\n\ninterface GrammarAppOptions {\n  container?: string;\n  data?: GrammarItem[];\n}\n\ninterface GrammarFilters {\n  level: string;\n  search: string;\n}\n\nclass GrammarApp {\n  private container: string;\n  private languageDirection: string;\n  private data: GrammarItem[];\n  private useServerRendering: boolean;\n  private filteredData: GrammarItem[];\n  private filters: GrammarFilters;\n  // private items: Element[]; // Removed unused property\n\n  constructor(options: GrammarAppOptions) {\n    this.container = options.container || '#grammar-list';\n    this.languageDirection = this.getLanguageDirection();\n\n    // If data is provided, use data-based rendering, otherwise use server-rendered DOM\n    this.data = options.data || [];\n    this.useServerRendering = this.data.length === 0;\n    this.filteredData = [...this.data];\n    // this.items = []; // Removed unused property initialization\n\n    this.filters = {\n      level: '',\n      search: ''\n    };\n\n    // If using server-rendered content, get items from DOM\n    // Note: items property removed as it was unused\n\n    this.init();\n  }\n\n  init(): void {\n    this.bindEvents();\n    if (this.useServerRendering) {\n      this.applyFiltersToDOM();\n    }\n    this.updateStats();\n    this.updateDirectionNotes();\n  }\n\n  private getServerRenderedItems(): Element[] {\n    const container = document.querySelector(this.container);\n    if (!container) {\n      return [];\n    }\n    return [...container.querySelectorAll('.grammar-item')];\n  }\n\n  private bindEvents(): void {\n    // Filter controls\n    const levelFilter = document.querySelector('#grammar-level-filter');\n    const searchInput = document.querySelector('#grammar-search');\n    const clearFilters = document.querySelector('#clear-grammar-filters');\n\n    if (levelFilter) {\n      levelFilter.addEventListener('change', (e: Event) => {\n        const target = e.target as HTMLSelectElement;\n        this.filters.level = target.value;\n        this.applyFilters();\n      });\n    }\n\n    if (searchInput) {\n      let searchTimeout: number;\n      searchInput.addEventListener('input', (e: Event) => {\n        const target = e.target as HTMLInputElement;\n        clearTimeout(searchTimeout);\n        searchTimeout = window.setTimeout(() => {\n          this.filters.search = target.value.toLowerCase();\n          this.applyFilters();\n        }, 300);\n      });\n    }\n\n    if (clearFilters) {\n      clearFilters.addEventListener('click', () => {\n        this.clearAllFilters();\n      });\n    }\n\n    document.addEventListener('language-direction-changed', (e: CustomEvent) => {\n      this.languageDirection = e?.detail?.direction || 'bg-de';\n      this.updateDirectionNotes();\n    });\n\n    // Show more examples buttons\n    document.addEventListener('click', (e: Event) => {\n      const target = e.target as HTMLElement;\n      if (target.classList.contains('show-more-examples')) {\n        this.toggleExamples(target);\n      }\n    });\n\n    // Exercise buttons\n    document.addEventListener('click', (e: Event) => {\n      const target = e.target as HTMLElement;\n      if (target.classList.contains('start-exercise-btn')) {\n        const grammarTitle = target.dataset.grammarTitle || '';\n        this.startGrammarExercise(grammarTitle);\n      }\n    });\n\n    // Bookmark buttons\n    document.addEventListener('click', (e: Event) => {\n      const target = e.target as HTMLElement;\n      if (target.classList.contains('bookmark-btn')) {\n        const grammarTitle = target.dataset.grammarTitle || '';\n        this.toggleBookmark(grammarTitle, target);\n      }\n    });\n  }\n\n  private applyFilters(): void {\n    if (this.useServerRendering) {\n      this.applyFiltersToDOM();\n    } else {\n      this.applyFiltersToData();\n    }\n    this.updateStats();\n  }\n\n  private applyFiltersToDOM(): void {\n    const items = this.getServerRenderedItems();\n    let visibleCount = 0;\n\n    for (const item of items) {\n      let shouldShow = true;\n\n      // Level filter\n      if (this.filters.level) {\n        const itemLevel = item.dataset.level || '';\n        if (itemLevel !== this.filters.level) {\n          shouldShow = false;\n        }\n      }\n\n      // Search filter\n      if (this.filters.search && shouldShow) {\n        const itemTitle = item.dataset.title || '';\n        const itemDescription = item.dataset.description || '';\n        const searchableText = itemTitle + ' ' + itemDescription;\n\n        if (!searchableText.includes(this.filters.search)) {\n          shouldShow = false;\n        }\n      }\n\n      (item as HTMLElement).style.display = shouldShow ? '' : 'none';\n      if (shouldShow) {\n        visibleCount++;\n      }\n    }\n\n    // Show/hide no results message\n    const container = document.querySelector(this.container);\n    const noResults = document.querySelector('#grammar-no-results');\n\n    if (visibleCount === 0) {\n      container?.classList.add('no-results-state');\n      noResults?.classList.remove('hidden');\n    } else {\n      container?.classList.remove('no-results-state');\n      noResults?.classList.add('hidden');\n    }\n  }\n\n  private applyFiltersToData(): void {\n    this.filteredData = this.data.filter(item => {\n      // Level filter\n      if (this.filters.level && item.level !== this.filters.level) {\n        return false;\n      }\n\n      // Search filter\n      if (this.filters.search) {\n        const searchTerm = this.filters.search;\n        const searchableText = [\n          item.title,\n          item.description,\n          ...(item.examples || [])\n        ].join(' ').toLowerCase();\n\n        if (!searchableText.includes(searchTerm)) {\n          return false;\n        }\n      }\n\n      return true;\n    });\n\n    this.render();\n  }\n\n  private render(): void {\n    // Only render if using data-based approach (not server rendering)\n    if (this.useServerRendering) {\n      return; // DOM is already rendered by server\n    }\n\n    const container = document.querySelector(this.container);\n    const noResults = document.querySelector('#grammar-no-results');\n\n    if (!container) {\n      return;\n    }\n\n    if (this.filteredData.length === 0) {\n      (container as HTMLElement).style.display = 'none';\n      noResults?.classList.remove('hidden');\n      return;\n    }\n\n    (container as HTMLElement).style.display = 'block';\n    noResults?.classList.add('hidden');\n\n    container.innerHTML = this.filteredData.map(item => this.renderGrammarItem(item)).join('');\n\n    this.updateDirectionNotes();\n  }\n\n  private renderGrammarItem(item: GrammarItem): string {\n    const bookmarked = this.isBookmarked(item.title);\n    const examplesId = `examples-${this.slugify(item.title)}`;\n    const notesHtml = this.buildNotesHtml(item);\n        \n    return `\n            <article class=\"grammar-item\" \n                     data-level=\"${item.level}\" \n                     data-title=\"${item.title.toLowerCase()}\"\n                     data-description=\"${item.description.toLowerCase()}\">\n                <header class=\"grammar-header\">\n                    <h2>${item.title}</h2>\n                    <span class=\"level-badge level-${item.level.toLowerCase()}\">${item.level}</span>\n                </header>\n                \n                <div class=\"grammar-description\">\n                    ${this.markdownToHtml(item.description)}\n                </div>\n                \n                ${notesHtml}\n\n                ${item.examples && item.examples.length > 0 ? `\n                    <div class=\"grammar-examples\">\n                        <h3>Examples:</h3>\n                        <ul class=\"examples-list\" id=\"${examplesId}\">\n                            ${item.examples.slice(0, 3).map(example => \n    `<li class=\"example-item\">${example}</li>`\n  ).join('')}\n                            ${item.examples.length > 3 ? `\n                                <div class=\"hidden-examples hidden\">\n                                    ${item.examples.slice(3).map(example => \n    `<li class=\"example-item\">${example}</li>`\n  ).join('')}\n                                </div>\n                            ` : ''}\n                        </ul>\n                        \n                        ${item.examples.length > 3 ? `\n                            <button class=\"show-more-examples\" data-target=\"${examplesId}\">\n                                Show More Examples (${item.examples.length - 3} more)\n                            </button>\n                        ` : ''}\n                    </div>\n                ` : ''}\n                \n                <div class=\"grammar-actions\">\n                    <button class=\"start-exercise-btn\" data-grammar-title=\"${item.title}\">\n                        Practice This Rule\n                    </button>\n                    <button class=\"bookmark-btn ${bookmarked ? 'bookmarked' : ''}\" \n                            data-grammar-title=\"${item.title}\" \n                            title=\"${bookmarked ? 'Remove bookmark' : 'Bookmark this rule'}\">\n                        ${bookmarked ? '⭐' : '☆'}\n                    </button>\n                </div>\n            </article>\n        `;\n  }\n\n  private buildNotesHtml(item: GrammarItem): string {\n    const notesBg = item.notes_bg_to_de ? this.escapeHtml(item.notes_bg_to_de) : '';\n    const notesDe = item.notes_de_to_bg ? this.escapeHtml(item.notes_de_to_bg) : '';\n\n    if (!notesBg && !notesDe) {\n      return '';\n    }\n\n    const showBg = this.languageDirection === 'bg-de';\n    const showDe = this.languageDirection === 'de-bg';\n\n    return `\n            <div class=\"grammar-notes\" aria-live=\"polite\">\n                ${notesBg ? `<div class=\"grammar-note-direction\" data-direction=\"bg-de\" style=\"${showBg ? '' : 'display:none;'}\">${notesBg}</div>` : ''}\n                ${notesDe ? `<div class=\"grammar-note-direction\" data-direction=\"de-bg\" style=\"${showDe ? '' : 'display:none;'}\">${notesDe}</div>` : ''}\n            </div>\n        `;\n  }\n\n  private toggleExamples(button: HTMLElement): void {\n    const targetId = button.dataset.target || '';\n    const examplesList = document.getElementById(targetId);\n    const hiddenExamples = examplesList?.querySelector('.hidden-examples');\n        \n    if (hiddenExamples) {\n      const isHidden = hiddenExamples.classList.contains('hidden');\n      hiddenExamples.classList.toggle('hidden');\n      button.textContent = isHidden ? 'Show Fewer Examples' : `Show More Examples (${hiddenExamples.children.length} more)`;\n    }\n  }\n\n  private startGrammarExercise(grammarTitle: string): void {\n    const grammarItem = this.data.find(item => item.title === grammarTitle);\n    if (!grammarItem) {\n      return;\n    }\n\n    // Store grammar exercise data\n    sessionStorage.setItem('practice-session', JSON.stringify({\n      items: [grammarItem],\n      type: 'grammar',\n      timestamp: Date.now()\n    }));\n\n    // Navigate to practice page (relative to parent)\n    window.location.href = '../practice/';\n  }\n\n  private toggleBookmark(grammarTitle: string, button: HTMLElement): void {\n    const bookmarks = this.getBookmarks();\n    const isBookmarked = bookmarks.includes(grammarTitle);\n        \n    if (isBookmarked) {\n      const index = bookmarks.indexOf(grammarTitle);\n      bookmarks.splice(index, 1);\n      button.classList.remove('bookmarked');\n      button.textContent = '☆';\n      button.title = 'Bookmark this rule';\n    } else {\n      bookmarks.push(grammarTitle);\n      button.classList.add('bookmarked');\n      button.textContent = '⭐';\n      button.title = 'Remove bookmark';\n    }\n        \n    localStorage.setItem('grammar-bookmarks', JSON.stringify(bookmarks));\n  }\n\n  private isBookmarked(grammarTitle: string): boolean {\n    const bookmarks = this.getBookmarks();\n    return bookmarks.includes(grammarTitle);\n  }\n\n  private getBookmarks(): string[] {\n    const stored = localStorage.getItem('grammar-bookmarks');\n    return stored ? JSON.parse(stored) : [];\n  }\n\n  private updateStats(): void {\n    const totalCount = document.querySelector('#grammar-total');\n    const showingCount = document.querySelector('#grammar-showing');\n\n    if (this.useServerRendering) {\n      const items = this.getServerRenderedItems();\n      const visibleItems = items.filter(item => (item as HTMLElement).style.display !== 'none');\n\n      if (totalCount) {\n        totalCount.textContent = items.length.toString();\n      }\n      if (showingCount) {\n        showingCount.textContent = visibleItems.length.toString();\n      }\n    } else {\n      if (totalCount) {\n        totalCount.textContent = this.data.length.toString();\n      }\n      if (showingCount) {\n        showingCount.textContent = this.filteredData.length.toString();\n      }\n    }\n  }\n\n  private updateDirectionNotes(): void {\n    const containers = document.querySelectorAll('.grammar-notes');\n    for (const container of containers) {\n      const notes = [...container.querySelectorAll('.grammar-note-direction')];\n      let shown = false;\n      for (const note of notes) {\n        if (!note.dataset.direction) {\n          continue;\n        }\n        const shouldShow = note.dataset.direction === this.languageDirection;\n        (note as HTMLElement).style.display = shouldShow ? '' : 'none';\n        if (shouldShow) {\n          shown = true;\n        }\n      }\n\n      if (!shown) {\n        const fallback = notes[0];\n        if (fallback) {\n          (fallback as HTMLElement).style.display = '';\n        }\n      }\n    }\n  }\n\n  private clearAllFilters(): void {\n    this.filters = { level: '', search: '' };\n        \n    // Reset form controls\n    const levelFilter = document.querySelector('#grammar-level-filter');\n    const searchInput = document.querySelector('#grammar-search');\n\n    if (levelFilter) {\n      (levelFilter as HTMLSelectElement).value = '';\n    }\n    if (searchInput) {\n      (searchInput as HTMLInputElement).value = '';\n    }\n\n    this.applyFilters();\n  }\n\n  private getLanguageDirection(): string {\n    try {\n      if ((window as any).languageToggle && typeof (window as any).languageToggle.getDirection === 'function') {\n        return (window as any).languageToggle.getDirection();\n      }\n      const stored = localStorage.getItem('bgde:language-direction') || localStorage.getItem('bgde:learning_direction');\n      return stored === 'de-bg' ? 'de-bg' : 'bg-de';\n    } catch {\n      return 'bg-de';\n    }\n  }\n\n  private markdownToHtml(text: string): string {\n    // Simple markdown conversion for basic formatting\n    return text\n      .replaceAll(/\\*\\*(.*?)\\*\\*/g, '<strong>$1</strong>')\n      .replaceAll(/\\*(.*?)\\*/g, '<em>$1</em>')\n      .replaceAll(/`(.*?)`/g, '<code>$1</code>')\n      .replaceAll('\\n', '<br>');\n  }\n\n  private slugify(text: string): string {\n    return text.toLowerCase()\n      .replaceAll(/[^\\s\\w-]/g, '')\n      .replaceAll(/[\\s_-]+/g, '-')\n      .replaceAll(/^-+|-+$/g, '');\n  }\n\n  private escapeHtml(text: string): string {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n}\n\n// Export for use in templates\n(window as any).GrammarApp = GrammarApp;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/home.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":3,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[65,68],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[65,68],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":5,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[113,116],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[113,116],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_e' is defined but never used.","line":19,"column":51,"nodeType":"Identifier","messageId":"unusedVar","endLine":19,"endColumn":60},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[582,585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[582,585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":47,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":47,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1331,1334],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1331,1334],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":67,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":67,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1971,1974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1971,1974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":81,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":81,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2451,2454],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2451,2454],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2703,2706],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2703,2706],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Home page functionality\nclass HomeApp {\n  private vocabulary: any[];\n  \n  constructor(options: { vocabulary?: any[] }) {\n    this.vocabulary = options.vocabulary || [];\n    this.init();\n  }\n\n  init(): void {\n    this.updateActivityCards();\n    this.bindEvents();\n  }\n\n  bindEvents(): void {\n    // Hero action buttons\n    const startLearningBtn = document.querySelector('a[href=\"/practice/\"]');\n    if (startLearningBtn) {\n      startLearningBtn.addEventListener('click', (_e: Event): void => {\n        // Check if there are items to practice\n        const dueItems = (window as any).progressTracker?.getDueItems(this.vocabulary) || [];\n        if (dueItems.length === 0 && this.vocabulary.length > 0) {\n          // Start with new items if no due items\n          const newItems = this.vocabulary.slice(0, 10);\n          sessionStorage.setItem('practice-session', JSON.stringify({\n            items: newItems,\n            type: 'vocabulary',\n            timestamp: Date.now()\n          }));\n        }\n      });\n    }\n  }\n\n  updateActivityCards(): void {\n    this.updateDueItemsCard();\n    this.updateNewItemsCard();\n    this.updateStreakCard();\n  }\n\n  updateDueItemsCard(): void {\n    const dueCountElement = document.querySelector('#due-count');\n    if (!dueCountElement) {\n      return;\n    }\n\n    const dueItems = (window as any).progressTracker?.getDueItems(this.vocabulary) || [];\n    const count = dueItems.length;\n\n    if (count === 0) {\n      dueCountElement.textContent = 'All caught up! 🎉';\n      const actionElement = dueCountElement.parentElement?.querySelector('.activity-action');\n      if (actionElement) {\n        actionElement.textContent = 'Browse Vocabulary';\n      }\n    } else {\n      dueCountElement.textContent = `${count} item${count === 1 ? '' : 's'}`;\n    }\n  }\n\n  updateNewItemsCard(): void {\n    const newCountElement = document.querySelector('#new-count');\n    if (!newCountElement) {\n      return;\n    }\n\n    const progress = (window as any).progressTracker?.data.vocabulary || {};\n    const studiedWords = Object.keys(progress);\n    const newItems = this.vocabulary.filter(item => !studiedWords.includes(item.word));\n    const count = newItems.length;\n\n    newCountElement.textContent = `${count} item${count === 1 ? '' : 's'}`;\n  }\n\n  updateStreakCard(): void {\n    const streakCountElement = document.querySelector('#streak-count');\n    if (!streakCountElement) {\n      return;\n    }\n\n    const stats = (window as any).progressTracker?.getStats() || { streak: 0 };\n    const streak = stats.streak;\n\n    streakCountElement.textContent = streak === 0 ? 'Start your streak!' : `${streak} day${streak === 1 ? '' : 's'}`;\n  }\n}\n\n// Export for use in templates\n(window as any).HomeApp = HomeApp;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/language-toggle-confirmation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":219,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7073,7076],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7073,7076],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Language Toggle Confirmation Modal\n * Ensures users understand the impact of switching learning direction\n * For Vincent (DE) and Ida (BG)\n */\n\ntype Direction = 'de-bg' | 'bg-de';\n\ninterface DirectionInfo {\n  icon: string;\n  text: string;\n  lang: 'de' | 'bg';\n  description: string;\n  impact1: string;\n  impact2: string;\n  impact3: string;\n}\n\nclass LanguageToggleConfirmation {\n  private isModalOpen = false;\n  private pendingDirection: Direction | null = null;\n  private callback: ((direction: Direction) => void) | null = null;\n  private escapeHandler: ((e: KeyboardEvent) => void) | null = null;\n  \n  show(currentDirection: Direction, newDirection: Direction, onConfirm: (direction: Direction) => void): void {\n    if (this.isModalOpen) {\n      return;\n    }\n    \n    this.pendingDirection = newDirection;\n    this.callback = onConfirm;\n    this.isModalOpen = true;\n    \n    this.createModal(currentDirection, newDirection);\n  }\n  \n  private createModal(currentDirection: Direction, newDirection: Direction): void {\n    // Create modal overlay\n    const overlay = document.createElement('div');\n    overlay.id = 'language-toggle-confirmation-overlay';\n    overlay.className = 'confirmation-overlay';\n    overlay.setAttribute('role', 'dialog');\n    overlay.setAttribute('aria-modal', 'true');\n    overlay.setAttribute('aria-labelledby', 'confirmation-title');\n    \n    const currentInfo = this.getDirectionInfo(currentDirection);\n    const newInfo = this.getDirectionInfo(newDirection);\n    \n    const modal = document.createElement('div');\n    modal.className = 'confirmation-modal';\n    modal.innerHTML = `\n      <div class=\"confirmation-header\">\n        <h2 id=\"confirmation-title\" class=\"confirmation-title\">\n          ${currentInfo.lang === 'de' ? 'Lernrichtung wechseln?' : 'Смяна на посоката на обучение?'}\n        </h2>\n      </div>\n      \n      <div class=\"confirmation-content\">\n        <div class=\"confirmation-current\">\n          <span class=\"confirmation-label\">\n            ${currentInfo.lang === 'de' ? 'Aktuell' : 'Текущо'}:\n          </span>\n          <div class=\"direction-badge direction-current\">\n            <span class=\"direction-icon\">${currentInfo.icon}</span>\n            <span class=\"direction-text\">${currentInfo.text}</span>\n          </div>\n          <p class=\"direction-description\">${currentInfo.description}</p>\n        </div>\n        \n        <div class=\"confirmation-arrow\">\n          <span aria-hidden=\"true\">↓</span>\n        </div>\n        \n        <div class=\"confirmation-new\">\n          <span class=\"confirmation-label\">\n            ${currentInfo.lang === 'de' ? 'Neu' : 'Ново'}:\n          </span>\n          <div class=\"direction-badge direction-new\">\n            <span class=\"direction-icon\">${newInfo.icon}</span>\n            <span class=\"direction-text\">${newInfo.text}</span>\n          </div>\n          <p class=\"direction-description\">${newInfo.description}</p>\n        </div>\n        \n        <div class=\"confirmation-impact\">\n          <p class=\"impact-title\">\n            ${currentInfo.lang === 'de' ? 'Dies wird:' : 'Това ще:'}\n          </p>\n          <ul class=\"impact-list\">\n            <li>\n              <span class=\"impact-icon\">🔄</span>\n              <span class=\"impact-text\">${newInfo.impact1}</span>\n            </li>\n            <li>\n              <span class=\"impact-icon\">📊</span>\n              <span class=\"impact-text\">${newInfo.impact2}</span>\n            </li>\n            <li>\n              <span class=\"impact-icon\">💾</span>\n              <span class=\"impact-text\">${newInfo.impact3}</span>\n            </li>\n          </ul>\n        </div>\n      </div>\n      \n      <div class=\"confirmation-footer\">\n        <button class=\"confirmation-cancel btn-secondary\" id=\"confirmation-cancel\">\n          ${currentInfo.lang === 'de' ? 'Abbrechen' : 'Отказ'}\n        </button>\n        <button class=\"confirmation-confirm btn-primary\" id=\"confirmation-confirm\">\n          ${currentInfo.lang === 'de' ? 'Richtung wechseln' : 'Смяна на посоката'}\n        </button>\n      </div>\n    `;\n    \n    overlay.append(modal);\n    document.body.append(overlay);\n    \n    // Bind events\n    overlay.querySelector('#confirmation-cancel')?.addEventListener('click', () => this.cancel());\n    overlay.querySelector('#confirmation-confirm')?.addEventListener('click', () => this.confirm());\n    \n    // Close on overlay click\n    overlay.addEventListener('click', (e) => {\n      if (e.target === overlay) {\n        this.cancel();\n      }\n    });\n    \n    // Close on Escape key\n    this.escapeHandler = (e: KeyboardEvent) => {\n      if (e.key === 'Escape') {\n        this.cancel();\n      }\n    };\n    document.addEventListener('keydown', this.escapeHandler);\n    \n    // Prevent background scrolling\n    document.body.style.overflow = 'hidden';\n    \n    // Focus confirm button\n    setTimeout(() => {\n      (overlay.querySelector('#confirmation-confirm') as HTMLElement)?.focus();\n    }, 100);\n    \n    // Announce to screen readers\n    this.announceToScreenReader(`Direction change confirmation. Current: ${currentInfo.text}. New: ${newInfo.text}`);\n  }\n  \n  private getDirectionInfo(direction: Direction): DirectionInfo {\n    const info: Record<Direction, DirectionInfo> = {\n      'de-bg': {\n        icon: '🇩🇪→🇧🇬',\n        text: 'Deutsch → Bulgarisch',\n        lang: 'de',\n        description: 'Sie lernen Bulgarisch aus deutscher Perspektive',\n        impact1: 'Bulgarische Wörter auf Lernkarten anzeigen',\n        impact2: 'Schwierigkeitsgrad an DE→BG anpassen',\n        impact3: 'Alle Übungssitzungen aktualisieren'\n      },\n      'bg-de': {\n        icon: '🇧🇬→🇩🇪',\n        text: 'Български → Deutsch',\n        lang: 'bg',\n        description: 'Вие учите немски от българска перспектива',\n        impact1: 'Показване на немски думи на карти',\n        impact2: 'Адаптиране на трудността към BG→DE',\n        impact3: 'Актуализиране на всички сесии'\n      }\n    };\n    \n    return info[direction] || info['de-bg'];\n  }\n  \n  private confirm(): void {\n    if (this.callback && this.pendingDirection) {\n      this.callback(this.pendingDirection);\n    }\n    this.close();\n  }\n  \n  private cancel(): void {\n    this.announceToScreenReader('Direction change cancelled');\n    this.close();\n  }\n  \n  private close(): void {\n    const overlay = document.querySelector('#language-toggle-confirmation-overlay');\n    if (overlay) {\n      overlay.remove();\n    }\n    \n    // Restore body scrolling\n    document.body.style.overflow = '';\n    \n    // Remove escape handler\n    if (this.escapeHandler) {\n      document.removeEventListener('keydown', this.escapeHandler);\n    }\n    \n    this.isModalOpen = false;\n    this.pendingDirection = null;\n    this.callback = null;\n  }\n  \n  private announceToScreenReader(message: string): void {\n    const announcer = document.querySelector('#sr-announcements');\n    if (announcer) {\n      announcer.textContent = message;\n      setTimeout(() => {\n        announcer.textContent = '';\n      }, 3000);\n    }\n  }\n}\n\n// Make globally available\nif (typeof window !== 'undefined') {\n  (window as any).LanguageToggleConfirmation = LanguageToggleConfirmation;\n  console.log('[LanguageToggleConfirmation] Module loaded');\n}\n\nexport default LanguageToggleConfirmation;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/language-toggle.ts","messages":[{"ruleId":"unicorn/consistent-function-scoping","severity":2,"message":"Move arrow function 'handleExternalChange' to the outer scope.","line":191,"column":55,"nodeType":"ArrowFunctionExpression","messageId":"consistent-function-scoping","endLine":191,"endColumn":57},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":221,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7186,7189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7186,7189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":225,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":225,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7404,7407],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7404,7407],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":569,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":569,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18448,18451],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18448,18451],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":570,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":570,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18511,18514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18511,18514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":573,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":573,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18573,18576],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18573,18576],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":574,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":574,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18624,18627],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18624,18627],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file language-toggle.ts\n * @description Bidirectional language learning direction controller\n * @status ACTIVE\n * @dependencies None (pure implementation)\n * @used_by flashcards.js, vocab-cards.js, enhanced-*.js modules, layouts/partials/language-toggle.html\n * @features\n *   - Toggle between BG→DE and DE→BG learning directions\n *   - localStorage persistence (bgde:language-direction)\n *   - Event-based notifications for direction changes\n *   - Cultural context adaptation based on native language\n *   - Difficulty multipliers for SM-2 (BG→DE: 1.2x, DE→BG: 1.1x)\n * @see docs/BIDIRECTIONAL_IMPLEMENTATION_PLAN.md for design\n * @version 2.0.0\n * @updated October 2025\n */\n\nconst DIRECTION = {\n  BG_TO_DE: 'bg-de',\n  DE_TO_BG: 'de-bg'\n} as const;\n\nconst DEFAULT_DIRECTION = DIRECTION.DE_TO_BG;\nconst VALID_DIRECTIONS = new Set([DIRECTION.BG_TO_DE, DIRECTION.DE_TO_BG]);\n\ntype Direction = typeof DIRECTION[keyof typeof DIRECTION];\n\ninterface DirectionConfig {\n  text: string;\n  subtitle: string;\n  title: string;\n  ariaLabel: string;\n  leftFlag: string;\n  rightFlag: string;\n}\n\ninterface LanguageLabels {\n  source: { code: string; name: string; flag: string };\n  target: { code: string; name: string; flag: string };\n  sourceField: string;\n  targetField: string;\n}\n\ninterface GradeInfo {\n  label: string;\n  desc: string;\n}\n\ninterface UITexts {\n  loading: string;\n  error: string;\n  retry: string;\n  noCards: string;\n  categories: string;\n  levels: string;\n  shuffle: string;\n  flip: string;\n  grade: string;\n  gradeHelp: string;\n  grades: Record<number, GradeInfo>;\n  sessionComplete: string;\n  newSession: string;\n  backToVocab: string;\n}\n\ninterface SetDirectionOptions {\n  silent?: boolean;\n  announce?: boolean;\n}\n\nclass LanguageToggle {\n  private storageKey = 'bgde:language-direction';\n  private legacyStorageKey = 'bgde:learning_direction';\n  private currentDirection: Direction;\n  private toggleButton: HTMLButtonElement | null = null;\n\n  constructor() {\n    this.currentDirection = this.loadDirection();\n    this.init();\n  }\n\n  init(): void {\n    this.createToggleButton();\n    this.applyDirection();\n    this.bindEvents();\n  }\n\n  private createToggleButton(): void {\n    let container = document.querySelector('[data-language-toggle]') as HTMLElement;\n\n    if (container) {\n      container.classList.add('language-controls');\n      container.innerHTML = '';\n    } else {\n      container = document.querySelector('.theme-toggle-container') as HTMLElement;\n\n      if (!container) {\n        container = document.createElement('div');\n        container.className = 'language-controls';\n\n        const header = document.querySelector('header') || document.querySelector('.header');\n        if (header) {\n          header.append(container);\n        } else {\n          container.classList.add('floating-controls');\n          document.body.append(container);\n        }\n      }\n    }\n\n    const toggleButton = document.createElement('button');\n    toggleButton.className = 'language-toggle-btn';\n    toggleButton.type = 'button';\n    toggleButton.id = 'language-toggle-button';\n    \n    // Enhanced accessibility\n    toggleButton.setAttribute('aria-pressed', 'false');\n    toggleButton.setAttribute('aria-describedby', 'language-toggle-description');\n\n    // Create hidden description for screen readers\n    const description = document.createElement('span');\n    description.id = 'language-toggle-description';\n    description.className = 'sr-only';\n    description.textContent = 'Click to switch learning direction between German to Bulgarian and Bulgarian to German';\n    \n    this.updateToggleButton(toggleButton);\n\n    container.append(toggleButton);\n    container.append(description);\n    this.toggleButton = toggleButton;\n  }\n\n  private updateToggleButton(button: HTMLButtonElement | null): void {\n    if (!button) {\n      return;\n    }\n\n    const directions: Record<Direction, DirectionConfig> = {\n      [DIRECTION.DE_TO_BG]: {\n        text: 'DE → BG',\n        subtitle: 'Deutsch zu Bulgarisch',\n        title: 'Learning Bulgarian (from German perspective)',\n        ariaLabel: 'Switch learning direction. Currently German to Bulgarian. Click to change to Bulgarian to German.',\n        leftFlag: 'de',\n        rightFlag: 'bg'\n      },\n      [DIRECTION.BG_TO_DE]: {\n        text: 'BG → DE',\n        subtitle: 'Български към Немски',\n        title: 'Learning German (from Bulgarian perspective)',\n        ariaLabel: 'Switch learning direction. Currently Bulgarian to German. Click to change to German to Bulgarian.',\n        leftFlag: 'bg',\n        rightFlag: 'de'\n      }\n    };\n\n    const current = directions[this.currentDirection] || directions[DEFAULT_DIRECTION];\n    const partnerDirection = this.currentDirection === DIRECTION.DE_TO_BG\n      ? directions[DIRECTION.BG_TO_DE]\n      : directions[DIRECTION.DE_TO_BG];\n\n    button.innerHTML = `\n      <span class=\"toggle-flag flag-${current.leftFlag}\" aria-hidden=\"true\"></span>\n      <span class=\"toggle-arrow\" aria-hidden=\"true\">\n        <span class=\"arrow-icon\"></span>\n      </span>\n      <span class=\"toggle-flag flag-${current.rightFlag}\" aria-hidden=\"true\"></span>\n      <span class=\"toggle-text\" aria-hidden=\"true\">\n        <span class=\"toggle-direction\">${current.text}</span>\n        <span class=\"toggle-subtitle\">${current.subtitle}</span>\n      </span>\n      <span class=\"sr-only\">${current.ariaLabel}</span>\n    `;\n\n    button.setAttribute('title', current.title);\n    button.setAttribute('aria-label', current.ariaLabel);\n    button.dataset.direction = this.currentDirection;\n    if (partnerDirection) {\n      button.dataset.nextDirection = partnerDirection.leftFlag + '-' + partnerDirection.rightFlag;\n    }\n  }\n\n  private bindEvents(): void {\n    if (this.toggleButton) {\n      this.toggleButton.addEventListener('click', () => this.toggleDirection());\n      this.toggleButton.addEventListener('animationend', () => {\n        this.toggleButton?.classList.remove('is-animating');\n      });\n    }\n\n    const handleExternalChange = (event: CustomEvent) => {\n      const detail = event?.detail;\n      if (!detail || detail.source === 'language-toggle') {\n        return;\n      }\n\n      this.setDirection(detail.direction, { silent: true });\n    };\n\n    document.addEventListener('language-direction-changed', handleExternalChange as EventListener);\n    document.addEventListener('languageDirectionChanged', handleExternalChange as EventListener);\n    window.addEventListener('learning-direction-changed', handleExternalChange as EventListener);\n\n    window.addEventListener('storage', (event: StorageEvent) => {\n      if (event.key === this.storageKey) {\n        this.setDirection(event.newValue as Direction, { silent: true });\n      } else if (event.key === this.legacyStorageKey) {\n        const migrated = this.migrateLegacyDirection(event.newValue || undefined);\n        if (migrated) {\n          this.setDirection(migrated, { silent: true });\n        }\n      }\n    });\n  }\n\n  toggleDirection(): void {\n    const nextDirection: Direction =\n      this.currentDirection === DIRECTION.DE_TO_BG ? DIRECTION.BG_TO_DE : DIRECTION.DE_TO_BG;\n\n    // Show confirmation modal if available\n    if ((window as any).LanguageToggleConfirmation === undefined) {\n      // Fallback: direct change without confirmation\n      this.setDirection(nextDirection, { announce: true });\n    } else {\n      const confirmation = new (window as any).LanguageToggleConfirmation();\n      confirmation.show(\n        this.currentDirection,\n        nextDirection,\n        (confirmedDirection: Direction) => {\n          // User confirmed, proceed with change\n          this.setDirection(confirmedDirection, { announce: true });\n        }\n      );\n    }\n  }\n\n  setDirection(direction: Direction, { silent = false, announce = false }: SetDirectionOptions = {}): void {\n    const normalized = this.normalizeDirection(direction) || DEFAULT_DIRECTION;\n    const previousDirection = this.currentDirection;\n    const changed = normalized !== this.currentDirection;\n\n    this.currentDirection = normalized;\n    this.saveDirection();\n    this.applyDirection();\n    this.updateToggleButton(this.toggleButton);\n    if (this.toggleButton) {\n      this.toggleButton.dataset.prevDirection = previousDirection || '';\n      if (changed) {\n        // Trigger morph animation\n        void this.toggleButton.offsetWidth;\n        this.toggleButton.classList.add('is-animating');\n      }\n    }\n\n    if (changed && !silent) {\n      this.broadcastDirectionChange();\n      if (announce) {\n        this.announceDirectionChange();\n      }\n    }\n  }\n\n  private applyDirection(): void {\n    const body = document.body;\n    if (body) {\n      if (body.classList) {\n        body.classList.remove('lang-de-bg', 'lang-bg-de');\n        body.classList.add(`lang-${this.currentDirection}`);\n      }\n\n      if (body.dataset) {\n        body.dataset.languageDirection = this.currentDirection;\n      }\n    }\n\n    const isGermanBase = this.isGermanBase();\n    document.documentElement.setAttribute('lang', isGermanBase ? 'de' : 'bg');\n\n    this.updateMetaDescription();\n  }\n\n  private updateMetaDescription(): void {\n    const descriptions: Record<Direction, string> = {\n      [DIRECTION.DE_TO_BG]:\n        'Bulgarisch lernen für Deutsche - Interaktive Vokabeln und Grammatik mit Spaced Repetition',\n      [DIRECTION.BG_TO_DE]:\n        'Учене на немски за българи - Интерактивни думи и граматика със система за повторение'\n    };\n\n    const content = descriptions[this.currentDirection] || descriptions[DEFAULT_DIRECTION];\n\n    let metaDesc = document.querySelector('meta[name=\"description\"]');\n    if (!metaDesc) {\n      metaDesc = document.createElement('meta');\n      metaDesc.setAttribute('name', 'description');\n      document.head.append(metaDesc);\n    }\n\n    metaDesc.setAttribute('content', content);\n  }\n\n  private broadcastDirectionChange(): void {\n    const detail = {\n      direction: this.currentDirection,\n      isGermanBase: this.isGermanBase(),\n      isBulgarianBase: this.isBulgarianBase(),\n      source: 'language-toggle'\n    };\n\n    document.dispatchEvent(new CustomEvent('language-direction-changed', { detail }));\n    document.dispatchEvent(new CustomEvent('languageDirectionChanged', { detail }));\n    window.dispatchEvent(new CustomEvent('learning-direction-changed', { detail }));\n  }\n\n  private announceDirectionChange(): void {\n    const announcements: Record<Direction, string> = {\n      [DIRECTION.DE_TO_BG]: 'Switched to German to Bulgarian learning mode. You will now see Bulgarian words to translate to German.',\n      [DIRECTION.BG_TO_DE]: 'Switched to Bulgarian to German learning mode. You will now see German words to translate to Bulgarian.'\n    };\n\n    const message = announcements[this.currentDirection] || announcements[DEFAULT_DIRECTION];\n    this.announceToScreenReader(message);\n    this.showToastNotification(message);\n  }\n\n  getDirection(): Direction {\n    return this.currentDirection;\n  }\n\n  isGermanBase(): boolean {\n    return this.currentDirection === DIRECTION.DE_TO_BG;\n  }\n\n  isBulgarianBase(): boolean {\n    return this.currentDirection === DIRECTION.BG_TO_DE;\n  }\n\n  getSourceLanguage(): string {\n    return this.isGermanBase() ? 'de' : 'bg';\n  }\n\n  getTargetLanguage(): string {\n    return this.isGermanBase() ? 'bg' : 'de';\n  }\n\n  getLanguageLabels(): LanguageLabels {\n    if (this.isGermanBase()) {\n      return {\n        source: { code: 'de', name: 'Deutsch', flag: '🇩🇪' },\n        target: { code: 'bg', name: 'Български', flag: '🇧🇬' },\n        sourceField: 'translation',\n        targetField: 'word'\n      };\n    }\n\n    return {\n      source: { code: 'bg', name: 'Български', flag: '🇧🇬' },\n      target: { code: 'de', name: 'Deutsch', flag: '🇩🇪' },\n      sourceField: 'word',\n      targetField: 'translation'\n    };\n  }\n\n  getUITexts(): UITexts {\n    const texts: Record<Direction, UITexts> = {\n      [DIRECTION.DE_TO_BG]: {\n        loading: 'Lade Vokabeln...',\n        error: 'Fehler beim Laden der Vokabeln',\n        retry: 'Erneut versuchen',\n        noCards: 'Keine Vokabelkarten gefunden',\n        categories: 'Kategorien',\n        levels: 'Niveaus',\n        shuffle: 'Mischen',\n        flip: 'Umdrehen',\n        grade: 'Bewerten Sie Ihr Wissen',\n        gradeHelp: 'Bewerten Sie, wie gut Sie dieses Wort kannten',\n        grades: {\n          0: { label: 'Keine Ahnung', desc: 'Völlig unbekannt' },\n          1: { label: 'Falsch', desc: 'Falsch aber bekannt' },\n          2: { label: 'Nah dran', desc: 'Falsch aber nah' },\n          3: { label: 'Schwer', desc: 'Richtig mit Mühe' },\n          4: { label: 'Gut', desc: 'Richtig nach Nachdenken' },\n          5: { label: 'Einfach', desc: 'Perfekte Erinnerung' }\n        },\n        sessionComplete: 'Sitzung abgeschlossen!',\n        newSession: 'Neue Sitzung',\n        backToVocab: 'Zurück zu Vokabeln'\n      },\n      [DIRECTION.BG_TO_DE]: {\n        loading: 'Зареждане на думи...',\n        error: 'Грешка при зареждане на думите',\n        retry: 'Опитай отново',\n        noCards: 'Няма намерени карти с думи',\n        categories: 'Категории',\n        levels: 'Нива',\n        shuffle: 'Разбъркай',\n        flip: 'Обърни',\n        grade: 'Оценете знанието си',\n        gradeHelp: 'Оценете колко добре знаехте тази дума',\n        grades: {\n          0: { label: 'Без идея', desc: 'Напълно непознато' },\n          1: { label: 'Грешно', desc: 'Грешно но познато' },\n          2: { label: 'Близо', desc: 'Грешно но близо' },\n          3: { label: 'Трудно', desc: 'Правилно с усилие' },\n          4: { label: 'Добре', desc: 'Правилно след размисъл' },\n          5: { label: 'Лесно', desc: 'Перфектна памет' }\n        },\n        sessionComplete: 'Сесията завърши!',\n        newSession: 'Нова сесия',\n        backToVocab: 'Обратно към думи'\n      }\n    };\n\n    return texts[this.currentDirection] || texts[DEFAULT_DIRECTION];\n  }\n\n  private loadDirection(): Direction {\n    try {\n      const migrated = this.migrateLegacyDirection();\n      if (migrated) {\n        return migrated;\n      }\n\n      const stored = localStorage.getItem(this.storageKey);\n      return this.normalizeDirection(stored) || DEFAULT_DIRECTION;\n    } catch (error) {\n      console.warn('Failed to load language direction:', error);\n      return DEFAULT_DIRECTION;\n    }\n  }\n\n  private migrateLegacyDirection(explicitValue?: string): Direction | null {\n    try {\n      const legacyValue =\n        explicitValue === undefined ? localStorage.getItem(this.legacyStorageKey) : explicitValue;\n\n      if (!legacyValue) {\n        return null;\n      }\n\n      const normalized = this.normalizeDirection(legacyValue);\n      if (normalized) {\n        localStorage.setItem(this.storageKey, normalized);\n      }\n\n      localStorage.removeItem(this.legacyStorageKey);\n      return normalized;\n    } catch (error) {\n      console.warn('Failed to migrate legacy language direction:', error);\n      return null;\n    }\n  }\n\n  private normalizeDirection(value: string | null): Direction | null {\n    if (!value) {\n      return null;\n    }\n\n    const normalized = value.toString().toLowerCase();\n\n    if (normalized === 'bg-de' || normalized === 'bg_to_de') {\n      return DIRECTION.BG_TO_DE;\n    }\n\n    if (normalized === 'de-bg' || normalized === 'de_to_bg') {\n      return DIRECTION.DE_TO_BG;\n    }\n\n    return VALID_DIRECTIONS.has(normalized as Direction) ? normalized as Direction : null;\n  }\n\n  private saveDirection(): void {\n    try {\n      localStorage.setItem(this.storageKey, this.currentDirection);\n    } catch (error) {\n      console.warn('Failed to save language direction:', error);\n    }\n  }\n\n  private announceToScreenReader(message: string): void {\n    // Use global announcement region if available\n    const globalAnnouncer = document.querySelector('#sr-announcements');\n    if (globalAnnouncer) {\n      globalAnnouncer.textContent = message;\n      setTimeout(() => {\n        globalAnnouncer.textContent = '';\n      }, 3000);\n    } else {\n      // Fallback: create temporary element\n      const announcement = document.createElement('div');\n      announcement.setAttribute('role', 'status');\n      announcement.setAttribute('aria-live', 'polite');\n      announcement.className = 'sr-only';\n      announcement.textContent = message;\n\n      document.body.append(announcement);\n\n      setTimeout(() => {\n        announcement.remove();\n      }, 1000);\n    }\n  }\n  \n  private showToastNotification(message: string): void {\n    // Check if toast container exists, create if not\n    let toastContainer = document.querySelector('#toast-container');\n    if (!toastContainer) {\n      toastContainer = document.createElement('div');\n      toastContainer.id = 'toast-container';\n      toastContainer.className = 'toast-container';\n      toastContainer.setAttribute('aria-live', 'polite');\n      toastContainer.setAttribute('aria-atomic', 'true');\n      document.body.append(toastContainer);\n    }\n    \n    // Create toast\n    const toast = document.createElement('div');\n    toast.className = 'toast toast-success';\n    toast.setAttribute('role', 'alert');\n    \n    const directionInfo = this.currentDirection === DIRECTION.DE_TO_BG \n      ? '🇩🇪 → 🇧🇬' \n      : '🇧🇬 → 🇩🇪';\n    \n    toast.innerHTML = `\n      <span class=\"toast-icon\" aria-hidden=\"true\">✓</span>\n      <span class=\"toast-message\">\n        <strong>${directionInfo}</strong><br>\n        ${message}\n      </span>\n    `;\n    \n    toastContainer.append(toast);\n    \n    // Trigger animation\n    setTimeout(() => {\n      toast.classList.add('toast-show');\n    }, 10);\n    \n    // Auto-remove after 4 seconds\n    setTimeout(() => {\n      toast.classList.remove('toast-show');\n      setTimeout(() => {\n        if (toast.parentNode === toastContainer) {\n          toast.remove();\n        }\n      }, 300);\n    }, 4000);\n  }\n}\n\nlet languageToggle: LanguageToggle | { \n  currentDirection: Direction;\n  getDirection: () => Direction;\n  isGermanBase: () => boolean;\n  isBulgarianBase: () => boolean;\n  getSourceLanguage: () => string;\n  getTargetLanguage: () => string;\n  getLanguageLabels: () => LanguageLabels;\n  getUITexts: () => UITexts;\n  toggleDirection: () => void;\n  setDirection: (direction: Direction, options?: SetDirectionOptions) => void;\n  applyDirection: () => void;\n  updateToggleButton: (button: HTMLButtonElement | null) => void;\n  announceToScreenReader: (message: string) => void;\n};\n\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n  languageToggle = (window as any).languageToggle instanceof LanguageToggle\n    ? (window as any).languageToggle\n    : new LanguageToggle();\n\n  (window as any).languageToggle = languageToggle;\n  (window as any).LanguageToggle = LanguageToggle;\n} else {\n  const noop = () => {};\n  languageToggle = {\n    currentDirection: DEFAULT_DIRECTION,\n    getDirection: () => DEFAULT_DIRECTION,\n    isGermanBase: () => DEFAULT_DIRECTION === 'de-bg',\n    isBulgarianBase: () => false,\n    getSourceLanguage: () => (DEFAULT_DIRECTION === 'de-bg' ? 'de' : 'bg'),\n    getTargetLanguage: () => (DEFAULT_DIRECTION === 'de-bg' ? 'bg' : 'de'),\n    getLanguageLabels: () => ({\n      source: { code: 'de', name: 'Deutsch', flag: '🇩🇪' },\n      target: { code: 'bg', name: 'Български', flag: '🇧🇬' },\n      sourceField: 'translation',\n      targetField: 'word'\n    }),\n    getUITexts: () => ({\n      loading: 'Loading...',\n      error: 'Unable to load data',\n      retry: 'Retry',\n      noCards: 'No cards found',\n      categories: 'Categories',\n      levels: 'Levels',\n      shuffle: 'Shuffle',\n      flip: 'Flip',\n      grade: 'Grade your knowledge',\n      gradeHelp: 'Rate how well you knew this word',\n      grades: {\n        0: { label: 'No idea', desc: 'Completely unknown' },\n        1: { label: 'Wrong', desc: 'Wrong but known' },\n        2: { label: 'Close', desc: 'Wrong but close' },\n        3: { label: 'Hard', desc: 'Correct with effort' },\n        4: { label: 'Good', desc: 'Correct after thinking' },\n        5: { label: 'Easy', desc: 'Perfect memory' }\n      },\n      sessionComplete: 'Session complete!',\n      newSession: 'New session',\n      backToVocab: 'Back to vocabulary'\n    }),\n    toggleDirection: noop,\n    setDirection: noop,\n    applyDirection: noop,\n    updateToggleButton: noop,\n    announceToScreenReader: noop\n  };\n}\n\nexport { languageToggle, LanguageToggle, DIRECTION };\nexport default languageToggle;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/mobile-menu.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":88,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":88,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2424,2427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2424,2427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2488,2491],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2488,2491],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Mobile Menu Toggle\n * Handles the mobile navigation menu toggle functionality\n * Note: This class is not exported as a module - it's instantiated automatically\n * and available globally for debugging if needed via window.MobileMenu\n */\n\nclass MobileMenu {\n  private menuToggle: HTMLElement | null;\n  private navMenu: HTMLElement | null;\n\n  constructor() {\n    this.menuToggle = document.querySelector('#mobile-menu-toggle');\n    this.navMenu = document.querySelector('#nav-menu');\n\n    if (this.menuToggle && this.navMenu) {\n      this.init();\n    }\n  }\n\n  init(): void {\n    // Toggle menu on button click\n    this.menuToggle!.addEventListener('click', () => {\n      this.toggleMenu();\n    });\n\n    // Close menu when clicking outside\n    document.addEventListener('click', (e: MouseEvent) => {\n      const target = e.target as HTMLElement;\n      if (!this.menuToggle!.contains(target) && !this.navMenu!.contains(target)) {\n        this.closeMenu();\n      }\n    });\n\n    // Close menu when pressing Escape key\n    document.addEventListener('keydown', (e: KeyboardEvent) => {\n      if (e.key === 'Escape' && this.isMenuOpen()) {\n        this.closeMenu();\n      }\n    });\n\n    // Close menu when window is resized to desktop\n    window.addEventListener('resize', () => {\n      if (window.innerWidth >= 768 && this.isMenuOpen()) {\n        this.closeMenu();\n      }\n    });\n\n    // Close menu when navigating to a new page\n    const navLinks = this.navMenu!.querySelectorAll('.nav-link');\n    for (const link of navLinks) {\n      link.addEventListener('click', () => {\n        this.closeMenu();\n      });\n    }\n  }\n\n  toggleMenu(): void {\n    if (this.isMenuOpen()) {\n      this.closeMenu();\n    } else {\n      this.openMenu();\n    }\n  }\n\n  openMenu(): void {\n    this.navMenu!.classList.add('mobile-menu-open');\n    this.menuToggle!.setAttribute('aria-expanded', 'true');\n    // Prevent body scroll when menu is open\n    document.body.style.overflow = 'hidden';\n  }\n\n  closeMenu(): void {\n    this.navMenu!.classList.remove('mobile-menu-open');\n    this.menuToggle!.setAttribute('aria-expanded', 'false');\n    // Restore body scroll\n    document.body.style.overflow = '';\n  }\n\n  isMenuOpen(): boolean {\n    return this.navMenu!.classList.contains('mobile-menu-open');\n  }\n}\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    (window as any).mobileMenu = new MobileMenu();\n  });\n} else {\n  (window as any).mobileMenu = new MobileMenu();\n}","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/api-client.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/learning-session.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'direction' is assigned a value but never used.","line":169,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":169,"endColumn":52}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Learning Session Service\n// Manages practice sessions, item selection, and session analytics\n\nclass LearningSession {\n  constructor(options = {}) {\n    this.sessionId = this.generateSessionId();\n    this.storageKey = 'bgde:learning-sessions';\n    \n    // Session configuration\n    this.config = {\n      maxItems: options.maxItems || 20,\n      sessionType: options.sessionType || 'mixed', // 'vocabulary', 'grammar', 'mixed'\n      difficulty: options.difficulty || 'adaptive',\n      categories: options.categories || [],\n      levels: options.levels || ['A1', 'A2'],\n      direction: options.direction || 'bg-de',\n      reviewType: options.reviewType || 'due', // 'due', 'new', 'review', 'mixed'\n      ...options\n    };\n    \n    // Session state\n    this.state = {\n      status: 'initialized', // 'initialized', 'active', 'paused', 'completed', 'abandoned'\n      currentIndex: 0,\n      items: [],\n      responses: [],\n      startTime: null,\n      endTime: null,\n      pausedTime: 0,\n      lastActivityTime: Date.now()\n    };\n    \n    // Session statistics\n    this.stats = {\n      totalItems: 0,\n      completedItems: 0,\n      correctAnswers: 0,\n      incorrectAnswers: 0,\n      skippedItems: 0,\n      hintsUsed: 0,\n      averageResponseTime: 0,\n      totalTime: 0,\n      accuracy: 0,\n      streak: 0,\n      maxStreak: 0\n    };\n    \n    // Event listeners\n    this.listeners = new Map();\n    \n    // Auto-save interval\n    this.autoSaveInterval = null;\n    \n    // Initialize session\n    this.initialize();\n  }\n\n  // Session lifecycle\n  async initialize() {\n    try {\n      // Load any existing session data\n      this.loadSession();\n      \n      // Generate items for the session\n      await this.generateSessionItems();\n      \n      // Set up auto-save\n      this.setupAutoSave();\n      \n      this.emit('initialized', { sessionId: this.sessionId, config: this.config });\n      \n    } catch (error) {\n      console.error('[LearningSession] Initialization failed:', error);\n      this.emit('error', { type: 'initialization', error });\n    }\n  }\n\n  async start() {\n    if (this.state.status !== 'initialized' && this.state.status !== 'paused') {\n      throw new Error('Session cannot be started from current state');\n    }\n    \n    this.state.status = 'active';\n    this.state.startTime = this.state.startTime || Date.now();\n    this.state.lastActivityTime = Date.now();\n    \n    this.emit('started', { sessionId: this.sessionId });\n    this.saveSession();\n    \n    return this.getCurrentItem();\n  }\n\n  pause() {\n    if (this.state.status !== 'active') {\n      throw new Error('Session is not active');\n    }\n    \n    this.state.status = 'paused';\n    this.state.pausedTime += Date.now() - this.state.lastActivityTime;\n    \n    this.emit('paused', { sessionId: this.sessionId });\n    this.saveSession();\n  }\n\n  resume() {\n    if (this.state.status !== 'paused') {\n      throw new Error('Session is not paused');\n    }\n    \n    this.state.status = 'active';\n    this.state.lastActivityTime = Date.now();\n    \n    this.emit('resumed', { sessionId: this.sessionId });\n    this.saveSession();\n    \n    return this.getCurrentItem();\n  }\n\n  complete() {\n    this.state.status = 'completed';\n    this.state.endTime = Date.now();\n    \n    this.calculateFinalStats();\n    this.emit('completed', { \n      sessionId: this.sessionId, \n      stats: this.stats,\n      duration: this.getTotalTime()\n    });\n    \n    this.saveSession();\n    this.clearAutoSave();\n    \n    return this.getSessionSummary();\n  }\n\n  abandon() {\n    this.state.status = 'abandoned';\n    this.state.endTime = Date.now();\n    \n    this.calculateFinalStats();\n    this.emit('abandoned', { sessionId: this.sessionId, stats: this.stats });\n    \n    this.saveSession();\n    this.clearAutoSave();\n  }\n\n  // Item management\n  async generateSessionItems() {\n    try {\n      // Get items based on session configuration\n      const items = await this.selectItems();\n      \n      // Shuffle items for variety\n      this.state.items = this.shuffleArray([...items]);\n      this.stats.totalItems = this.state.items.length;\n      \n      this.emit('itemsGenerated', { \n        count: this.state.items.length,\n        types: this.getItemTypeDistribution()\n      });\n      \n    } catch (error) {\n      console.error('[LearningSession] Failed to generate items:', error);\n      throw error;\n    }\n  }\n\n  async selectItems() {\n    const { maxItems, categories, levels, direction, reviewType } = this.config;\n    \n    // This would typically call the API client or spaced repetition service\n    // For now, we'll simulate the selection logic\n    \n    let selectedItems = [];\n    \n    switch (reviewType) {\n    case 'due': {\n      // Get due items from spaced repetition\n      selectedItems = await this.getDueItems();\n    \n      break;\n    }\n    case 'new': {\n      // Get new items user hasn't seen\n      selectedItems = await this.getNewItems();\n    \n      break;\n    }\n    case 'review': {\n      // Get items for review (recently learned)\n      selectedItems = await this.getReviewItems();\n    \n      break;\n    }\n    default: {\n      // Mixed selection\n      const dueItems = await this.getDueItems();\n      const newItems = await this.getNewItems();\n      const reviewItems = await this.getReviewItems();\n      \n      // Balance the selection\n      selectedItems = [\n        ...dueItems.slice(0, Math.floor(maxItems * 0.5)),\n        ...newItems.slice(0, Math.floor(maxItems * 0.3)),\n        ...reviewItems.slice(0, Math.floor(maxItems * 0.2))\n      ];\n    }\n    }\n    \n    // Apply filters\n    selectedItems = selectedItems.filter(item => {\n      if (categories.length > 0 && !categories.includes(item.category)) {\n        return false;\n      }\n      if (levels.length > 0 && !levels.includes(item.level)) {\n        return false;\n      }\n      return true;\n    });\n    \n    // Limit to max items\n    return selectedItems.slice(0, maxItems);\n  }\n\n  async getDueItems() {\n    // Placeholder - would integrate with spaced repetition service\n    return [];\n  }\n\n  async getNewItems() {\n    // Placeholder - would get items user hasn't practiced\n    return [];\n  }\n\n  async getReviewItems() {\n    // Placeholder - would get recently learned items\n    return [];\n  }\n\n  getCurrentItem() {\n    if (this.state.currentIndex >= this.state.items.length) {\n      return null;\n    }\n    \n    const item = this.state.items[this.state.currentIndex];\n    return {\n      ...item,\n      index: this.state.currentIndex,\n      total: this.state.items.length,\n      progress: (this.state.currentIndex / this.state.items.length) * 100\n    };\n  }\n\n  // Response handling\n  submitResponse(response) {\n    const currentItem = this.getCurrentItem();\n    if (!currentItem) {\n      throw new Error('No current item to respond to');\n    }\n    \n    const responseData = {\n      itemId: currentItem.id,\n      response: response.answer,\n      isCorrect: response.isCorrect,\n      responseTime: response.responseTime || 0,\n      hintsUsed: response.hintsUsed || 0,\n      timestamp: Date.now(),\n      difficulty: response.difficulty || 'medium'\n    };\n    \n    // Store the response\n    this.state.responses.push(responseData);\n    \n    // Update statistics\n    this.updateStats(responseData);\n    \n    // Update spaced repetition data\n    this.updateSpacedRepetition(currentItem, responseData);\n    \n    // Move to next item\n    this.state.currentIndex++;\n    this.state.lastActivityTime = Date.now();\n    \n    this.emit('responseSubmitted', { \n      response: responseData, \n      currentItem,\n      nextItem: this.getCurrentItem()\n    });\n    \n    // Check if session is complete\n    if (this.state.currentIndex >= this.state.items.length) {\n      this.complete();\n      return null;\n    }\n    \n    this.saveSession();\n    return this.getCurrentItem();\n  }\n\n  skipItem(reason = 'user_skip') {\n    const currentItem = this.getCurrentItem();\n    if (!currentItem) {\n      throw new Error('No current item to skip');\n    }\n    \n    const skipData = {\n      itemId: currentItem.id,\n      reason: reason,\n      timestamp: Date.now()\n    };\n    \n    this.state.responses.push({\n      ...skipData,\n      response: null,\n      isCorrect: false,\n      responseTime: 0,\n      hintsUsed: 0\n    });\n    \n    this.stats.skippedItems++;\n    this.stats.streak = 0; // Reset streak on skip\n    \n    this.state.currentIndex++;\n    this.state.lastActivityTime = Date.now();\n    \n    this.emit('itemSkipped', { skipData, currentItem });\n    \n    if (this.state.currentIndex >= this.state.items.length) {\n      this.complete();\n      return null;\n    }\n    \n    this.saveSession();\n    return this.getCurrentItem();\n  }\n\n  // Statistics and analytics\n  updateStats(responseData) {\n    this.stats.completedItems++;\n    \n    if (responseData.isCorrect) {\n      this.stats.correctAnswers++;\n      this.stats.streak++;\n      this.stats.maxStreak = Math.max(this.stats.maxStreak, this.stats.streak);\n    } else {\n      this.stats.incorrectAnswers++;\n      this.stats.streak = 0;\n    }\n    \n    this.stats.hintsUsed += responseData.hintsUsed;\n    \n    // Update average response time\n    const totalResponseTime = this.stats.averageResponseTime * (this.stats.completedItems - 1) + responseData.responseTime;\n    this.stats.averageResponseTime = totalResponseTime / this.stats.completedItems;\n    \n    // Calculate accuracy\n    this.stats.accuracy = (this.stats.correctAnswers / this.stats.completedItems) * 100;\n  }\n\n  calculateFinalStats() {\n    this.stats.totalTime = this.getTotalTime();\n    \n    // Calculate additional metrics\n    this.stats.itemsPerMinute = this.stats.totalTime > 0 ? \n      (this.stats.completedItems / (this.stats.totalTime / 60_000)) : 0;\n    \n    this.stats.efficiencyScore = this.calculateEfficiencyScore();\n    this.stats.difficultyRating = this.calculateDifficultyRating();\n  }\n\n  calculateEfficiencyScore() {\n    // Combine accuracy, speed, and hint usage into efficiency score\n    const accuracyWeight = 0.5;\n    const speedWeight = 0.3;\n    const hintWeight = 0.2;\n    \n    const accuracyScore = this.stats.accuracy;\n    const speedScore = Math.max(0, 100 - (this.stats.averageResponseTime / 1000) * 10);\n    const hintScore = Math.max(0, 100 - (this.stats.hintsUsed / this.stats.completedItems) * 50);\n    \n    return (accuracyScore * accuracyWeight + speedScore * speedWeight + hintScore * hintWeight);\n  }\n\n  calculateDifficultyRating() {\n    // Estimate session difficulty based on performance\n    if (this.stats.accuracy >= 90) {\n      return 'easy';\n    }\n    if (this.stats.accuracy >= 70) {\n      return 'medium';\n    }\n    if (this.stats.accuracy >= 50) {\n      return 'hard';\n    }\n    return 'very_hard';\n  }\n\n  // Spaced repetition integration\n  updateSpacedRepetition(item, response) {\n    // This would integrate with the spaced repetition service\n    // to update review intervals based on performance\n    \n    const grade = this.responseToGrade(response);\n    \n    // Emit event for spaced repetition service to handle\n    this.emit('updateSpacedRepetition', {\n      itemId: item.id,\n      grade: grade,\n      direction: this.config.direction,\n      timestamp: response.timestamp\n    });\n  }\n\n  responseToGrade(response) {\n    // Convert response to SM-2 grade (0-5)\n    if (!response.isCorrect) {\n      return 0;\n    } // Failed\n    \n    if (response.hintsUsed > 0) {\n      return 3;\n    } // Correct with hints\n    if (response.responseTime > 10_000) {\n      return 4;\n    } // Slow but correct\n    return 5; // Quick and correct\n  }\n\n  // Persistence\n  saveSession() {\n    try {\n      const sessionData = {\n        sessionId: this.sessionId,\n        config: this.config,\n        state: this.state,\n        stats: this.stats,\n        lastSaved: Date.now()\n      };\n      \n      const sessions = this.loadAllSessions();\n      sessions[this.sessionId] = sessionData;\n      \n      localStorage.setItem(this.storageKey, JSON.stringify(sessions));\n      \n    } catch (error) {\n      console.error('[LearningSession] Failed to save session:', error);\n    }\n  }\n\n  loadSession() {\n    try {\n      const sessions = this.loadAllSessions();\n      const sessionData = sessions[this.sessionId];\n      \n      if (sessionData) {\n        this.config = { ...this.config, ...sessionData.config };\n        this.state = { ...this.state, ...sessionData.state };\n        this.stats = { ...this.stats, ...sessionData.stats };\n      }\n      \n    } catch (error) {\n      console.error('[LearningSession] Failed to load session:', error);\n    }\n  }\n\n  loadAllSessions() {\n    try {\n      const stored = localStorage.getItem(this.storageKey);\n      return stored ? JSON.parse(stored) : {};\n    } catch (error) {\n      console.error('[LearningSession] Failed to load sessions:', error);\n      return {};\n    }\n  }\n\n  // Utility methods\n  generateSessionId() {\n    // Use crypto.getRandomValues for secure randomness\n    const array = new Uint8Array(9);\n    window.crypto.getRandomValues(array);\n    const randomStr = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');\n    return `session_${Date.now()}_${randomStr}`;\n  }\n\n  shuffleArray(array) {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    return shuffled;\n  }\n\n  getTotalTime() {\n    if (!this.state.startTime) {\n      return 0;\n    }\n    \n    const endTime = this.state.endTime || Date.now();\n    return endTime - this.state.startTime - this.state.pausedTime;\n  }\n\n  getProgress() {\n    return {\n      current: this.state.currentIndex,\n      total: this.state.items.length,\n      percentage: (this.state.currentIndex / this.state.items.length) * 100,\n      completed: this.state.status === 'completed'\n    };\n  }\n\n  getSessionSummary() {\n    return {\n      sessionId: this.sessionId,\n      config: this.config,\n      stats: this.stats,\n      duration: this.getTotalTime(),\n      progress: this.getProgress(),\n      status: this.state.status,\n      responses: this.state.responses\n    };\n  }\n\n  getItemTypeDistribution() {\n    const distribution = {};\n    for (const item of this.state.items) {\n      const type = item.type || 'vocabulary';\n      distribution[type] = (distribution[type] || 0) + 1;\n    }\n    return distribution;\n  }\n\n  // Auto-save functionality\n  setupAutoSave() {\n    this.clearAutoSave();\n    this.autoSaveInterval = setInterval(() => {\n      if (this.state.status === 'active') {\n        this.saveSession();\n      }\n    }, 30_000); // Auto-save every 30 seconds\n  }\n\n  clearAutoSave() {\n    if (this.autoSaveInterval) {\n      clearInterval(this.autoSaveInterval);\n      this.autoSaveInterval = null;\n    }\n  }\n\n  // Event system\n  on(event, callback) {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, new Set());\n    }\n    this.listeners.get(event).add(callback);\n    \n    return () => this.off(event, callback);\n  }\n\n  off(event, callback) {\n    if (this.listeners.has(event)) {\n      this.listeners.get(event).delete(callback);\n    }\n  }\n\n  emit(event, data) {\n    if (this.listeners.has(event)) {\n      for (const callback of this.listeners.get(event)) {\n        try {\n          callback(data);\n        } catch (error) {\n          console.error('[LearningSession] Event listener error:', error);\n        }\n      }\n    }\n  }\n\n  // Cleanup\n  destroy() {\n    this.clearAutoSave();\n    this.listeners.clear();\n    \n    if (this.state.status === 'active') {\n      this.abandon();\n    }\n  }\n}\n\nexport default LearningSession;\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/performance-monitor.js","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'key' is assigned a value but never used.","line":563,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":563,"endColumn":20},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":635,"column":23,"nodeType":"Identifier","messageId":"error/identifier","endLine":635,"endColumn":30},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":641,"column":24,"nodeType":"Identifier","messageId":"error/identifier","endLine":641,"endColumn":31}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Performance Monitor with Web Vitals\n// Tracks Core Web Vitals, custom metrics, and performance analytics\n\nclass PerformanceMonitor {\n  constructor() {\n    this.metrics = new Map();\n    this.observers = new Map();\n    this.config = {\n      enableWebVitals: true,\n      enableCustomMetrics: true,\n      enableResourceTiming: true,\n      enableNavigationTiming: true,\n      sampleRate: 1, // 100% sampling by default\n      reportingEndpoint: null,\n      bufferSize: 100,\n      reportingInterval: 30_000 // 30 seconds\n    };\n    \n    this.buffer = [];\n    this.reportingTimer = null;\n    this.sessionId = this.generateSessionId();\n    this.pageLoadTime = performance.now();\n    \n    this.init();\n  }\n\n  init() {\n    if (!this.shouldSample()) {\n      return;\n    }\n\n    // Initialize Web Vitals monitoring\n    if (this.config.enableWebVitals) {\n      this.initWebVitals();\n    }\n\n    // Initialize custom metrics\n    if (this.config.enableCustomMetrics) {\n      this.initCustomMetrics();\n    }\n\n    // Initialize resource timing\n    if (this.config.enableResourceTiming) {\n      this.initResourceTiming();\n    }\n\n    // Initialize navigation timing\n    if (this.config.enableNavigationTiming) {\n      this.initNavigationTiming();\n    }\n\n    // Set up periodic reporting\n    this.setupReporting();\n\n    // Listen for page visibility changes\n    this.setupVisibilityTracking();\n\n    console.log('[PerformanceMonitor] Initialized with session:', this.sessionId);\n  }\n\n  // Web Vitals Implementation\n  initWebVitals() {\n    // Largest Contentful Paint (LCP)\n    this.observeLCP();\n    \n    // First Input Delay (FID)\n    this.observeFID();\n    \n    // Cumulative Layout Shift (CLS)\n    this.observeCLS();\n    \n    // First Contentful Paint (FCP)\n    this.observeFCP();\n    \n    // Time to First Byte (TTFB)\n    this.observeTTFB();\n  }\n\n  observeLCP() {\n    if (!('PerformanceObserver' in window)) {\n      return;\n    }\n\n    try {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        const lastEntry = entries.at(-1);\n        \n        this.recordMetric('LCP', {\n          value: lastEntry.startTime,\n          element: lastEntry.element?.tagName || 'unknown',\n          url: lastEntry.url || '',\n          timestamp: Date.now(),\n          rating: this.rateLCP(lastEntry.startTime)\n        });\n      });\n\n      observer.observe({ entryTypes: ['largest-contentful-paint'] });\n      this.observers.set('lcp', observer);\n    } catch (error) {\n      console.warn('[PerformanceMonitor] LCP observation failed:', error);\n    }\n  }\n\n  observeFID() {\n    if (!('PerformanceObserver' in window)) {\n      return;\n    }\n\n    try {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        \n        for (const entry of entries) {\n          this.recordMetric('FID', {\n            value: entry.processingStart - entry.startTime,\n            eventType: entry.name,\n            timestamp: Date.now(),\n            rating: this.rateFID(entry.processingStart - entry.startTime)\n          });\n        }\n      });\n\n      observer.observe({ entryTypes: ['first-input'] });\n      this.observers.set('fid', observer);\n    } catch (error) {\n      console.warn('[PerformanceMonitor] FID observation failed:', error);\n    }\n  }\n\n  observeCLS() {\n    if (!('PerformanceObserver' in window)) {\n      return;\n    }\n\n    let clsValue = 0;\n    let sessionValue = 0;\n    let sessionEntries = [];\n\n    try {\n      const observer = new PerformanceObserver((list) => {\n        for (const entry of list.getEntries()) {\n          if (!entry.hadRecentInput) {\n            const firstSessionEntry = sessionEntries[0];\n            const lastSessionEntry = sessionEntries.at(-1);\n\n            if (sessionValue && \n                entry.startTime - lastSessionEntry.startTime < 1000 &&\n                entry.startTime - firstSessionEntry.startTime < 5000) {\n              sessionValue += entry.value;\n              sessionEntries.push(entry);\n            } else {\n              sessionValue = entry.value;\n              sessionEntries = [entry];\n            }\n\n            if (sessionValue > clsValue) {\n              clsValue = sessionValue;\n              \n              this.recordMetric('CLS', {\n                value: clsValue,\n                entries: sessionEntries.length,\n                timestamp: Date.now(),\n                rating: this.rateCLS(clsValue)\n              });\n            }\n          }\n        }\n      });\n\n      observer.observe({ entryTypes: ['layout-shift'] });\n      this.observers.set('cls', observer);\n    } catch (error) {\n      console.warn('[PerformanceMonitor] CLS observation failed:', error);\n    }\n  }\n\n  observeFCP() {\n    if (!('PerformanceObserver' in window)) {\n      return;\n    }\n\n    try {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        \n        for (const entry of entries) {\n          if (entry.name === 'first-contentful-paint') {\n            this.recordMetric('FCP', {\n              value: entry.startTime,\n              timestamp: Date.now(),\n              rating: this.rateFCP(entry.startTime)\n            });\n          }\n        }\n      });\n\n      observer.observe({ entryTypes: ['paint'] });\n      this.observers.set('fcp', observer);\n    } catch (error) {\n      console.warn('[PerformanceMonitor] FCP observation failed:', error);\n    }\n  }\n\n  observeTTFB() {\n    try {\n      const navigationEntry = performance.getEntriesByType('navigation')[0];\n      if (navigationEntry) {\n        const ttfb = navigationEntry.responseStart - navigationEntry.requestStart;\n        \n        this.recordMetric('TTFB', {\n          value: ttfb,\n          timestamp: Date.now(),\n          rating: this.rateTTFB(ttfb)\n        });\n      }\n    } catch (error) {\n      console.warn('[PerformanceMonitor] TTFB measurement failed:', error);\n    }\n  }\n\n  // Custom Metrics\n  initCustomMetrics() {\n    // Vocabulary loading time\n    this.trackVocabularyLoading();\n    \n    // Search performance\n    this.trackSearchPerformance();\n    \n    // Practice session metrics\n    this.trackPracticeSession();\n    \n    // Memory usage\n    this.trackMemoryUsage();\n    \n    // JavaScript errors\n    this.trackJavaScriptErrors();\n  }\n\n  trackVocabularyLoading() {\n    const startTime = performance.now();\n    \n    // Monitor when vocabulary data is loaded\n    document.addEventListener('DOMContentLoaded', () => {\n      const vocabContainer = document.querySelector('#vocabulary-grid');\n      if (vocabContainer) {\n        const observer = new MutationObserver((mutations) => {\n          for (const mutation of mutations) {\n            if (mutation.type === 'childList' && mutation.addedNodes.length > 0) {\n              const loadTime = performance.now() - startTime;\n              \n              this.recordMetric('VocabularyLoadTime', {\n                value: loadTime,\n                itemCount: vocabContainer.children.length,\n                timestamp: Date.now(),\n                rating: loadTime < 1000 ? 'good' : (loadTime < 2500 ? 'needs-improvement' : 'poor')\n              });\n              \n              observer.disconnect();\n            }\n          }\n        });\n        \n        observer.observe(vocabContainer, { childList: true });\n      }\n    });\n  }\n\n  trackSearchPerformance() {\n    // This would be called by the search engine\n    window.addEventListener('search-performed', (event) => {\n      const { query, resultCount, responseTime } = event.detail;\n      \n      this.recordMetric('SearchPerformance', {\n        query: query.slice(0, 50), // Limit query length for privacy\n        resultCount,\n        responseTime,\n        timestamp: Date.now(),\n        rating: responseTime < 100 ? 'good' : (responseTime < 300 ? 'needs-improvement' : 'poor')\n      });\n    });\n  }\n\n  trackPracticeSession() {\n    // Track practice session metrics\n    window.addEventListener('practice-session-completed', (event) => {\n      const { duration, accuracy, itemCount } = event.detail;\n      \n      this.recordMetric('PracticeSession', {\n        duration,\n        accuracy,\n        itemCount,\n        itemsPerMinute: itemCount / (duration / 60_000),\n        timestamp: Date.now()\n      });\n    });\n  }\n\n  trackMemoryUsage() {\n    if ('memory' in performance) {\n      setInterval(() => {\n        const memory = performance.memory;\n        \n        this.recordMetric('MemoryUsage', {\n          usedJSHeapSize: memory.usedJSHeapSize,\n          totalJSHeapSize: memory.totalJSHeapSize,\n          jsHeapSizeLimit: memory.jsHeapSizeLimit,\n          timestamp: Date.now()\n        });\n      }, 30_000); // Every 30 seconds\n    }\n  }\n\n  trackJavaScriptErrors() {\n    window.addEventListener('error', (event) => {\n      this.recordMetric('JavaScriptError', {\n        message: event.message,\n        filename: event.filename,\n        lineno: event.lineno,\n        colno: event.colno,\n        stack: event.error?.stack?.slice(0, 500) || '',\n        timestamp: Date.now()\n      });\n    });\n\n    window.addEventListener('unhandledrejection', (event) => {\n      this.recordMetric('UnhandledPromiseRejection', {\n        reason: event.reason?.toString?.() || 'Unknown',\n        timestamp: Date.now()\n      });\n    });\n  }\n\n  // Resource Timing\n  initResourceTiming() {\n    if (!('PerformanceObserver' in window)) {\n      return;\n    }\n\n    try {\n      const observer = new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        \n        for (const entry of entries) {\n          if (entry.initiatorType && entry.duration > 0) {\n            this.recordMetric('ResourceTiming', {\n              name: entry.name.split('/').pop() || entry.name,\n              type: entry.initiatorType,\n              duration: entry.duration,\n              size: entry.transferSize || 0,\n              cached: entry.transferSize === 0 && entry.decodedBodySize > 0,\n              timestamp: Date.now()\n            });\n          }\n        }\n      });\n\n      observer.observe({ entryTypes: ['resource'] });\n      this.observers.set('resource', observer);\n    } catch (error) {\n      console.warn('[PerformanceMonitor] Resource timing observation failed:', error);\n    }\n  }\n\n  // Navigation Timing\n  initNavigationTiming() {\n    window.addEventListener('load', () => {\n      const navigation = performance.getEntriesByType('navigation')[0];\n      if (navigation) {\n        this.recordMetric('NavigationTiming', {\n          domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,\n          loadComplete: navigation.loadEventEnd - navigation.loadEventStart,\n          domInteractive: navigation.domInteractive - navigation.navigationStart,\n          totalLoadTime: navigation.loadEventEnd - navigation.navigationStart,\n          timestamp: Date.now()\n        });\n      }\n    });\n  }\n\n  // Visibility Tracking\n  setupVisibilityTracking() {\n    let visibilityStart = Date.now();\n    let totalVisibleTime = 0;\n\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        totalVisibleTime += Date.now() - visibilityStart;\n        \n        this.recordMetric('PageVisibility', {\n          event: 'hidden',\n          visibleTime: totalVisibleTime,\n          timestamp: Date.now()\n        });\n      } else {\n        visibilityStart = Date.now();\n        \n        this.recordMetric('PageVisibility', {\n          event: 'visible',\n          timestamp: Date.now()\n        });\n      }\n    };\n\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    // Track total session time on page unload\n    window.addEventListener('beforeunload', () => {\n      if (!document.hidden) {\n        totalVisibleTime += Date.now() - visibilityStart;\n      }\n      \n      this.recordMetric('SessionSummary', {\n        totalVisibleTime,\n        totalSessionTime: Date.now() - this.pageLoadTime,\n        timestamp: Date.now()\n      });\n    });\n  }\n\n  // Metric Recording and Rating\n  recordMetric(name, data) {\n    const metric = {\n      name,\n      sessionId: this.sessionId,\n      url: window.location.pathname,\n      userAgent: navigator.userAgent.slice(0, 100),\n      ...data\n    };\n\n    this.metrics.set(`${name}-${Date.now()}`, metric);\n    this.buffer.push(metric);\n\n    // Emit event for real-time monitoring\n    window.dispatchEvent(new CustomEvent('performance-metric', { detail: metric }));\n\n    // Limit buffer size\n    if (this.buffer.length > this.config.bufferSize) {\n      this.buffer = this.buffer.slice(-this.config.bufferSize);\n    }\n  }\n\n  // Web Vitals Rating Functions\n  rateLCP(value) {\n    if (value <= 2500) {\n      return 'good';\n    }\n    if (value <= 4000) {\n      return 'needs-improvement';\n    }\n    return 'poor';\n  }\n\n  rateFID(value) {\n    if (value <= 100) {\n      return 'good';\n    }\n    if (value <= 300) {\n      return 'needs-improvement';\n    }\n    return 'poor';\n  }\n\n  rateCLS(value) {\n    if (value <= 0.1) {\n      return 'good';\n    }\n    if (value <= 0.25) {\n      return 'needs-improvement';\n    }\n    return 'poor';\n  }\n\n  rateFCP(value) {\n    if (value <= 1800) {\n      return 'good';\n    }\n    if (value <= 3000) {\n      return 'needs-improvement';\n    }\n    return 'poor';\n  }\n\n  rateTTFB(value) {\n    if (value <= 800) {\n      return 'good';\n    }\n    if (value <= 1800) {\n      return 'needs-improvement';\n    }\n    return 'poor';\n  }\n\n  // Reporting\n  setupReporting() {\n    if (this.config.reportingEndpoint) {\n      this.reportingTimer = setInterval(() => {\n        this.sendReport();\n      }, this.config.reportingInterval);\n    }\n  }\n\n  async sendReport() {\n    if (this.buffer.length === 0) {\n      return;\n    }\n\n    const report = {\n      sessionId: this.sessionId,\n      timestamp: Date.now(),\n      url: window.location.href,\n      metrics: [...this.buffer]\n    };\n\n    try {\n      if (this.config.reportingEndpoint) {\n        await fetch(this.config.reportingEndpoint, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify(report)\n        });\n      }\n\n      // Store locally as backup\n      this.storeLocalReport(report);\n      \n      // Clear buffer after successful send\n      this.buffer = [];\n      \n    } catch (error) {\n      console.warn('[PerformanceMonitor] Failed to send report:', error);\n    }\n  }\n\n  storeLocalReport(report) {\n    try {\n      const key = `bgde:perf-report-${Date.now()}`;\n      localStorage.setItem(key, JSON.stringify(report));\n      \n      // Clean up old reports (keep last 10)\n      const keys = Object.keys(localStorage)\n        .filter(k => k.startsWith('bgde:perf-report-'))\n        .sort()\n        .reverse();\n      \n      for (const key of keys.slice(10)) {\n        localStorage.removeItem(key);\n      }\n      \n    } catch (error) {\n      console.warn('[PerformanceMonitor] Failed to store local report:', error);\n    }\n  }\n\n  // Public API\n  getMetrics() {\n    return [...this.metrics.values()];\n  }\n\n  getWebVitals() {\n    const vitals = {};\n    \n    for (const [key, metric] of this.metrics) {\n      if (['LCP', 'FID', 'CLS', 'FCP', 'TTFB'].includes(metric.name)) {\n        vitals[metric.name] = metric;\n      }\n    }\n    \n    return vitals;\n  }\n\n  getSummary() {\n    const webVitals = this.getWebVitals();\n    const customMetrics = this.getMetrics().filter(m => \n      !['LCP', 'FID', 'CLS', 'FCP', 'TTFB'].includes(m.name)\n    );\n\n    return {\n      sessionId: this.sessionId,\n      webVitals,\n      customMetricsCount: customMetrics.length,\n      overallScore: this.calculateOverallScore(webVitals),\n      recommendations: this.generateRecommendations(webVitals)\n    };\n  }\n\n  calculateOverallScore(webVitals) {\n    const scores = Object.values(webVitals).map(metric => {\n      switch (metric.rating) {\n      case 'good': { return 100;\n      }\n      case 'needs-improvement': { return 50;\n      }\n      case 'poor': { return 0;\n      }\n      default: { return 50;\n      }\n      }\n    });\n\n    return scores.length > 0 ? scores.reduce((a, b) => a + b) / scores.length : 0;\n  }\n\n  generateRecommendations(webVitals) {\n    const recommendations = [];\n\n    if (webVitals.LCP?.rating === 'poor') {\n      recommendations.push('Optimize largest contentful paint by reducing image sizes and server response times');\n    }\n\n    if (webVitals.FID?.rating === 'poor') {\n      recommendations.push('Improve first input delay by reducing JavaScript execution time');\n    }\n\n    if (webVitals.CLS?.rating === 'poor') {\n      recommendations.push('Reduce cumulative layout shift by setting image dimensions and avoiding dynamic content insertion');\n    }\n\n    return recommendations;\n  }\n\n  // Utility Methods\n  shouldSample() {\n    return Math.random() < this.config.sampleRate;\n  }\n\n  generateSessionId() {\n    // Use cryptographically secure random values for session id\n    let randStr;\n    if (typeof window !== 'undefined' && window.crypto && window.crypto.getRandomValues) {\n      // Browser: Use crypto.getRandomValues\n      const buf = new Uint32Array(3); // 96 bits\n      window.crypto.getRandomValues(buf);\n      randStr = [...buf].map(val => val.toString(36)).join('');\n    } else if (typeof require === 'undefined') {\n      // Fallback (not recommended): use Math.random\n      randStr = Math.random().toString(36).slice(2, 11);\n    } else {\n      // NodeJS: Use crypto.randomBytes\n      try {\n        const crypto = require('node:crypto');\n        randStr = crypto.randomBytes(12).toString('base64url'); // 12 bytes -> 16 chars\n      } catch {\n        // Fallback to Math.random only if secure RNG is missing (not recommended)\n        randStr = Math.random().toString(36).slice(2, 11);\n      }\n    }\n    return `perf_${Date.now()}_${randStr}`;\n  }\n\n  // Configuration\n  configure(options) {\n    Object.assign(this.config, options);\n  }\n\n  // Cleanup\n  destroy() {\n    // Disconnect all observers\n    for (const observer of this.observers.values()) {\n      observer.disconnect();\n    }\n    this.observers.clear();\n\n    // Clear reporting timer\n    if (this.reportingTimer) {\n      clearInterval(this.reportingTimer);\n    }\n\n    // Send final report\n    if (this.buffer.length > 0) {\n      this.sendReport();\n    }\n  }\n}\n\n// Create and export singleton instance\nconst performanceMonitor = new PerformanceMonitor();\n\nexport default performanceMonitor;\n\n// Also make available globally for non-module usage\nif (typeof window !== 'undefined') {\n  window.performanceMonitor = performanceMonitor;\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/phase-calculator.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":232,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7096,7099],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7096,7099],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7147,7150],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7147,7150],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":233,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":233,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7182,7185],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7182,7185],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"unicorn/no-useless-switch-case","severity":2,"message":"Useless case in switch statement.","line":266,"column":5,"nodeType":"SwitchCase","messageId":"no-useless-switch-case/error","endLine":266,"endColumn":12,"suggestions":[{"messageId":"no-useless-switch-case/suggestion","fix":{"range":[7929,7936],"text":""},"data":{},"desc":"Remove this case."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Phase Calculator Module\n * Maps SM-2 ease factors to 6-phase learning progression system\n *\n * Phase System:\n * - Phase 1 (New): EF < 2.0 - Just introduced, frequent reviews\n * - Phase 2 (Learning): EF 2.0-2.2 - Building familiarity\n * - Phase 3 (Familiar): EF 2.2-2.4 - Recognizable but needs practice\n * - Phase 4 (Known): EF 2.4-2.6 - Comfortable recall\n * - Phase 5 (Mastered): EF 2.6-2.8 - Strong retention\n * - Phase 6 (Expert): EF 2.8-3.0 - Nearly perfect\n * - Learned: EF ≥ 3.0 - Long-term memory, periodic maintenance\n */\n\nimport type { PhaseDetails, PhaseStatistics, ReviewState } from '../types.js';\n\nclass PhaseCalculator {\n  // Phase thresholds based on ease factor\n  private PHASE_THRESHOLDS: Record<string, PhaseDetails> = {\n    PHASE_1: { min: 0, max: 2, name: 'New', color: '#ef4444' },\n    PHASE_2: { min: 2, max: 2.2, name: 'Learning', color: '#f97316' },\n    PHASE_3: { min: 2.2, max: 2.4, name: 'Familiar', color: '#eab308' },\n    PHASE_4: { min: 2.4, max: 2.6, name: 'Known', color: '#84cc16' },\n    PHASE_5: { min: 2.6, max: 2.8, name: 'Mastered', color: '#22c55e' },\n    PHASE_6: { min: 2.8, max: 3, name: 'Expert', color: '#10b981' },\n    LEARNED: { min: 3, max: Number.POSITIVE_INFINITY, name: 'Learned', color: '#06b6d4' }\n  };\n\n  // Minimum correct reviews required to advance from Phase 1\n  private MIN_REVIEWS_TO_ADVANCE: number = 3;\n\n  // Learned status requires sustained high performance\n  private LEARNED_MIN_REPETITIONS: number = 5;\n\n  /**\n   * Calculate current phase based on ease factor\n   * @param easeFactor - SM-2 ease factor (typically 1.3-3.0+)\n   * @param repetitions - Number of successful repetitions\n   * @returns Phase number (1-6) or 0 for \"Learned\"\n   */\n  calculatePhase(easeFactor: number, repetitions: number = 0): number {\n    // Ensure ease factor is within valid range\n    const ef = Math.max(1.3, easeFactor);\n\n    // Check if vocabulary has reached \"Learned\" status\n    if (ef >= 3 && repetitions >= this.LEARNED_MIN_REPETITIONS) {\n      return 0; // 0 represents \"Learned\" status\n    }\n\n    // Determine phase based on ease factor\n    if (ef < 2) return 1;\n    if (ef < 2.2) return 2;\n    if (ef < 2.4) return 3;\n    if (ef < 2.6) return 4;\n    if (ef < 2.8) return 5;\n    if (ef < 3) return 6;\n\n    // If EF >= 3.0 but not enough repetitions, stay in Phase 6\n    return 6;\n  }\n\n  /**\n   * Get phase details including name, color, and thresholds\n   * @param phase - Phase number (0-6)\n   * @returns Phase details\n   */\n  getPhaseDetails(phase: number): PhaseDetails {\n    switch (phase) {\n    case 0: {\n      return this.PHASE_THRESHOLDS.LEARNED!;\n    }\n    case 1: {\n      return this.PHASE_THRESHOLDS.PHASE_1!;\n    }\n    case 2: {\n      return this.PHASE_THRESHOLDS.PHASE_2!;\n    }\n    case 3: {\n      return this.PHASE_THRESHOLDS.PHASE_3!;\n    }\n    case 4: {\n      return this.PHASE_THRESHOLDS.PHASE_4!;\n    }\n    case 5: {\n      return this.PHASE_THRESHOLDS.PHASE_5!;\n    }\n    case 6: {\n      return this.PHASE_THRESHOLDS.PHASE_6!;\n    }\n    default: {\n      return this.PHASE_THRESHOLDS.PHASE_1!;\n    }\n    }\n  }\n\n  /**\n   * Calculate new phase after a review\n   * @param currentPhase - Current phase (0-6)\n   * @param quality - Review quality (0-5)\n   * @param newEaseFactor - Updated ease factor after review\n   * @param repetitions - Number of successful repetitions\n   * @returns New phase number\n   */\n  calculateNewPhase(currentPhase: number, quality: number, newEaseFactor: number, repetitions: number): number {\n    // If answer was incorrect (quality < 3), move back one phase\n    if (quality < 3) {\n      // Don't move below Phase 1\n      return Math.max(1, currentPhase - 1);\n    }\n\n    // For correct answers, recalculate phase based on new ease factor\n    const newPhase = this.calculatePhase(newEaseFactor, repetitions);\n\n    // Prevent skipping phases - can only advance one phase at a time\n    // Exception: Can jump to \"Learned\" (phase 0) from Phase 6\n    if (newPhase === 0 && currentPhase === 6) {\n      return 0;\n    }\n\n    // Otherwise, advance at most one phase\n    if (newPhase > currentPhase) {\n      return Math.min(newPhase, currentPhase + 1);\n    }\n\n    return newPhase;\n  }\n\n  /**\n   * Check if vocabulary item can advance to next phase\n   * @param currentPhase - Current phase (1-6)\n   * @param repetitions - Number of successful repetitions\n   * @param easeFactor - Current ease factor\n   * @returns True if ready to advance\n   */\n  canAdvanceToNextPhase(currentPhase: number, repetitions: number, easeFactor: number): boolean {\n    // Already learned\n    if (currentPhase === 0) {\n      return false;\n    }\n\n    // Phase 1 requires minimum reviews before advancing\n    if (currentPhase === 1 && repetitions < this.MIN_REVIEWS_TO_ADVANCE) {\n      return false;\n    }\n\n    // Check if ease factor is high enough for next phase\n    const nextPhaseThreshold = this.getPhaseDetails(currentPhase + 1).min;\n    return easeFactor >= nextPhaseThreshold;\n  }\n\n  /**\n   * Get progress within current phase (0-100%)\n   * @param phase - Current phase (1-6)\n   * @param easeFactor - Current ease factor\n   * @returns Progress percentage\n   */\n  getPhaseProgress(phase: number, easeFactor: number): number {\n    if (phase === 0) {\n      return 100; // Learned items are 100% complete\n    }\n\n    const phaseDetails = this.getPhaseDetails(phase);\n    const range = phaseDetails.max - phaseDetails.min;\n\n    if (range === 0 || range === Number.POSITIVE_INFINITY) {\n      return 0;\n    }\n\n    const progress = (easeFactor - phaseDetails.min) / range;\n    return Math.max(0, Math.min(100, progress * 100));\n  }\n\n  /**\n   * Get all phase statistics for a collection of reviews\n   * @param reviews - Array of review objects with easeFactor and phase\n   * @returns Statistics by phase\n   */\n  getPhaseStatistics(reviews: ReviewState[]): PhaseStatistics {\n    const stats: PhaseStatistics = {\n      learned: { count: 0, percentage: '0' },\n      phase1: { count: 0, percentage: '0' },\n      phase2: { count: 0, percentage: '0' },\n      phase3: { count: 0, percentage: '0' },\n      phase4: { count: 0, percentage: '0' },\n      phase5: { count: 0, percentage: '0' },\n      phase6: { count: 0, percentage: '0' },\n      total: reviews.length\n    };\n\n    if (reviews.length === 0) {\n      return stats;\n    }\n\n    // Count items in each phase\n    for (const review of reviews) {\n      const phase = review.phase ?? this.calculatePhase(review.easeFactor || 2.5, review.repetitions || 0);\n\n      switch (phase) {\n      case 0: {\n        stats.learned.count++;\n        break;\n      }\n      case 1: {\n        stats.phase1.count++;\n        break;\n      }\n      case 2: {\n        stats.phase2.count++;\n        break;\n      }\n      case 3: {\n        stats.phase3.count++;\n        break;\n      }\n      case 4: {\n        stats.phase4.count++;\n        break;\n      }\n      case 5: {\n        stats.phase5.count++;\n        break;\n      }\n      case 6: {\n        stats.phase6.count++;\n        break;\n      }\n      }\n    }\n\n    // Calculate percentages\n    for (const key of Object.keys(stats)) {\n      if (key !== 'total' && (stats as any)[key].count !== undefined) {\n        (stats as any)[key].percentage = (((stats as any)[key].count / stats.total) * 100).toFixed(1);\n      }\n    }\n\n    return stats;\n  }\n\n  /**\n   * Get recommended review interval multiplier based on phase\n   * Higher phases = longer intervals\n   * @param phase - Current phase (0-6)\n   * @returns Interval multiplier\n   */\n  getPhaseIntervalMultiplier(phase: number): number {\n    switch (phase) {\n    case 0: { // Learned - very long intervals\n      return 3;\n    }\n    case 6: { // Expert - long intervals\n      return 2;\n    }\n    case 5: { // Mastered - moderately long\n      return 1.5;\n    }\n    case 4: { // Known - standard\n      return 1.2;\n    }\n    case 3: { // Familiar - slightly increased\n      return 1;\n    }\n    case 2: { // Learning - standard SM-2\n      return 0.9;\n    }\n    case 1: // New - shorter intervals for reinforcement\n    default: {\n      return 0.8;\n    }\n    }\n  }\n\n  /**\n   * Determine if a learned item needs periodic review\n   * Learned items should be reviewed periodically to maintain retention\n   * @param lastReviewDate - Date of last review\n   * @param easeFactor - Current ease factor\n   * @returns True if review is needed\n   */\n  needsMaintenanceReview(lastReviewDate: Date | string | number | null, easeFactor: number): boolean {\n    if (!lastReviewDate) {\n      return true;\n    }\n\n    const lastReviewTime = typeof lastReviewDate === 'number' \n      ? lastReviewDate \n      : new Date(lastReviewDate).getTime();\n    \n    const daysSinceReview = (Date.now() - lastReviewTime) / (1000 * 60 * 60 * 24);\n\n    // Maintenance review intervals based on performance\n    // Higher EF = longer maintenance intervals\n    let maintenanceInterval = 90; // Default: 90 days\n\n    if (easeFactor >= 3.5) {\n      maintenanceInterval = 180; // 6 months for very strong retention\n    } else if (easeFactor >= 3.2) {\n      maintenanceInterval = 120; // 4 months\n    }\n\n    return daysSinceReview >= maintenanceInterval;\n  }\n\n  /**\n   * Get phase name in multiple languages\n   * @param phase - Phase number (0-6)\n   * @param language - Language code ('en', 'de', 'bg')\n   * @returns Localized phase name\n   */\n  getPhaseName(phase: number, language: 'en' | 'de' | 'bg' = 'en'): string {\n    const names: Record<number, Record<string, string>> = {\n      0: {\n        en: 'Learned',\n        de: 'Gelernt',\n        bg: 'Научен'\n      },\n      1: {\n        en: 'New',\n        de: 'Neu',\n        bg: 'Нов'\n      },\n      2: {\n        en: 'Learning',\n        de: 'Lernen',\n        bg: 'Учене'\n      },\n      3: {\n        en: 'Familiar',\n        de: 'Vertraut',\n        bg: 'Познат'\n      },\n      4: {\n        en: 'Known',\n        de: 'Bekannt',\n        bg: 'Известен'\n      },\n      5: {\n        en: 'Mastered',\n        de: 'Gemeistert',\n        bg: 'Овладян'\n      },\n      6: {\n        en: 'Expert',\n        de: 'Experte',\n        bg: 'Експерт'\n      }\n    };\n\n    return names[phase]?.[language] || names[phase]?.en || 'Unknown';\n  }\n\n  /**\n   * Get phase icon/emoji\n   * @param phase - Phase number (0-6)\n   * @returns Emoji representing the phase\n   */\n  getPhaseIcon(phase: number): string {\n    const icons: Record<number, string> = {\n      0: '🎓', // Learned - graduation cap\n      1: '🌱', // New - seedling\n      2: '📖', // Learning - book\n      3: '👁️', // Familiar - eye\n      4: '✅', // Known - check mark\n      5: '⭐', // Mastered - star\n      6: '🏆'  // Expert - trophy\n    };\n\n    return icons[phase] || '❓';\n  }\n}\n\n// Export as ES6 module\nexport default PhaseCalculator;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/practice-page.js","messages":[{"ruleId":"unicorn/prefer-ternary","severity":2,"message":"This `if` statement can be replaced by a ternary expression.","line":182,"column":5,"nodeType":"IfStatement","messageId":"prefer-ternary","endLine":189,"endColumn":6}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Practice Page Module - Lazy loaded only on practice pages\n * Handles practice sessions, spaced repetition, and session management\n */\n\nclass PracticePageModule {\n  constructor(options = {}) {\n    this.adapter = options.adapter;\n    this.spacedRepetition = options.spacedRepetition;\n    this.selectedItems = options.selectedItems || [];\n    this.learningDirection = this.normalizeDirection(options.learningDirection) || this.getInitialDirection();\n    this.enableAudio = options.enableAudio || false;\n    this.sessionLength = options.sessionLength || 20;\n        \n    // Session state\n    this.currentSession = null;\n    this.sessionItems = [];\n    this.currentIndex = 0;\n    this.sessionStats = {\n      correct: 0,\n      total: 0,\n      startTime: null,\n      mistakes: []\n    };\n        \n    // UI elements\n    this.elements = {};\n    this.isInitialized = false;\n  }\n\n  normalizeDirection(value) {\n    if (!value) {\n      return null;\n    }\n\n    const normalized = value.toString().toLowerCase();\n\n    if (normalized === 'bg-de' || normalized === 'bg_to_de') {\n      return 'bg-de';\n    }\n\n    if (normalized === 'de-bg' || normalized === 'de_to_bg') {\n      return 'de-bg';\n    }\n\n    return normalized === 'bg-de' || normalized === 'de-bg' ? normalized : null;\n  }\n\n  getInitialDirection() {\n    if (window.languageToggle && typeof window.languageToggle.getDirection === 'function') {\n      return window.languageToggle.getDirection();\n    }\n\n    const stored =\n            localStorage.getItem('bgde:language-direction') ||\n            localStorage.getItem('bgde:learning_direction');\n\n    return this.normalizeDirection(stored) || 'de-bg';\n  }\n\n  async init() {\n    try {\n      // Cache DOM elements\n      this.cacheElements();\n            \n      // Initialize session\n      await this.initializeSession();\n            \n      // Setup event listeners\n      this.setupEventListeners();\n            \n      // Start session\n      this.startSession();\n            \n      this.isInitialized = true;\n      console.log('PracticePageModule initialized successfully');\n    } catch (error) {\n      console.error('Failed to initialize PracticePageModule:', error);\n      this.showErrorState();\n    }\n  }\n\n  cacheElements() {\n    // Cache all DOM elements for better performance\n    this.elements = {\n      loadingState: document.querySelector('#loading-state'),\n      noItemsState: document.querySelector('#no-items-state'),\n      practiceSession: document.querySelector('#practice-session'),\n      sessionComplete: document.querySelector('#session-complete'),\n      settingsPanel: document.querySelector('#settings-panel'),\n            \n      // Session stats\n      progress: document.querySelector('#progress'),\n      accuracy: document.querySelector('#accuracy'),\n      sessionTime: document.querySelector('#session-time'),\n            \n      // Flashcard elements\n      flashcard: document.querySelector('#flashcard'),\n      currentWord: document.querySelector('#current-word'),\n      currentTranslation: document.querySelector('#current-translation'),\n      currentNotes: document.querySelector('#current-notes'),\n      wordLevel: document.querySelector('#word-level'),\n      wordCategory: document.querySelector('#word-category'),\n            \n      // Controls\n      showAnswer: document.querySelector('#show-answer'),\n      responseButtons: document.querySelector('#response-buttons'),\n      correctBtn: document.querySelector('#correct-btn'),\n      incorrectBtn: document.querySelector('#incorrect-btn'),\n      playAudio: document.querySelector('#play-audio'),\n      showHint: document.querySelector('#show-hint'),\n      hintContent: document.querySelector('#hint-content'),\n            \n      // Progress\n      progressFill: document.querySelector('#progress-fill'),\n            \n      // Settings\n      settingsToggle: document.querySelector('#settings-toggle'),\n      sessionLength: document.querySelector('#session-length'),\n      difficultyFilter: document.querySelector('#difficulty-filter'),\n      audioEnabled: document.querySelector('#audio-enabled'),\n            \n      // Session controls\n      endSession: document.querySelector('#end-session'),\n      newSession: document.querySelector('#new-session'),\n      reviewMistakes: document.querySelector('#review-mistakes'),\n            \n      // Final stats\n      finalCorrect: document.querySelector('#final-correct'),\n      finalTotal: document.querySelector('#final-total'),\n      finalAccuracy: document.querySelector('#final-accuracy'),\n      finalTime: document.querySelector('#final-time'),\n      performanceFeedback: document.querySelector('#performance-feedback')\n    };\n  }\n\n  async initializeSession() {\n    this.showLoadingState();\n        \n    try {\n      // Get session items based on spaced repetition\n      this.sessionItems = await this.getSessionItems();\n            \n      if (this.sessionItems.length === 0) {\n        this.showNoItemsState();\n        return;\n      }\n            \n      // Initialize session stats\n      this.sessionStats = {\n        correct: 0,\n        total: 0,\n        startTime: Date.now(),\n        mistakes: [],\n        sessionId: this.generateSessionId()\n      };\n            \n      // Save session to localStorage for recovery\n      this.saveSessionState();\n            \n    } catch (error) {\n      console.error('Failed to initialize session:', error);\n      this.showErrorState();\n    }\n  }\n\n  async getSessionItems() {\n    if (!this.adapter || !this.spacedRepetition) {\n      throw new Error('Missing required dependencies');\n    }\n\n    // Get due items from spaced repetition\n    const reviewStates = this.spacedRepetition.getAllReviewStates();\n    const dueItems = this.spacedRepetition.getDueItems(reviewStates);\n        \n    // Get vocabulary items for current direction\n    const availableItems = this.adapter.getItemsForDirection(this.learningDirection);\n        \n    // If we have selected items, prioritize those\n    let sessionItems = [];\n        \n    if (this.selectedItems.length > 0) {\n      sessionItems = availableItems.filter(item => \n        this.selectedItems.includes(item.word) || this.selectedItems.includes(item.id)\n      );\n    } else {\n      // Use spaced repetition algorithm to select items\n      sessionItems = this.selectOptimalItems(availableItems, dueItems);\n    }\n        \n    // Shuffle items for better learning\n    return this.shuffleArray(sessionItems.slice(0, this.sessionLength));\n  }\n\n  selectOptimalItems(availableItems, dueItems) {\n    const dueItemIds = new Set(dueItems.map(item => item.itemId));\n        \n    // Prioritize due items\n    const dueVocabItems = availableItems.filter(item => \n      dueItemIds.has(item.id)\n    );\n        \n    // Fill remaining slots with new items\n    const newItems = availableItems.filter(item => \n      !dueItemIds.has(item.id)\n    ).sort((a, b) => {\n      // Sort by difficulty and frequency\n      if (a.difficulty !== b.difficulty) {\n        return a.difficulty - b.difficulty; // Easier first\n      }\n      return (b.frequency || 0) - (a.frequency || 0); // Higher frequency first\n    });\n        \n    const combined = [...dueVocabItems, ...newItems];\n    return combined.slice(0, this.sessionLength);\n  }\n\n  shuffleArray(array) {\n    const shuffled = [...array];\n    for (let i = shuffled.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];\n    }\n    return shuffled;\n  }\n\n  setupEventListeners() {\n    // Flashcard controls\n    if (this.elements.showAnswer) {\n      this.elements.showAnswer.addEventListener('click', () => this.showAnswer());\n    }\n        \n    if (this.elements.correctBtn) {\n      this.elements.correctBtn.addEventListener('click', () => this.handleResponse(true));\n    }\n        \n    if (this.elements.incorrectBtn) {\n      this.elements.incorrectBtn.addEventListener('click', () => this.handleResponse(false));\n    }\n        \n    // Audio playback\n    if (this.elements.playAudio && this.enableAudio) {\n      this.elements.playAudio.addEventListener('click', () => this.playAudio());\n    }\n        \n    // Hint system\n    if (this.elements.showHint) {\n      this.elements.showHint.addEventListener('click', () => this.toggleHint());\n    }\n\n    document.addEventListener('language-direction-changed', (event) => {\n      const nextDirection = this.normalizeDirection(event?.detail?.direction);\n      if (!nextDirection || nextDirection === this.learningDirection) {\n        return;\n      }\n\n      this.learningDirection = nextDirection;\n      this.displayCurrentItem();\n    });\n        \n    // Settings\n    if (this.elements.settingsToggle) {\n      this.elements.settingsToggle.addEventListener('click', () => this.toggleSettings());\n    }\n        \n    // Session controls\n    if (this.elements.endSession) {\n      this.elements.endSession.addEventListener('click', () => this.endSession());\n    }\n        \n    if (this.elements.newSession) {\n      this.elements.newSession.addEventListener('click', () => this.startNewSession());\n    }\n        \n    if (this.elements.reviewMistakes) {\n      this.elements.reviewMistakes.addEventListener('click', () => this.reviewMistakes());\n    }\n        \n    // Keyboard shortcuts\n    document.addEventListener('keydown', (e) => this.handleKeyboard(e));\n        \n    // Settings changes\n    if (this.elements.sessionLength) {\n      this.elements.sessionLength.addEventListener('change', (e) => {\n        this.sessionLength = Number.parseInt(e.target.value);\n      });\n    }\n        \n    if (this.elements.audioEnabled) {\n      this.elements.audioEnabled.addEventListener('change', (e) => {\n        this.enableAudio = e.target.checked;\n      });\n    }\n  }\n\n  startSession() {\n    if (this.sessionItems.length === 0) {\n      this.showNoItemsState();\n      return;\n    }\n        \n    this.hideLoadingState();\n    this.showPracticeSession();\n    this.currentIndex = 0;\n    this.displayCurrentItem();\n    this.startSessionTimer();\n  }\n\n  displayCurrentItem() {\n    if (this.currentIndex >= this.sessionItems.length) {\n      this.completeSession();\n      return;\n    }\n        \n    const item = this.sessionItems[this.currentIndex];\n\n    const isReverse = this.learningDirection === 'de-bg';\n    const frontText = isReverse ? item.translation : item.word;\n    const backText = isReverse ? item.word : item.translation;\n\n    // Update flashcard content\n    if (this.elements.currentWord) {\n      this.elements.currentWord.textContent = frontText;\n    }\n\n    if (this.elements.currentTranslation) {\n      this.elements.currentTranslation.textContent = backText;\n    }\n        \n    if (this.elements.currentNotes) {\n      this.elements.currentNotes.textContent = item.notes || '';\n    }\n        \n    if (this.elements.wordLevel) {\n      this.elements.wordLevel.textContent = item.level;\n      this.elements.wordLevel.className = `level-badge level-${item.level.toLowerCase()}`;\n    }\n        \n    if (this.elements.wordCategory) {\n      this.elements.wordCategory.textContent = item.category;\n    }\n        \n    // Reset flashcard state\n    this.resetFlashcardState();\n        \n    // Update progress\n    this.updateProgress();\n        \n    // Preload audio if available\n    if (this.enableAudio && item.audio) {\n      this.preloadAudio(item.audio);\n    }\n  }\n\n  resetFlashcardState() {\n    // Reset flashcard to front side\n    if (this.elements.flashcard) {\n      this.elements.flashcard.classList.remove('flipped');\n    }\n        \n    // Show answer button, hide response buttons\n    if (this.elements.showAnswer) {\n      this.elements.showAnswer.classList.remove('hidden');\n    }\n        \n    if (this.elements.responseButtons) {\n      this.elements.responseButtons.classList.add('hidden');\n    }\n        \n    // Hide hint\n    if (this.elements.hintContent) {\n      this.elements.hintContent.classList.add('hidden');\n    }\n  }\n\n  showAnswer() {\n    // Flip flashcard\n    if (this.elements.flashcard) {\n      this.elements.flashcard.classList.add('flipped');\n    }\n        \n    // Hide answer button, show response buttons\n    if (this.elements.showAnswer) {\n      this.elements.showAnswer.classList.add('hidden');\n    }\n        \n    if (this.elements.responseButtons) {\n      this.elements.responseButtons.classList.remove('hidden');\n    }\n        \n    // Auto-play audio if enabled\n    if (this.enableAudio) {\n      setTimeout(() => this.playAudio(), 300);\n    }\n  }\n\n  handleResponse(correct) {\n    const currentItem = this.sessionItems[this.currentIndex];\n        \n    // Update session stats\n    this.sessionStats.total++;\n    if (correct) {\n      this.sessionStats.correct++;\n    } else {\n      this.sessionStats.mistakes.push({\n        item: currentItem,\n        timestamp: Date.now()\n      });\n    }\n        \n    // Update spaced repetition\n    if (this.spacedRepetition) {\n      this.spacedRepetition.updateReviewState(currentItem.id, correct, {\n        learningDirection: this.learningDirection,\n        difficulty: currentItem.difficulty || 3\n      });\n    }\n        \n    // Update UI\n    this.updateSessionStats();\n        \n    // Move to next item\n    setTimeout(() => {\n      this.currentIndex++;\n      this.displayCurrentItem();\n    }, 1000);\n  }\n\n  updateProgress() {\n    const progress = `${this.currentIndex + 1}/${this.sessionItems.length}`;\n    if (this.elements.progress) {\n      this.elements.progress.textContent = progress;\n    }\n        \n    // Update progress bar\n    const percentage = ((this.currentIndex + 1) / this.sessionItems.length) * 100;\n    if (this.elements.progressFill) {\n      this.elements.progressFill.style.width = `${percentage}%`;\n    }\n  }\n\n  updateSessionStats() {\n    // Update accuracy\n    const accuracy = this.sessionStats.total > 0 \n      ? Math.round((this.sessionStats.correct / this.sessionStats.total) * 100)\n      : 0;\n        \n    if (this.elements.accuracy) {\n      this.elements.accuracy.textContent = `${accuracy}%`;\n    }\n  }\n\n  startSessionTimer() {\n    this.sessionTimer = setInterval(() => {\n      const elapsed = Date.now() - this.sessionStats.startTime;\n      const minutes = Math.floor(elapsed / 60_000);\n      const seconds = Math.floor((elapsed % 60_000) / 1000);\n      const timeString = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;\n            \n      if (this.elements.sessionTime) {\n        this.elements.sessionTime.textContent = timeString;\n      }\n    }, 1000);\n  }\n\n  completeSession() {\n    clearInterval(this.sessionTimer);\n        \n    // Calculate final stats\n    const totalTime = Date.now() - this.sessionStats.startTime;\n    const accuracy = this.sessionStats.total > 0 \n      ? Math.round((this.sessionStats.correct / this.sessionStats.total) * 100)\n      : 0;\n        \n    // Update final stats display\n    this.displayFinalStats(totalTime, accuracy);\n        \n    // Save session results\n    this.saveSessionResults();\n        \n    // Show completion screen\n    this.showSessionComplete();\n  }\n\n  displayFinalStats(totalTime, accuracy) {\n    if (this.elements.finalCorrect) {\n      this.elements.finalCorrect.textContent = this.sessionStats.correct;\n    }\n        \n    if (this.elements.finalTotal) {\n      this.elements.finalTotal.textContent = this.sessionStats.total;\n    }\n        \n    if (this.elements.finalAccuracy) {\n      this.elements.finalAccuracy.textContent = `${accuracy}%`;\n    }\n        \n    if (this.elements.finalTime) {\n      const minutes = Math.floor(totalTime / 60_000);\n      const seconds = Math.floor((totalTime % 60_000) / 1000);\n      this.elements.finalTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;\n    }\n        \n    // Generate performance feedback\n    this.generatePerformanceFeedback(accuracy);\n  }\n\n  generatePerformanceFeedback(accuracy) {\n    let feedback = '';\n        \n    if (accuracy >= 90) {\n      feedback = '🌟 Ausgezeichnet! Hervorragende Leistung! / Отлично! Превъзходно представяне!';\n    } else if (accuracy >= 75) {\n      feedback = '👍 Gut gemacht! Weiter so! / Добра работа! Продължавайте така!';\n    } else if (accuracy >= 60) {\n      feedback = '📚 Nicht schlecht! Mehr Übung wird helfen. / Неплохо! Повече практика ще помогне.';\n    } else {\n      feedback = '💪 Übung macht den Meister! Versuchen Sie es noch einmal. / Практиката прави съвършенство! Опитайте отново.';\n    }\n        \n    if (this.elements.performanceFeedback) {\n      this.elements.performanceFeedback.innerHTML = `<p>${feedback}</p>`;\n    }\n  }\n\n  playAudio() {\n    const currentItem = this.sessionItems[this.currentIndex];\n    if (!currentItem || !currentItem.word) {\n      return;\n    }\n\n    // Use enhanced TextToSpeech if available\n    if (window.audioManager && window.audioManager.useEnhancedTTS && window.audioManager.tts) {\n      const lang = this.learningDirection === 'de-bg' ? 'bg-BG' : 'de-DE';\n      window.audioManager.tts.speak(currentItem.word, lang);\n      return;\n    }\n\n    // Fallback to basic Web Speech API\n    if ('speechSynthesis' in window) {\n      const utterance = new SpeechSynthesisUtterance(currentItem.word);\n      utterance.lang = this.learningDirection === 'de-bg' ? 'bg-BG' : 'de-DE';\n      utterance.rate = 0.85;\n      utterance.pitch = 1;\n      utterance.volume = 1;\n      speechSynthesis.speak(utterance);\n    }\n  }\n\n  toggleHint() {\n    if (this.elements.hintContent) {\n      const isHidden = this.elements.hintContent.classList.contains('hidden');\n            \n      if (isHidden) {\n        const currentItem = this.sessionItems[this.currentIndex];\n        const hints = this.generateHints(currentItem);\n        this.elements.hintContent.innerHTML = hints;\n        this.elements.hintContent.classList.remove('hidden');\n      } else {\n        this.elements.hintContent.classList.add('hidden');\n      }\n    }\n  }\n\n  generateHints(item) {\n    const hints = [];\n        \n    if (item.etymology) {\n      hints.push(`<strong>Etymology:</strong> ${item.etymology}`);\n    }\n        \n    if (item.cultural_note) {\n      hints.push(`<strong>Cultural Note:</strong> ${item.cultural_note}`);\n    }\n        \n    if (item.linguistic_note) {\n      hints.push(`<strong>Linguistic Note:</strong> ${item.linguistic_note}`);\n    }\n        \n    if (item.examples && item.examples.length > 0) {\n      const example = item.examples[0];\n      hints.push(`<strong>Example:</strong> ${example.sentence} - ${example.translation}`);\n    }\n        \n    return hints.length > 0 ? hints.join('<br><br>') : 'No additional hints available.';\n  }\n\n  handleKeyboard(event) {\n    if (!this.isInitialized) {\n      return;\n    }\n        \n    switch (event.key) {\n    case ' ':\n    case 'Enter': {\n      event.preventDefault();\n      if (!this.elements.showAnswer.classList.contains('hidden')) {\n        this.showAnswer();\n      }\n      break;\n    }\n    case '1': {\n      if (!this.elements.responseButtons.classList.contains('hidden')) {\n        this.handleResponse(false);\n      }\n      break;\n    }\n    case '2': {\n      if (!this.elements.responseButtons.classList.contains('hidden')) {\n        this.handleResponse(true);\n      }\n      break;\n    }\n    case 'h': {\n      this.toggleHint();\n      break;\n    }\n    case 'Escape': {\n      this.toggleSettings();\n      break;\n    }\n    }\n  }\n\n  // UI State Management\n  showLoadingState() {\n    this.hideAllStates();\n    if (this.elements.loadingState) {\n      this.elements.loadingState.classList.remove('hidden');\n    }\n  }\n\n  showNoItemsState() {\n    this.hideAllStates();\n    if (this.elements.noItemsState) {\n      this.elements.noItemsState.classList.remove('hidden');\n    }\n  }\n\n  showPracticeSession() {\n    this.hideAllStates();\n    if (this.elements.practiceSession) {\n      this.elements.practiceSession.classList.remove('hidden');\n    }\n  }\n\n  showSessionComplete() {\n    this.hideAllStates();\n    if (this.elements.sessionComplete) {\n      this.elements.sessionComplete.classList.remove('hidden');\n    }\n  }\n\n  hideAllStates() {\n    const states = [\n      this.elements.loadingState,\n      this.elements.noItemsState,\n      this.elements.practiceSession,\n      this.elements.sessionComplete\n    ];\n        \n    for (const element of states) {\n      if (element) {\n        element.classList.add('hidden');\n      }\n    }\n  }\n\n  toggleSettings() {\n    if (this.elements.settingsPanel) {\n      this.elements.settingsPanel.classList.toggle('hidden');\n    }\n  }\n\n  // Session Management\n  saveSessionState() {\n    const sessionState = {\n      sessionId: this.sessionStats.sessionId,\n      items: this.sessionItems,\n      currentIndex: this.currentIndex,\n      stats: this.sessionStats,\n      timestamp: Date.now()\n    };\n        \n    localStorage.setItem('bgde:current_session', JSON.stringify(sessionState));\n  }\n\n  saveSessionResults() {\n    const results = {\n      sessionId: this.sessionStats.sessionId,\n      correct: this.sessionStats.correct,\n      total: this.sessionStats.total,\n      accuracy: Math.round((this.sessionStats.correct / this.sessionStats.total) * 100),\n      duration: Date.now() - this.sessionStats.startTime,\n      mistakes: this.sessionStats.mistakes,\n      learningDirection: this.learningDirection,\n      timestamp: Date.now()\n    };\n        \n    // Save to session history\n    const history = JSON.parse(localStorage.getItem('bgde:session_history') || '[]');\n    history.unshift(results);\n    history.splice(50); // Keep only last 50 sessions\n    localStorage.setItem('bgde:session_history', JSON.stringify(history));\n  }\n\n  generateSessionId() {\n    // Use crypto.getRandomValues for secure random ID\n    const array = new Uint8Array(9);\n    window.crypto.getRandomValues(array);\n    const randomString = Array.from(array, b => b.toString(16).padStart(2, '0')).join('');\n    return `session_${Date.now()}_${randomString}`;\n  }\n\n  endSession() {\n    if (confirm('Are you sure you want to end this session?')) {\n      this.completeSession();\n    }\n  }\n\n  startNewSession() {\n    // Clear current session\n    localStorage.removeItem('bgde:current_session');\n    localStorage.removeItem('bgde:practice_selection');\n        \n    // Reload page to start fresh\n    window.location.reload();\n  }\n\n  reviewMistakes() {\n    if (this.sessionStats.mistakes.length === 0) {\n      alert('No mistakes to review in this session!');\n      return;\n    }\n        \n    // Create new session with only mistakes\n    const mistakeWords = this.sessionStats.mistakes.map(mistake => mistake.item.word);\n    localStorage.setItem('bgde:practice_selection', JSON.stringify(mistakeWords));\n    window.location.reload();\n  }\n\n  showErrorState() {\n    this.hideAllStates();\n        \n    const errorHtml = `\n            <div class=\"error-state\">\n                <h3>⚠️ Session Error</h3>\n                <p>Failed to initialize practice session. Please try again.</p>\n                <button onclick=\"location.reload()\" class=\"btn-primary\">Retry</button>\n                <a href=\"/vocabulary/\" class=\"btn-secondary\">Back to Vocabulary</a>\n            </div>\n        `;\n        \n    if (this.elements.practiceSession) {\n      this.elements.practiceSession.innerHTML = errorHtml;\n      this.elements.practiceSession.classList.remove('hidden');\n    }\n  }\n\n  // Cleanup\n  destroy() {\n    clearInterval(this.sessionTimer);\n        \n    // Remove event listeners\n    document.removeEventListener('keydown', this.handleKeyboard);\n        \n    // Clear session state\n    localStorage.removeItem('bgde:current_session');\n  }\n}\n\nexport default PracticePageModule;\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/profile-manager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/profile-switcher-ui.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/progress-dashboard.js","messages":[{"ruleId":"no-undef","severity":2,"message":"'Chart' is not defined.","line":320,"column":29,"nodeType":"Identifier","messageId":"undef","endLine":320,"endColumn":34},{"ruleId":"no-undef","severity":2,"message":"'Chart' is not defined.","line":366,"column":33,"nodeType":"Identifier","messageId":"undef","endLine":366,"endColumn":38},{"ruleId":"no-undef","severity":2,"message":"'Chart' is not defined.","line":426,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":426,"endColumn":37},{"ruleId":"no-undef","severity":2,"message":"'Chart' is not defined.","line":485,"column":32,"nodeType":"Identifier","messageId":"undef","endLine":485,"endColumn":37}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Progress Dashboard Module\n * Handles data aggregation and visualization for learning progress\n * Displays charts, statistics, and session history\n */\n\nexport class ProgressDashboard {\n  constructor() {\n    this.profileId = null;\n    this.vocabulary = [];\n    this.charts = {};\n    this.data = {\n      phaseDistribution: {},\n      categoryStats: {},\n      directionStats: {},\n      sessionHistory: [],\n      activityData: {}\n    };\n  }\n\n  /**\n   * Initialize the dashboard\n   */\n  async initialize() {\n    try {\n      // Wait for profileManager and phaseCalculator to be available\n      await this.waitForDependencies();\n\n      this.profileId = window.profileManager?.getActiveProfileId() || 'german_learner';\n      this.vocabulary = this.getVocabularyData();\n\n      // Calculate all metrics\n      this.calculateMetrics();\n\n      // Update key metrics display\n      this.updateKeyMetrics();\n\n      // Render all charts\n      this.renderCharts();\n\n      // Display session history\n      this.populateSessionHistory();\n\n      // Listen for profile changes\n      if (window.profileManager) {\n        window.profileManager.onProfileChange(() => {\n          this.handleProfileChange();\n        });\n      }\n\n      console.log('[ProgressDashboard] Initialized successfully');\n    } catch (error) {\n      console.error('[ProgressDashboard] Initialization error:', error);\n      this.showEmptyState();\n    }\n  }\n\n  /**\n   * Wait for required dependencies to load\n   */\n  waitForDependencies() {\n    return new Promise((resolve) => {\n      const checkDeps = () => {\n        if (window.profileManager && window.phaseCalculator) {\n          resolve();\n        } else {\n          setTimeout(checkDeps, 100);\n        }\n      };\n      checkDeps();\n    });\n  }\n\n  /**\n   * Get vocabulary data from the page\n   */\n  getVocabularyData() {\n    // Check if vocabulary is embedded in the page as JSON\n    if (window.vocabulary && Array.isArray(window.vocabulary)) {\n      return window.vocabulary;\n    }\n\n    // Try to extract from embedded script tag\n    const vocabScript = document.querySelector('script[type=\"application/json\"][data-vocab]');\n    if (vocabScript) {\n      try {\n        return JSON.parse(vocabScript.textContent);\n      } catch (error) {\n        console.warn('[ProgressDashboard] Error parsing vocabulary:', error);\n      }\n    }\n\n    return [];\n  }\n\n  /**\n   * Calculate all metrics from localStorage\n   */\n  calculateMetrics() {\n    const phaseDistribution = {\n      '0': 0, // Learned\n      '1': 0, // Phase 1\n      '2': 0,\n      '3': 0,\n      '4': 0,\n      '5': 0,\n      '6': 0,\n      'not-started': 0\n    };\n\n    const categoryStats = {};\n    const directionStats = {\n      'de-bg': { reviewed: 0, learned: 0 },\n      'bg-de': { reviewed: 0, learned: 0 }\n    };\n\n    // Iterate through vocabulary\n    for (const item of this.vocabulary) {\n      // Initialize category if not exists\n      if (!categoryStats[item.category]) {\n        categoryStats[item.category] = { total: 0, learned: 0, reviewed: 0 };\n      }\n      categoryStats[item.category].total++;\n\n      // Check review data for both directions\n      const directions = ['de_bg', 'bg_de'];\n      let hasReviewData = false;\n\n      for (const direction of directions) {\n        const storageKey = `bgde:${this.profileId}:review_${item.id}_${direction}`;\n        const reviewData = this.getReviewData(storageKey);\n\n        if (reviewData) {\n          hasReviewData = true;\n          categoryStats[item.category].reviewed++;\n\n          const directionKey = direction === 'de_bg' ? 'de-bg' : 'bg-de';\n          directionStats[directionKey].reviewed++;\n\n          const phase = this.getPhaseFromData(reviewData);\n          if (phase === '0') {\n            directionStats[directionKey].learned++;\n            categoryStats[item.category].learned++;\n          }\n\n          // Add to phase distribution\n          phaseDistribution[phase]++;\n        }\n      }\n\n      // If no review data, it's not started\n      if (!hasReviewData) {\n        phaseDistribution['not-started']++;\n      }\n    }\n\n    this.data.phaseDistribution = phaseDistribution;\n    this.data.categoryStats = categoryStats;\n    this.data.directionStats = directionStats;\n    this.data.sessionHistory = this.getSessionHistory();\n    this.data.activityData = this.calculateWeeklyActivity();\n  }\n\n  /**\n   * Get review data from localStorage\n   */\n  getReviewData(storageKey) {\n    try {\n      const data = localStorage.getItem(storageKey);\n      return data ? JSON.parse(data) : null;\n    } catch (error) {\n      console.warn(`[ProgressDashboard] Error parsing review data for ${storageKey}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Get phase from review data\n   */\n  getPhaseFromData(reviewData) {\n    if (reviewData.phase !== undefined) {\n      return reviewData.phase.toString();\n    }\n\n    // Calculate from easeFactor if available\n    if (window.phaseCalculator && reviewData.easeFactor !== undefined) {\n      const repetitions = reviewData.repetitions || 0;\n      return window.phaseCalculator.calculatePhase(reviewData.easeFactor, repetitions).toString();\n    }\n\n    return 'not-started';\n  }\n\n  /**\n   * Get session history from localStorage\n   */\n  getSessionHistory() {\n    try {\n      const storageKey = `bgde:${this.profileId}:session_history`;\n      const data = localStorage.getItem(storageKey);\n      if (!data) {\n        return [];\n      }\n\n      const history = JSON.parse(data);\n      // Return last 10 sessions, most recent first\n      return Array.isArray(history) ? history.slice(-10).reverse() : [];\n    } catch (error) {\n      console.warn('[ProgressDashboard] Error parsing session history:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Calculate weekly activity data\n   */\n  calculateWeeklyActivity() {\n    const activity = {};\n    const today = new Date();\n\n    // Initialize last 7 days\n    for (let i = 6; i >= 0; i--) {\n      const date = new Date(today);\n      date.setDate(date.getDate() - i);\n      const dateStr = date.toISOString().split('T')[0];\n      activity[dateStr] = 0;\n    }\n\n    // Count sessions per day\n    for (const session of this.data.sessionHistory) {\n      if (session.timestamp) {\n        const date = new Date(session.timestamp);\n        const dateStr = date.toISOString().split('T')[0];\n        if (activity[dateStr] !== undefined) {\n          activity[dateStr] += session.reviewed || 0;\n        }\n      }\n    }\n\n    return activity;\n  }\n\n  /**\n   * Update key metrics in the DOM\n   */\n  updateKeyMetrics() {\n    const totalWords = this.vocabulary.length;\n    const learnedCount = this.data.phaseDistribution['0'] || 0;\n    const notStartedCount = this.data.phaseDistribution['not-started'] || 0;\n    const inProgressCount = totalWords - learnedCount - notStartedCount;\n\n    document.querySelector('#total-words').textContent = totalWords;\n    document.querySelector('#learned-count').textContent = learnedCount;\n    document.querySelector('#not-started-count').textContent = notStartedCount;\n    document.querySelector('#in-progress-count').textContent = inProgressCount;\n\n    // Update profile name\n    const profileName = this.profileId === 'german_learner' ? 'German Learner 🇩🇪' : 'Bulgarian Learner 🇧🇬';\n    document.querySelector('#active-profile-name').textContent = profileName;\n  }\n\n  /**\n   * Render all charts\n   */\n  renderCharts() {\n    this.renderPhaseChart();\n    this.renderDirectionChart();\n    this.renderCategoryChart();\n    this.renderActivityChart();\n  }\n\n  /**\n   * Render phase distribution doughnut chart\n   */\n  renderPhaseChart() {\n    const ctx = document.querySelector('#phase-chart');\n    if (!ctx) {\n      return;\n    }\n\n    const data = this.data.phaseDistribution;\n    const labels = [\n      'Phase 0 (Learned)',\n      'Phase 1 (New)',\n      'Phase 2 (Learning)',\n      'Phase 3 (Familiar)',\n      'Phase 4 (Known)',\n      'Phase 5 (Mastered)',\n      'Phase 6 (Expert)',\n      'Not Started'\n    ];\n\n    const values = [\n      data['0'] || 0,\n      data['1'] || 0,\n      data['2'] || 0,\n      data['3'] || 0,\n      data['4'] || 0,\n      data['5'] || 0,\n      data['6'] || 0,\n      data['not-started'] || 0\n    ];\n\n    const colors = [\n      '#10b981', // Learned - green\n      '#f59e0b', // Phase 1 - amber\n      '#f97316', // Phase 2 - orange\n      '#ec4899', // Phase 3 - pink\n      '#8b5cf6', // Phase 4 - purple\n      '#3b82f6', // Phase 5 - blue\n      '#06b6d4', // Phase 6 - cyan\n      '#6b7280'  // Not started - gray\n    ];\n\n    // Destroy existing chart if it exists\n    if (this.charts.phase) {\n      this.charts.phase.destroy();\n    }\n\n    this.charts.phase = new Chart(ctx, {\n      type: 'doughnut',\n      data: {\n        labels: labels,\n        datasets: [{\n          data: values,\n          backgroundColor: colors,\n          borderColor: '#ffffff',\n          borderWidth: 2\n        }]\n      },\n      options: {\n        responsive: true,\n        maintainAspectRatio: true,\n        plugins: {\n          legend: {\n            position: 'bottom',\n            labels: {\n              padding: 15,\n              font: { size: 12 }\n            }\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Render direction performance bar chart\n   */\n  renderDirectionChart() {\n    const ctx = document.querySelector('#direction-chart');\n    if (!ctx) {\n      return;\n    }\n\n    const stats = this.data.directionStats;\n    const labels = ['German → Bulgarian', 'Bulgarian → German'];\n    const reviewed = [stats['de-bg'].reviewed || 0, stats['bg-de'].reviewed || 0];\n    const learned = [stats['de-bg'].learned || 0, stats['bg-de'].learned || 0];\n\n    // Destroy existing chart if it exists\n    if (this.charts.direction) {\n      this.charts.direction.destroy();\n    }\n\n    this.charts.direction = new Chart(ctx, {\n      type: 'bar',\n      data: {\n        labels: labels,\n        datasets: [\n          {\n            label: 'Reviewed',\n            data: reviewed,\n            backgroundColor: '#3b82f6'\n          },\n          {\n            label: 'Learned',\n            data: learned,\n            backgroundColor: '#10b981'\n          }\n        ]\n      },\n      options: {\n        responsive: true,\n        maintainAspectRatio: true,\n        plugins: {\n          legend: {\n            position: 'bottom'\n          }\n        },\n        scales: {\n          y: {\n            beginAtZero: true,\n            ticks: {\n              stepSize: 1\n            }\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Render category performance bar chart\n   */\n  renderCategoryChart() {\n    const ctx = document.querySelector('#category-chart');\n    if (!ctx) {\n      return;\n    }\n\n    const stats = this.data.categoryStats;\n    const sortedCategories = Object.entries(stats)\n      .sort((a, b) => b[1].total - a[1].total)\n      .slice(0, 10); // Top 10 categories\n\n    const labels = sortedCategories.map(([cat]) => cat);\n    const totalData = sortedCategories.map(([, data]) => data.total);\n    const learnedData = sortedCategories.map(([, data]) => data.learned);\n\n    // Destroy existing chart if it exists\n    if (this.charts.category) {\n      this.charts.category.destroy();\n    }\n\n    this.charts.category = new Chart(ctx, {\n      type: 'bar',\n      data: {\n        labels: labels,\n        datasets: [\n          {\n            label: 'Total Words',\n            data: totalData,\n            backgroundColor: '#d1d5db'\n          },\n          {\n            label: 'Learned',\n            data: learnedData,\n            backgroundColor: '#10b981'\n          }\n        ]\n      },\n      options: {\n        responsive: true,\n        maintainAspectRatio: true,\n        indexAxis: 'y',\n        plugins: {\n          legend: {\n            position: 'bottom'\n          }\n        },\n        scales: {\n          x: {\n            beginAtZero: true,\n            ticks: {\n              stepSize: 1\n            }\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Render weekly activity line chart\n   */\n  renderActivityChart() {\n    const ctx = document.querySelector('#activity-chart');\n    if (!ctx) {\n      return;\n    }\n\n    const activityData = this.data.activityData;\n    const labels = Object.keys(activityData).map(date => {\n      const d = new Date(date);\n      return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });\n    });\n    const data = Object.values(activityData);\n\n    // Destroy existing chart if it exists\n    if (this.charts.activity) {\n      this.charts.activity.destroy();\n    }\n\n    this.charts.activity = new Chart(ctx, {\n      type: 'line',\n      data: {\n        labels: labels,\n        datasets: [{\n          label: 'Words Reviewed',\n          data: data,\n          borderColor: '#3b82f6',\n          backgroundColor: 'rgba(59, 130, 246, 0.1)',\n          borderWidth: 2,\n          fill: true,\n          tension: 0.4,\n          pointRadius: 4,\n          pointBackgroundColor: '#3b82f6',\n          pointBorderColor: '#ffffff',\n          pointBorderWidth: 2\n        }]\n      },\n      options: {\n        responsive: true,\n        maintainAspectRatio: true,\n        plugins: {\n          legend: {\n            position: 'bottom'\n          }\n        },\n        scales: {\n          y: {\n            beginAtZero: true,\n            ticks: {\n              stepSize: 1\n            }\n          }\n        }\n      }\n    });\n  }\n\n  /**\n   * Populate session history table\n   */\n  populateSessionHistory() {\n    const tbody = document.querySelector('#session-tbody');\n    const sessionCount = document.querySelector('#total-sessions');\n\n    if (!this.data.sessionHistory || this.data.sessionHistory.length === 0) {\n      tbody.innerHTML = '<tr><td colspan=\"4\" class=\"no-data\">No sessions yet. Start practicing to track your progress!</td></tr>';\n      sessionCount.textContent = 'Total Sessions: 0';\n      return;\n    }\n\n    const rows = this.data.sessionHistory.map(session => {\n      const date = new Date(session.timestamp);\n      const dateStr = date.toLocaleDateString('en-US', {\n        month: 'short',\n        day: 'numeric',\n        year: 'numeric',\n        hour: '2-digit',\n        minute: '2-digit'\n      });\n\n      const accuracy = session.correct && session.reviewed\n        ? Math.round((session.correct / session.reviewed) * 100)\n        : 0;\n\n      const duration = session.duration\n        ? this.formatDuration(session.duration)\n        : 'N/A';\n\n      return `\n        <tr>\n          <td>${dateStr}</td>\n          <td>${session.reviewed || 0}</td>\n          <td>${accuracy}%</td>\n          <td>${duration}</td>\n        </tr>\n      `;\n    });\n\n    tbody.innerHTML = rows.join('');\n    sessionCount.textContent = `Total Sessions: ${this.data.sessionHistory.length}`;\n  }\n\n  /**\n   * Format duration in seconds to human-readable format\n   */\n  formatDuration(seconds) {\n    if (!seconds) {\n      return 'N/A';\n    }\n\n    const hours = Math.floor(seconds / 3600);\n    const minutes = Math.floor((seconds % 3600) / 60);\n    const secs = seconds % 60;\n\n    const parts = [];\n    if (hours > 0) {\n      parts.push(`${hours}h`);\n    }\n    if (minutes > 0) {\n      parts.push(`${minutes}m`);\n    }\n    if (secs > 0) {\n      parts.push(`${secs}s`);\n    }\n\n    return parts.join(' ') || '0s';\n  }\n\n  /**\n   * Handle profile change\n   */\n  handleProfileChange() {\n    this.profileId = window.profileManager?.getActiveProfileId() || 'german_learner';\n    this.calculateMetrics();\n    this.updateKeyMetrics();\n    this.renderCharts();\n    this.populateSessionHistory();\n    console.log('[ProgressDashboard] Profile changed, metrics updated');\n  }\n\n  /**\n   * Show empty state\n   */\n  showEmptyState() {\n    const emptyState = document.querySelector('#empty-state');\n    const dashboard = document.querySelector('.progress-dashboard');\n\n    if (emptyState && dashboard) {\n      emptyState.style.display = 'block';\n      dashboard.style.opacity = '0.5';\n    }\n  }\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/search-engine.js","messages":[{"ruleId":"unicorn/no-useless-switch-case","severity":2,"message":"Useless case in switch statement.","line":472,"column":5,"nodeType":"SwitchCase","messageId":"no-useless-switch-case/error","endLine":472,"endColumn":22,"suggestions":[{"messageId":"no-useless-switch-case/suggestion","fix":{"range":[13148,13165],"text":""},"data":{},"desc":"Remove this case."}]},{"ruleId":"no-unused-vars","severity":2,"message":"'id' is assigned a value but never used.","line":659,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":659,"endColumn":19}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Enhanced Search Engine with Full-Text Indexing\n// Provides fast, accurate search across vocabulary and grammar content\n\nclass SearchEngine {\n  constructor() {\n    this.index = new Map();\n    this.documents = new Map();\n    this.stopWords = new Set([\n      // German stop words\n      'der', 'die', 'das', 'und', 'oder', 'aber', 'mit', 'von', 'zu', 'in', 'auf', 'für', 'ist', 'sind', 'war', 'waren',\n      // Bulgarian stop words  \n      'и', 'или', 'но', 'с', 'от', 'до', 'в', 'на', 'за', 'е', 'са', 'беше', 'бяха', 'това', 'тази', 'този',\n      // English stop words\n      'the', 'and', 'or', 'but', 'with', 'from', 'to', 'in', 'on', 'for', 'is', 'are', 'was', 'were'\n    ]);\n    \n    this.searchHistory = [];\n    this.maxHistorySize = 100;\n    this.searchStats = {\n      totalSearches: 0,\n      avgResponseTime: 0,\n      popularTerms: new Map()\n    };\n    \n    this.isIndexed = false;\n    this.indexingPromise = null;\n  }\n\n  // Index building\n  async buildIndex(data) {\n    if (this.indexingPromise) {\n      return this.indexingPromise;\n    }\n\n    this.indexingPromise = this._buildIndexInternal(data);\n    return this.indexingPromise;\n  }\n\n  async _buildIndexInternal(data) {\n    console.log('[SearchEngine] Building search index...');\n    const startTime = performance.now();\n    \n    try {\n      // Clear existing index\n      this.index.clear();\n      this.documents.clear();\n      \n      // Index vocabulary items\n      if (data.vocabulary) {\n        await this.indexVocabulary(data.vocabulary);\n      }\n      \n      // Index grammar items\n      if (data.grammar) {\n        await this.indexGrammar(data.grammar);\n      }\n      \n      // Optimize index for search performance\n      this.optimizeIndex();\n      \n      this.isIndexed = true;\n      const endTime = performance.now();\n      \n      console.log(`[SearchEngine] Index built in ${(endTime - startTime).toFixed(2)}ms`);\n      console.log(`[SearchEngine] Indexed ${this.documents.size} documents with ${this.index.size} terms`);\n      \n    } catch (error) {\n      console.error('[SearchEngine] Index building failed:', error);\n      throw error;\n    } finally {\n      this.indexingPromise = null;\n    }\n  }\n\n  async indexVocabulary(vocabulary) {\n    for (const item of vocabulary) {\n      const doc = {\n        id: item.id,\n        type: 'vocabulary',\n        title: item.word,\n        content: this.buildVocabularyContent(item),\n        category: item.category,\n        level: item.level,\n        source_lang: item.source_lang || 'bg',\n        target_lang: item.target_lang || 'de',\n        difficulty: item.difficulty || 1,\n        frequency: item.frequency || 1,\n        url: `/vocabulary/${item.word}/`,\n        data: item\n      };\n      \n      this.documents.set(doc.id, doc);\n      this.indexDocument(doc);\n    }\n  }\n\n  async indexGrammar(grammar) {\n    for (const item of grammar) {\n      const doc = {\n        id: item.id || `grammar-${item.title}`,\n        type: 'grammar',\n        title: item.title,\n        content: this.buildGrammarContent(item),\n        category: item.category || 'grammar',\n        level: item.level || 'A1',\n        difficulty: item.difficulty || 1,\n        url: `/grammar/${item.slug || item.title}/`,\n        data: item\n      };\n      \n      this.documents.set(doc.id, doc);\n      this.indexDocument(doc);\n    }\n  }\n\n  buildVocabularyContent(item) {\n    const parts = [\n      item.word,\n      item.translation,\n      item.notes || '',\n      item.etymology || '',\n      item.cultural_note || '',\n      item.linguistic_note || ''\n    ];\n    \n    if (item.examples && Array.isArray(item.examples)) {\n      parts.push(...item.examples.map(ex => ex.text || ex));\n    }\n    \n    return parts.filter(Boolean).join(' ');\n  }\n\n  buildGrammarContent(item) {\n    const parts = [\n      item.title,\n      item.description || '',\n      item.content || '',\n      item.examples || ''\n    ];\n    \n    if (item.rules && Array.isArray(item.rules)) {\n      parts.push(...item.rules.map(rule => rule.text || rule));\n    }\n    \n    return parts.filter(Boolean).join(' ');\n  }\n\n  indexDocument(doc) {\n    const terms = this.extractTerms(doc.content + ' ' + doc.title);\n    \n    for (const term of terms) {\n      if (!this.index.has(term)) {\n        this.index.set(term, new Map());\n      }\n      \n      const termIndex = this.index.get(term);\n      if (!termIndex.has(doc.id)) {\n        termIndex.set(doc.id, {\n          frequency: 0,\n          positions: [],\n          inTitle: doc.title.toLowerCase().includes(term)\n        });\n      }\n      \n      const docEntry = termIndex.get(doc.id);\n      docEntry.frequency++;\n    }\n  }\n\n  extractTerms(text) {\n    // Normalize text: lowercase, remove punctuation, split into words\n    const normalized = text\n      .toLowerCase()\n      .replaceAll(/[^\\s\\w\\u0400-\\u04FF]/g, ' ') // Keep Cyrillic characters\n      .replaceAll(/\\s+/g, ' ')\n      .trim();\n    \n    const words = normalized.split(' ');\n    const terms = new Set();\n    \n    for (const word of words) {\n      if (word.length < 2 || this.stopWords.has(word)) {\n        continue;\n      }\n      \n      // Add the word itself\n      terms.add(word);\n      \n      // Add prefixes for partial matching\n      for (let i = 2; i <= Math.min(word.length, 6); i++) {\n        terms.add(word.slice(0, Math.max(0, i)));\n      }\n      \n      // Add suffixes for inflected forms\n      if (word.length > 4) {\n        for (let i = Math.max(2, word.length - 3); i < word.length; i++) {\n          terms.add(word.slice(Math.max(0, i)));\n        }\n      }\n    }\n    \n    return [...terms];\n  }\n\n  optimizeIndex() {\n    // Remove very common terms that don't add value\n    const docCount = this.documents.size;\n    const maxDocFreq = docCount * 0.8; // Terms in >80% of docs\n    \n    for (const [term, termIndex] of this.index.entries()) {\n      if (termIndex.size > maxDocFreq) {\n        this.index.delete(term);\n      }\n    }\n  }\n\n  // Search functionality\n  async search(query, options = {}) {\n    const startTime = performance.now();\n    \n    try {\n      // Ensure index is built\n      if (!this.isIndexed) {\n        throw new Error('Search index not ready. Call buildIndex() first.');\n      }\n      \n      const {\n        type = 'all', // 'vocabulary', 'grammar', 'all'\n        category = '',\n        level = '',\n        limit = 50,\n        offset = 0,\n        sortBy = 'relevance', // 'relevance', 'alphabetical', 'difficulty'\n        direction = '',\n        minScore = 0.1\n      } = options;\n      \n      // Parse and normalize query\n      const searchTerms = this.parseQuery(query);\n      if (searchTerms.length === 0) {\n        return { results: [], total: 0, query, responseTime: 0 };\n      }\n      \n      // Find matching documents\n      const matches = this.findMatches(searchTerms, {\n        type, category, level, direction, minScore\n      });\n      \n      // Sort results\n      const sortedResults = this.sortResults(matches, sortBy);\n      \n      // Apply pagination\n      const paginatedResults = sortedResults.slice(offset, offset + limit);\n      \n      // Build result objects\n      const results = paginatedResults.map(match => this.buildResult(match, searchTerms));\n      \n      const endTime = performance.now();\n      const responseTime = endTime - startTime;\n      \n      // Update statistics\n      this.updateSearchStats(query, responseTime, results.length);\n      \n      return {\n        results,\n        total: sortedResults.length,\n        query,\n        responseTime,\n        suggestions: this.generateSuggestions(query, results.length)\n      };\n      \n    } catch (error) {\n      console.error('[SearchEngine] Search failed:', error);\n      throw error;\n    }\n  }\n\n  parseQuery(query) {\n    if (!query || typeof query !== 'string') {\n      return [];\n    }\n    \n    // Handle quoted phrases\n    const phrases = [];\n    const quotedRegex = /\"([^\"]+)\"/g;\n    let match;\n    \n    while ((match = quotedRegex.exec(query)) !== null) {\n      phrases.push(match[1].toLowerCase().trim());\n    }\n    \n    // Remove quoted phrases from query and get individual terms\n    const remainingQuery = query.replaceAll(quotedRegex, '').trim();\n    const individualTerms = this.extractTerms(remainingQuery);\n    \n    return [...phrases, ...individualTerms].filter(term => term.length >= 2);\n  }\n\n  findMatches(searchTerms, filters) {\n    const matches = new Map();\n    \n    for (const term of searchTerms) {\n      const termMatches = this.findTermMatches(term);\n      \n      for (const [docId, termScore] of termMatches) {\n        const doc = this.documents.get(docId);\n        \n        // Apply filters\n        if (!this.passesFilters(doc, filters)) {\n          continue;\n        }\n        \n        if (!matches.has(docId)) {\n          matches.set(docId, {\n            doc,\n            score: 0,\n            termMatches: new Map()\n          });\n        }\n        \n        const match = matches.get(docId);\n        match.score += termScore;\n        match.termMatches.set(term, termScore);\n      }\n    }\n    \n    // Calculate final scores\n    for (const match of matches.values()) {\n      match.score = this.calculateRelevanceScore(match, searchTerms);\n    }\n    \n    return [...matches.values()];\n  }\n\n  findTermMatches(term) {\n    const matches = new Map();\n    \n    // Exact matches\n    if (this.index.has(term)) {\n      const termIndex = this.index.get(term);\n      for (const [docId, docData] of termIndex) {\n        matches.set(docId, docData.frequency * (docData.inTitle ? 2 : 1));\n      }\n    }\n    \n    // Fuzzy matches for longer terms\n    if (term.length >= 4) {\n      for (const [indexTerm, termIndex] of this.index) {\n        if (indexTerm !== term && this.isFuzzyMatch(term, indexTerm)) {\n          const fuzzyScore = this.calculateFuzzyScore(term, indexTerm);\n          \n          for (const [docId, docData] of termIndex) {\n            const currentScore = matches.get(docId) || 0;\n            const newScore = docData.frequency * fuzzyScore * (docData.inTitle ? 1.5 : 1);\n            matches.set(docId, Math.max(currentScore, newScore));\n          }\n        }\n      }\n    }\n    \n    return matches;\n  }\n\n  isFuzzyMatch(term1, term2) {\n    // Simple fuzzy matching based on edit distance\n    if (Math.abs(term1.length - term2.length) > 2) {\n      return false;\n    }\n    \n    const distance = this.levenshteinDistance(term1, term2);\n    const maxDistance = Math.floor(Math.max(term1.length, term2.length) * 0.3);\n    \n    return distance <= maxDistance;\n  }\n\n  levenshteinDistance(str1, str2) {\n    const matrix = Array.from({ length: str2.length + 1 }).fill().map(() => Array.from({ length: str1.length + 1 }).fill(0));\n    \n    for (let i = 0; i <= str1.length; i++) {\n      matrix[0][i] = i;\n    }\n    for (let j = 0; j <= str2.length; j++) {\n      matrix[j][0] = j;\n    }\n    \n    for (let j = 1; j <= str2.length; j++) {\n      for (let i = 1; i <= str1.length; i++) {\n        const cost = str1[i - 1] === str2[j - 1] ? 0 : 1;\n        matrix[j][i] = Math.min(\n          matrix[j - 1][i] + 1,\n          matrix[j][i - 1] + 1,\n          matrix[j - 1][i - 1] + cost\n        );\n      }\n    }\n    \n    return matrix[str2.length][str1.length];\n  }\n\n  calculateFuzzyScore(term1, term2) {\n    const distance = this.levenshteinDistance(term1, term2);\n    const maxLength = Math.max(term1.length, term2.length);\n    return Math.max(0, (maxLength - distance) / maxLength) * 0.7;\n  }\n\n  passesFilters(doc, filters) {\n    if (filters.type && filters.type !== 'all' && doc.type !== filters.type) {\n      return false;\n    }\n    \n    if (filters.category && doc.category !== filters.category) {\n      return false;\n    }\n    \n    if (filters.level && doc.level !== filters.level) {\n      return false;\n    }\n    \n    if (filters.direction) {\n      const [source, target] = filters.direction.split('-');\n      if (doc.source_lang !== source || doc.target_lang !== target) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n\n  calculateRelevanceScore(match, searchTerms) {\n    const doc = match.doc;\n    let score = match.score;\n    \n    // Boost score based on document properties\n    if (doc.type === 'vocabulary') {\n      score *= 1.2; // Slight preference for vocabulary\n    }\n    \n    // Boost based on difficulty (easier items rank higher for beginners)\n    if (doc.difficulty) {\n      score *= (6 - doc.difficulty) / 5;\n    }\n    \n    // Boost based on frequency (more common words rank higher)\n    if (doc.frequency) {\n      score *= Math.log(doc.frequency + 1);\n    }\n    \n    // Boost for title matches\n    const titleTerms = this.extractTerms(doc.title);\n    const titleMatches = searchTerms.filter(term => \n      titleTerms.some(titleTerm => titleTerm.includes(term) || term.includes(titleTerm))\n    );\n    \n    if (titleMatches.length > 0) {\n      score *= 1.5;\n    }\n    \n    // Normalize score\n    return score / Math.max(1, searchTerms.length);\n  }\n\n  sortResults(matches, sortBy) {\n    switch (sortBy) {\n    case 'alphabetical': {\n      return matches.sort((a, b) => a.doc.title.localeCompare(b.doc.title));\n    }\n      \n    case 'difficulty': {\n      return matches.sort((a, b) => (a.doc.difficulty || 1) - (b.doc.difficulty || 1));\n    }\n      \n    case 'relevance':\n    default: {\n      return matches.sort((a, b) => b.score - a.score);\n    }\n    }\n  }\n\n  buildResult(match, searchTerms) {\n    const doc = match.doc;\n    \n    return {\n      id: doc.id,\n      type: doc.type,\n      title: doc.title,\n      snippet: this.generateSnippet(doc.content, searchTerms),\n      category: doc.category,\n      level: doc.level,\n      url: doc.url,\n      score: match.score,\n      highlights: this.generateHighlights(doc, searchTerms),\n      data: doc.data\n    };\n  }\n\n  generateSnippet(content, searchTerms, maxLength = 200) {\n    const sentences = content.split(/[!.?]+/);\n    let bestSentence = '';\n    let maxMatches = 0;\n    \n    for (const sentence of sentences) {\n      const matches = searchTerms.filter(term => \n        sentence.toLowerCase().includes(term.toLowerCase())\n      ).length;\n      \n      if (matches > maxMatches) {\n        maxMatches = matches;\n        bestSentence = sentence.trim();\n      }\n    }\n    \n    if (bestSentence.length > maxLength) {\n      bestSentence = bestSentence.slice(0, Math.max(0, maxLength)) + '...';\n    }\n    \n    return bestSentence || content.slice(0, Math.max(0, maxLength)) + '...';\n  }\n\n  generateHighlights(doc, searchTerms) {\n    const highlights = [];\n    \n    for (const term of searchTerms) {\n      const regex = new RegExp(`\\\\b${this.escapeRegex(term)}\\\\w*`, 'gi');\n      const titleMatches = doc.title.match(regex) || [];\n      const contentMatches = doc.content.match(regex) || [];\n      \n      if (titleMatches.length > 0 || contentMatches.length > 0) {\n        highlights.push({\n          term,\n          titleMatches,\n          contentMatches: contentMatches.slice(0, 5) // Limit content matches\n        });\n      }\n    }\n    \n    return highlights;\n  }\n\n  escapeRegex(string) {\n    return string.replaceAll(/[$()*+.?[\\\\\\]^{|}]/g, '\\\\$&');\n  }\n\n  // Search suggestions and autocomplete\n  generateSuggestions(query, resultCount) {\n    if (resultCount > 0) {\n      return []; // No suggestions needed if we have results\n    }\n    \n    const suggestions = [];\n    const queryTerms = this.extractTerms(query);\n    \n    // Find similar terms in the index\n    for (const [indexTerm] of this.index) {\n      for (const queryTerm of queryTerms) {\n        if (indexTerm.includes(queryTerm) || queryTerm.includes(indexTerm)) {\n          suggestions.push(indexTerm);\n        }\n      }\n    }\n    \n    // Add popular search terms\n    const popularTerms = [...this.searchStats.popularTerms.entries()]\n      .sort((a, b) => b[1] - a[1])\n      .slice(0, 5)\n      .map(([term]) => term);\n    \n    suggestions.push(...popularTerms);\n    \n    return [...new Set(suggestions)].slice(0, 5);\n  }\n\n  async getAutocompleteSuggestions(query, limit = 10) {\n    if (!query || query.length < 2) {\n      return [];\n    }\n    \n    const queryLower = query.toLowerCase();\n    const suggestions = [];\n    \n    // Find terms that start with the query\n    for (const [term] of this.index) {\n      if (term.startsWith(queryLower) && term !== queryLower) {\n        suggestions.push(term);\n        \n        if (suggestions.length >= limit) {\n          break;\n        }\n      }\n    }\n    \n    return suggestions;\n  }\n\n  // Statistics and analytics\n  updateSearchStats(query, responseTime, resultCount) {\n    this.searchStats.totalSearches++;\n    \n    // Update average response time\n    const totalTime = this.searchStats.avgResponseTime * (this.searchStats.totalSearches - 1) + responseTime;\n    this.searchStats.avgResponseTime = totalTime / this.searchStats.totalSearches;\n    \n    // Track popular terms\n    const terms = this.extractTerms(query);\n    for (const term of terms) {\n      const count = this.searchStats.popularTerms.get(term) || 0;\n      this.searchStats.popularTerms.set(term, count + 1);\n    }\n    \n    // Add to search history\n    this.searchHistory.unshift({\n      query,\n      resultCount,\n      timestamp: Date.now(),\n      responseTime\n    });\n    \n    // Limit history size\n    if (this.searchHistory.length > this.maxHistorySize) {\n      this.searchHistory = this.searchHistory.slice(0, this.maxHistorySize);\n    }\n  }\n\n  getSearchStats() {\n    return {\n      ...this.searchStats,\n      indexSize: this.index.size,\n      documentCount: this.documents.size,\n      isIndexed: this.isIndexed,\n      recentSearches: this.searchHistory.slice(0, 10)\n    };\n  }\n\n  // Utility methods\n  clearIndex() {\n    this.index.clear();\n    this.documents.clear();\n    this.isIndexed = false;\n  }\n\n  getIndexInfo() {\n    return {\n      termCount: this.index.size,\n      documentCount: this.documents.size,\n      isIndexed: this.isIndexed,\n      memoryUsage: this.estimateMemoryUsage()\n    };\n  }\n\n  estimateMemoryUsage() {\n    let size = 0;\n    \n    // Estimate index size\n    for (const [term, termIndex] of this.index) {\n      size += term.length * 2; // Rough estimate for string\n      size += termIndex.size * 50; // Rough estimate for term data\n    }\n    \n    // Estimate document size\n    for (const [id, doc] of this.documents) {\n      size += JSON.stringify(doc).length * 2;\n    }\n    \n    return size;\n  }\n}\n\n// Create and export singleton instance\nconst searchEngine = new SearchEngine();\n\nexport default searchEngine;\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/service-worker.js","messages":[{"ruleId":"unicorn/prefer-add-event-listener","severity":2,"message":"Prefer `addEventListener` over `onmessage`. Note that there is difference between `SharedWorker#onmessage` and `SharedWorker#addEventListener('message')`.","line":346,"column":28,"nodeType":"Identifier","messageId":"prefer-add-event-listener","endLine":346,"endColumn":37},{"ruleId":"unicorn/prefer-add-event-listener","severity":2,"message":"Prefer `addEventListener` over `onmessage`. Note that there is difference between `SharedWorker#onmessage` and `SharedWorker#addEventListener('message')`.","line":365,"column":28,"nodeType":"Identifier","messageId":"prefer-add-event-listener","endLine":365,"endColumn":37}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Service Worker Registration and Management\n// Handles PWA functionality, offline support, and cache management\n\nclass ServiceWorkerManager {\n  constructor() {\n    this.swRegistration = null;\n    this.updateAvailable = false;\n    this.isOnline = navigator.onLine;\n    \n    this.init();\n  }\n\n  async init() {\n    if (!('serviceWorker' in navigator)) {\n      console.warn('[SW Manager] Service Worker not supported');\n      return;\n    }\n\n    const host = window.location.hostname;\n    const isDev = host === 'localhost' || host === '127.0.0.1';\n\n    if (isDev) {\n      console.log('[SW Manager] Skipping registration in development environment');\n      return;\n    }\n\n    try {\n      // Register service worker\n      this.swRegistration = await navigator.serviceWorker.register('/sw-workbox.js', {\n        scope: '/'\n      });\n\n      console.log('[SW Manager] Service Worker registered successfully');\n\n      // Set up event listeners\n      this.setupEventListeners();\n      \n      // Check for updates\n      this.checkForUpdates();\n      \n      // Set up periodic update checks\n      this.setupPeriodicUpdateCheck();\n\n    } catch (error) {\n      console.error('[SW Manager] Service Worker registration failed:', error);\n    }\n  }\n\n  setupEventListeners() {\n    // Listen for service worker updates\n    this.swRegistration.addEventListener('updatefound', () => {\n      const newWorker = this.swRegistration.installing;\n      \n      newWorker.addEventListener('statechange', () => {\n        if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {\n          // New version available\n          this.updateAvailable = true;\n          this.showUpdateNotification();\n        }\n      });\n    });\n\n    // Listen for messages from service worker\n    navigator.serviceWorker.addEventListener('message', (event) => {\n      this.handleServiceWorkerMessage(event.data);\n    });\n\n    // Listen for connection changes\n    window.addEventListener('online', () => {\n      this.isOnline = true;\n      this.handleConnectionChange(true);\n    });\n\n    window.addEventListener('offline', () => {\n      this.isOnline = false;\n      this.handleConnectionChange(false);\n    });\n\n    // Listen for beforeinstallprompt (PWA install)\n    window.addEventListener('beforeinstallprompt', (event) => {\n      event.preventDefault();\n      this.showInstallPrompt(event);\n    });\n\n    // Listen for app installed\n    window.addEventListener('appinstalled', () => {\n      console.log('[SW Manager] PWA installed successfully');\n      this.hideInstallPrompt();\n    });\n  }\n\n  handleServiceWorkerMessage(data) {\n    switch (data.type) {\n    case 'SW_ACTIVATED': {\n      console.log('[SW Manager] Service Worker activated, version:', data.version);\n      this.hideUpdateNotification();\n      break;\n    }\n        \n    case 'CACHE_UPDATED': {\n      console.log('[SW Manager] Cache updated for:', data.url);\n      break;\n    }\n        \n    default: {\n      console.log('[SW Manager] Unknown message from SW:', data);\n    }\n    }\n  }\n\n  async checkForUpdates() {\n    if (!this.swRegistration) {\n      return;\n    }\n\n    try {\n      await this.swRegistration.update();\n    } catch (error) {\n      console.error('[SW Manager] Failed to check for updates:', error);\n    }\n  }\n\n  setupPeriodicUpdateCheck() {\n    // Check for updates every 30 minutes\n    setInterval(() => {\n      if (this.isOnline) {\n        this.checkForUpdates();\n      }\n    }, 30 * 60 * 1000);\n  }\n\n  showUpdateNotification() {\n    // Remove existing notification\n    this.hideUpdateNotification();\n\n    const notification = document.createElement('div');\n    notification.id = 'sw-update-notification';\n    notification.className = 'sw-notification update-available';\n    notification.innerHTML = `\n      <div class=\"notification-content\">\n        <div class=\"notification-icon\">🔄</div>\n        <div class=\"notification-text\">\n          <strong>Update Available</strong>\n          <p>A new version of the app is ready. Refresh to update.</p>\n        </div>\n        <div class=\"notification-actions\">\n          <button id=\"sw-update-btn\" class=\"btn btn-primary btn-sm\">Update</button>\n          <button id=\"sw-dismiss-btn\" class=\"btn btn-secondary btn-sm\">Later</button>\n        </div>\n      </div>\n    `;\n\n    document.body.append(notification);\n\n    // Add event listeners\n    document.querySelector('#sw-update-btn').addEventListener('click', () => {\n      this.applyUpdate();\n    });\n\n    document.querySelector('#sw-dismiss-btn').addEventListener('click', () => {\n      this.hideUpdateNotification();\n    });\n\n    // Auto-hide after 10 seconds\n    setTimeout(() => {\n      this.hideUpdateNotification();\n    }, 10_000);\n  }\n\n  hideUpdateNotification() {\n    const notification = document.querySelector('#sw-update-notification');\n    if (notification) {\n      notification.remove();\n    }\n  }\n\n  async applyUpdate() {\n    if (!this.swRegistration || !this.swRegistration.waiting) {\n      console.warn('[SW Manager] No update available to apply');\n      return;\n    }\n\n    // Tell the waiting service worker to skip waiting\n    this.swRegistration.waiting.postMessage({ type: 'SKIP_WAITING' });\n    \n    // Reload the page to activate the new service worker\n    window.location.reload();\n  }\n\n  showInstallPrompt(event) {\n    // Only show if not already installed and user hasn't dismissed recently\n    const lastDismissed = localStorage.getItem('bgde:pwa-install-dismissed');\n    const now = Date.now();\n    const dismissedRecently = lastDismissed && (now - Number.parseInt(lastDismissed)) < 7 * 24 * 60 * 60 * 1000; // 7 days\n\n    if (dismissedRecently) {\n      return;\n    }\n\n    const prompt = document.createElement('div');\n    prompt.id = 'pwa-install-prompt';\n    prompt.className = 'sw-notification install-prompt';\n    prompt.innerHTML = `\n      <div class=\"notification-content\">\n        <div class=\"notification-icon\">📱</div>\n        <div class=\"notification-text\">\n          <strong>Install App</strong>\n          <p>Add Bulgarian-German Learning to your home screen for quick access.</p>\n        </div>\n        <div class=\"notification-actions\">\n          <button id=\"pwa-install-btn\" class=\"btn btn-primary btn-sm\">Install</button>\n          <button id=\"pwa-dismiss-btn\" class=\"btn btn-secondary btn-sm\">Not Now</button>\n        </div>\n      </div>\n    `;\n\n    document.body.append(prompt);\n\n    // Add event listeners\n    document.querySelector('#pwa-install-btn').addEventListener('click', async () => {\n      try {\n        await event.prompt();\n        const choiceResult = await event.userChoice;\n        \n        if (choiceResult.outcome === 'accepted') {\n          console.log('[SW Manager] User accepted PWA install');\n        } else {\n          console.log('[SW Manager] User dismissed PWA install');\n        }\n        \n        this.hideInstallPrompt();\n      } catch (error) {\n        console.error('[SW Manager] PWA install failed:', error);\n      }\n    });\n\n    document.querySelector('#pwa-dismiss-btn').addEventListener('click', () => {\n      localStorage.setItem('bgde:pwa-install-dismissed', now.toString());\n      this.hideInstallPrompt();\n    });\n\n    // Auto-hide after 15 seconds\n    setTimeout(() => {\n      this.hideInstallPrompt();\n    }, 15_000);\n  }\n\n  hideInstallPrompt() {\n    const prompt = document.querySelector('#pwa-install-prompt');\n    if (prompt) {\n      prompt.remove();\n    }\n  }\n\n  handleConnectionChange(isOnline) {\n    console.log('[SW Manager] Connection changed:', isOnline ? 'online' : 'offline');\n    \n    // Show connection status notification\n    this.showConnectionNotification(isOnline);\n    \n    // Trigger cache sync when coming back online\n    if (isOnline && this.swRegistration) {\n      this.syncWhenOnline();\n    }\n  }\n\n  showConnectionNotification(isOnline) {\n    // Remove existing notification\n    const existing = document.querySelector('#connection-notification');\n    if (existing) {\n      existing.remove();\n    }\n\n    const notification = document.createElement('div');\n    notification.id = 'connection-notification';\n    notification.className = `sw-notification connection-status ${isOnline ? 'online' : 'offline'}`;\n    notification.innerHTML = `\n      <div class=\"notification-content\">\n        <div class=\"notification-icon\">${isOnline ? '🟢' : '🔴'}</div>\n        <div class=\"notification-text\">\n          <strong>${isOnline ? 'Back Online' : 'You\\'re Offline'}</strong>\n          <p>${isOnline ? 'All features are now available.' : 'Using cached content. Some features may be limited.'}</p>\n        </div>\n      </div>\n    `;\n\n    document.body.append(notification);\n\n    // Auto-hide after 3 seconds\n    setTimeout(() => {\n      const notif = document.querySelector('#connection-notification');\n      if (notif) {\n        notif.remove();\n      }\n    }, 3000);\n  }\n\n  async syncWhenOnline() {\n    if (!this.swRegistration || !this.isOnline) {\n      return;\n    }\n\n    try {\n      // Trigger background sync if supported\n      if ('sync' in window.ServiceWorkerRegistration.prototype) {\n        await this.swRegistration.sync.register('background-sync');\n      }\n      \n      // Prefetch vocabulary data\n      await this.prefetchVocabularyData();\n      \n    } catch (error) {\n      console.error('[SW Manager] Sync failed:', error);\n    }\n  }\n\n  async prefetchVocabularyData() {\n    try {\n      // Load vocabulary data and send to service worker for prefetching\n      const response = await fetch('/search-index.json');\n      if (response.ok) {\n        const data = await response.json();\n        \n        if (this.swRegistration && this.swRegistration.active) {\n          this.swRegistration.active.postMessage({\n            type: 'PREFETCH_VOCABULARY',\n            data: { items: data.vocabulary || [] }\n          });\n        }\n      }\n    } catch (error) {\n      console.warn('[SW Manager] Failed to prefetch vocabulary:', error);\n    }\n  }\n\n  // Public API methods\n  async clearCache() {\n    if (!this.swRegistration || !this.swRegistration.active) {\n      console.warn('[SW Manager] No active service worker to clear cache');\n      return false;\n    }\n\n    return new Promise((resolve) => {\n      const messageChannel = new MessageChannel();\n      \n      messageChannel.port1.onmessage = (event) => {\n        resolve(event.data.success);\n      };\n      \n      this.swRegistration.active.postMessage(\n        { type: 'CLEAR_CACHE' },\n        [messageChannel.port2]\n      );\n    });\n  }\n\n  async getVersion() {\n    if (!this.swRegistration || !this.swRegistration.active) {\n      return null;\n    }\n\n    return new Promise((resolve) => {\n      const messageChannel = new MessageChannel();\n      \n      messageChannel.port1.onmessage = (event) => {\n        resolve(event.data);\n      };\n      \n      this.swRegistration.active.postMessage(\n        { type: 'GET_VERSION' },\n        [messageChannel.port2]\n      );\n    });\n  }\n\n  isSupported() {\n    return 'serviceWorker' in navigator;\n  }\n\n  isInstalled() {\n    return window.matchMedia('(display-mode: standalone)').matches ||\n           window.navigator.standalone === true;\n  }\n}\n\n// Create and export singleton instance\nconst serviceWorkerManager = new ServiceWorkerManager();\n\nexport default serviceWorkerManager;\n\n// Also make available globally for non-module usage\nif (typeof window !== 'undefined') {\n  window.serviceWorkerManager = serviceWorkerManager;\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/text-to-speech.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/user-preferences.js","messages":[{"ruleId":"unicorn/prefer-number-properties","severity":2,"message":"Prefer `Number.isNaN` over `isNaN`.","line":179,"column":9,"nodeType":"Identifier","messageId":"error","endLine":179,"endColumn":14,"suggestions":[{"messageId":"suggestion","fix":{"range":[4805,4810],"text":"Number.isNaN"},"data":{"description":"isNaN","property":"isNaN"},"desc":"Replace `isNaN` with `Number.isNaN`."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// User Preferences Service\n// Manages user settings, language direction, and learning preferences\n\nclass UserPreferences {\n  constructor() {\n    this.storageKey = 'bgde:user-preferences';\n    this.defaults = {\n      // Language and direction settings\n      nativeLanguage: 'de', // 'bg' or 'de'\n      learningDirection: 'bg-de', // 'bg-de' or 'de-bg'\n      \n      // UI preferences\n      theme: 'auto', // 'light', 'dark', 'auto'\n      fontSize: 'medium', // 'small', 'medium', 'large'\n      animationsEnabled: true,\n      soundEnabled: true,\n      \n      // Learning preferences\n      sessionLength: 20, // number of items per session\n      difficultyLevel: 'adaptive', // 'easy', 'medium', 'hard', 'adaptive'\n      showCulturalContext: true,\n      showEtymology: true,\n      showExamples: true,\n      \n      // Spaced repetition settings\n      easyMultiplier: 1.3,\n      hardMultiplier: 0.8,\n      intervalCap: 365, // max days between reviews\n      \n      // Practice settings\n      practiceMode: 'mixed', // 'flashcards', 'typing', 'multiple-choice', 'mixed'\n      showHints: true,\n      autoPlayAudio: false,\n      \n      // Categories and levels\n      preferredCategories: [],\n      preferredLevels: ['A1', 'A2'],\n      \n      // Privacy and data\n      analyticsEnabled: true,\n      syncEnabled: false,\n      \n      // Accessibility\n      highContrast: false,\n      reducedMotion: false,\n      screenReaderOptimized: false,\n      \n      // Advanced settings\n      debugMode: false,\n      betaFeatures: false\n    };\n    \n    this.preferences = this.load();\n    this.listeners = new Set();\n    \n    // Apply preferences on initialization\n    this.applyPreferences();\n  }\n\n  // Core preference management\n  load() {\n    try {\n      const stored = localStorage.getItem(this.storageKey);\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        return { ...this.defaults, ...parsed };\n      }\n    } catch (error) {\n      console.warn('[UserPreferences] Failed to load preferences:', error);\n    }\n    \n    return { ...this.defaults };\n  }\n\n  save() {\n    try {\n      localStorage.setItem(this.storageKey, JSON.stringify(this.preferences));\n      this.notifyListeners('save', this.preferences);\n      return true;\n    } catch (error) {\n      console.error('[UserPreferences] Failed to save preferences:', error);\n      return false;\n    }\n  }\n\n  get(key) {\n    return key ? this.preferences[key] : { ...this.preferences };\n  }\n\n  set(key, value) {\n    if (typeof key === 'object') {\n      // Bulk update\n      Object.assign(this.preferences, key);\n    } else {\n      // Single key update\n      this.preferences[key] = value;\n    }\n    \n    this.save();\n    this.applyPreferences();\n    this.notifyListeners('change', { key, value });\n  }\n\n  reset(keys = null) {\n    if (keys) {\n      // Reset specific keys\n      const keysArray = Array.isArray(keys) ? keys : [keys];\n      for (const key of keysArray) {\n        if (key in this.defaults) {\n          this.preferences[key] = this.defaults[key];\n        }\n      }\n    } else {\n      // Reset all preferences\n      this.preferences = { ...this.defaults };\n    }\n    \n    this.save();\n    this.applyPreferences();\n    this.notifyListeners('reset', keys);\n  }\n\n  // Language and direction management\n  setNativeLanguage(language) {\n    if (!['bg', 'de'].includes(language)) {\n      throw new Error('Invalid native language. Must be \"bg\" or \"de\"');\n    }\n    \n    this.set('nativeLanguage', language);\n    \n    // Auto-adjust learning direction based on native language\n    const newDirection = language === 'bg' ? 'bg-de' : 'de-bg';\n    this.set('learningDirection', newDirection);\n  }\n\n  setLearningDirection(direction) {\n    if (!['bg-de', 'de-bg'].includes(direction)) {\n      throw new Error('Invalid learning direction. Must be \"bg-de\" or \"de-bg\"');\n    }\n    \n    this.set('learningDirection', direction);\n  }\n\n  toggleLearningDirection() {\n    const current = this.get('learningDirection');\n    const newDirection = current === 'bg-de' ? 'de-bg' : 'bg-de';\n    this.setLearningDirection(newDirection);\n    return newDirection;\n  }\n\n  getSourceLanguage() {\n    return this.get('learningDirection').split('-')[0];\n  }\n\n  getTargetLanguage() {\n    return this.get('learningDirection').split('-')[1];\n  }\n\n  // UI preferences\n  setTheme(theme) {\n    if (!['light', 'dark', 'auto'].includes(theme)) {\n      throw new Error('Invalid theme. Must be \"light\", \"dark\", or \"auto\"');\n    }\n    \n    this.set('theme', theme);\n  }\n\n  setFontSize(size) {\n    if (!['small', 'medium', 'large'].includes(size)) {\n      throw new Error('Invalid font size. Must be \"small\", \"medium\", or \"large\"');\n    }\n    \n    this.set('fontSize', size);\n  }\n\n  // Learning preferences\n  setSessionLength(length) {\n    const numLength = Number.parseInt(length);\n    if (isNaN(numLength) || numLength < 5 || numLength > 100) {\n      throw new Error('Session length must be between 5 and 100');\n    }\n    \n    this.set('sessionLength', numLength);\n  }\n\n  setDifficultyLevel(level) {\n    if (!['easy', 'medium', 'hard', 'adaptive'].includes(level)) {\n      throw new Error('Invalid difficulty level');\n    }\n    \n    this.set('difficultyLevel', level);\n  }\n\n  // Category and level preferences\n  addPreferredCategory(category) {\n    const categories = this.get('preferredCategories');\n    if (!categories.includes(category)) {\n      categories.push(category);\n      this.set('preferredCategories', categories);\n    }\n  }\n\n  removePreferredCategory(category) {\n    const categories = this.get('preferredCategories');\n    const index = categories.indexOf(category);\n    if (index > -1) {\n      categories.splice(index, 1);\n      this.set('preferredCategories', categories);\n    }\n  }\n\n  setPreferredLevels(levels) {\n    const validLevels = new Set(['A1', 'A2', 'B1', 'B2', 'C1', 'C2']);\n    const filteredLevels = levels.filter(level => validLevels.has(level));\n    this.set('preferredLevels', filteredLevels);\n  }\n\n  // Spaced repetition customization\n  setSpacedRepetitionSettings(settings) {\n    const { easyMultiplier, hardMultiplier, intervalCap } = settings;\n    \n    const updates = {};\n    \n    if (easyMultiplier !== undefined) {\n      if (easyMultiplier < 1.1 || easyMultiplier > 3) {\n        throw new Error('Easy multiplier must be between 1.1 and 3.0');\n      }\n      updates.easyMultiplier = easyMultiplier;\n    }\n    \n    if (hardMultiplier !== undefined) {\n      if (hardMultiplier < 0.3 || hardMultiplier > 0.9) {\n        throw new Error('Hard multiplier must be between 0.3 and 0.9');\n      }\n      updates.hardMultiplier = hardMultiplier;\n    }\n    \n    if (intervalCap !== undefined) {\n      if (intervalCap < 30 || intervalCap > 1000) {\n        throw new Error('Interval cap must be between 30 and 1000 days');\n      }\n      updates.intervalCap = intervalCap;\n    }\n    \n    this.set(updates);\n  }\n\n  // Apply preferences to DOM and environment\n  applyPreferences() {\n    this.applyTheme();\n    this.applyFontSize();\n    this.applyAccessibility();\n    this.applyAnimations();\n  }\n\n  applyTheme() {\n    const theme = this.get('theme');\n    const root = document.documentElement;\n    \n    if (theme === 'auto') {\n      // Use system preference\n      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;\n      root.dataset.theme = prefersDark ? 'dark' : 'light';\n    } else {\n      root.dataset.theme = theme;\n    }\n  }\n\n  applyFontSize() {\n    const fontSize = this.get('fontSize');\n    const root = document.documentElement;\n    \n    const sizeMap = {\n      small: '14px',\n      medium: '16px',\n      large: '18px'\n    };\n    \n    root.style.setProperty('--base-font-size', sizeMap[fontSize]);\n  }\n\n  applyAccessibility() {\n    const root = document.documentElement;\n    \n    if (this.get('highContrast')) {\n      root.classList.add('high-contrast');\n    } else {\n      root.classList.remove('high-contrast');\n    }\n    \n    if (this.get('reducedMotion')) {\n      root.classList.add('reduced-motion');\n    } else {\n      root.classList.remove('reduced-motion');\n    }\n    \n    if (this.get('screenReaderOptimized')) {\n      root.classList.add('screen-reader-optimized');\n    } else {\n      root.classList.remove('screen-reader-optimized');\n    }\n  }\n\n  applyAnimations() {\n    const animationsEnabled = this.get('animationsEnabled');\n    const root = document.documentElement;\n    \n    if (animationsEnabled) {\n      root.classList.remove('no-animations');\n    } else {\n      root.classList.add('no-animations');\n    }\n  }\n\n  // Event system\n  addListener(callback) {\n    this.listeners.add(callback);\n    return () => this.listeners.delete(callback);\n  }\n\n  removeListener(callback) {\n    this.listeners.delete(callback);\n  }\n\n  notifyListeners(event, data) {\n    for (const callback of this.listeners) {\n      try {\n        callback(event, data);\n      } catch (error) {\n        console.error('[UserPreferences] Listener error:', error);\n      }\n    }\n  }\n\n  // Import/Export\n  export() {\n    return {\n      preferences: this.preferences,\n      version: '1.0.0',\n      exportedAt: new Date().toISOString()\n    };\n  }\n\n  import(data) {\n    try {\n      if (data.version && data.preferences) {\n        // Validate imported preferences\n        const validPrefs = {};\n        for (const key of Object.keys(this.defaults)) {\n          if (key in data.preferences) {\n            validPrefs[key] = data.preferences[key];\n          }\n        }\n        \n        this.preferences = { ...this.defaults, ...validPrefs };\n        this.save();\n        this.applyPreferences();\n        this.notifyListeners('import', validPrefs);\n        \n        return true;\n      }\n    } catch (error) {\n      console.error('[UserPreferences] Import failed:', error);\n    }\n    \n    return false;\n  }\n\n  // Utility methods\n  isDarkMode() {\n    const theme = this.get('theme');\n    if (theme === 'dark') {\n      return true;\n    }\n    if (theme === 'light') {\n      return false;\n    }\n    \n    // Auto mode - check system preference\n    return window.matchMedia('(prefers-color-scheme: dark)').matches;\n  }\n\n  getEffectiveDifficulty() {\n    const level = this.get('difficultyLevel');\n    if (level === 'adaptive') {\n      // Could implement adaptive logic based on user performance\n      return 'medium';\n    }\n    return level;\n  }\n\n  shouldShowFeature(feature) {\n    const featureMap = {\n      culturalContext: 'showCulturalContext',\n      etymology: 'showEtymology',\n      examples: 'showExamples',\n      hints: 'showHints',\n      audio: 'soundEnabled',\n      animations: 'animationsEnabled'\n    };\n    \n    const prefKey = featureMap[feature];\n    return prefKey ? this.get(prefKey) : true;\n  }\n\n  // Debug and development\n  getDebugInfo() {\n    return {\n      preferences: this.preferences,\n      defaults: this.defaults,\n      storageKey: this.storageKey,\n      listenerCount: this.listeners.size,\n      storageSize: JSON.stringify(this.preferences).length\n    };\n  }\n}\n\n// Create and export singleton instance\nconst userPreferences = new UserPreferences();\n\nexport default userPreferences;\n\n// Also make available globally for non-module usage\nif (typeof window !== 'undefined') {\n  window.userPreferences = userPreferences;\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/vocabulary-api.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":44,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":44,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[938,941],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[938,941],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[961,964],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[961,964],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Modular Vocabulary API\n * Provides lazy-loading capabilities for split vocabulary data\n * Maintains backward compatibility with existing loading patterns\n */\n\ninterface VocabularyEntry {\n  id: string;\n  word: string;\n  translation: string;\n  source_lang: string;\n  target_lang: string;\n  category?: string;\n  level?: string;\n  notes?: string;\n  notes_bg_to_de?: string;\n  notes_de_to_bg?: string;\n  etymology?: string;\n  cultural_note?: string;\n  linguistic_note?: string;\n  difficulty?: number;\n  frequency?: number;\n  examples?: Array<{\n    sentence: string;\n    translation: string;\n    context?: string;\n    note?: string;\n  }>;\n}\n\ninterface VocabularyIndex {\n  generated: string;\n  totalEntries: number;\n  splitFiles: Array<{\n    file: string;\n    entryCount: number;\n    sizeKB: number;\n    categories: string[];\n  }>;\n  summary: {\n    totalFiles: number;\n    totalSizeKB: number;\n    averageSizeKB: number;\n    largestFile: any;\n    smallestFile: any;\n  };\n}\n\nclass VocabularyAPI {\n  private loadedChunks: Map<string, VocabularyEntry[]> = new Map();\n  private index: VocabularyIndex | null = null;\n  private basePath = '/data/vocab/';\n\n  constructor() {\n    this.loadIndex();\n  }\n\n  /**\n   * Load the vocabulary index to understand available chunks\n   */\n  private async loadIndex(): Promise<void> {\n    try {\n      const response = await fetch(`${this.basePath}index.json`);\n      if (response.ok) {\n        this.index = await response.json();\n        console.log(`[VocabularyAPI] Loaded index with ${this.index?.totalEntries} entries across ${this.index?.splitFiles.length} files`);\n      }\n    } catch {\n      console.warn('[VocabularyAPI] Failed to load vocabulary index, using fallback loading');\n    }\n  }\n\n  /**\n   * Load a specific vocabulary chunk by file name\n   */\n  async loadChunk(fileName: string): Promise<VocabularyEntry[]> {\n    // Check if already loaded\n    if (this.loadedChunks.has(fileName)) {\n      return this.loadedChunks.get(fileName)!;\n    }\n\n    try {\n      // Use dynamic import for JSON files\n      const module = await import(`../../data/vocab/${fileName}`);\n      const entries: VocabularyEntry[] = module.default;\n      \n      if (Array.isArray(entries)) {\n        this.loadedChunks.set(fileName, entries);\n        console.log(`[VocabularyAPI] Loaded chunk ${fileName} with ${entries.length} entries`);\n        return entries;\n      } else {\n        throw new TypeError(`Invalid data format in ${fileName}`);\n      }\n    } catch (error) {\n      console.error(`[VocabularyAPI] Failed to load chunk ${fileName}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Load vocabulary by CEFR level\n   */\n  async loadByLevel(level: string): Promise<VocabularyEntry[]> {\n    const fileName = `${level}.json`;\n    return this.loadChunk(fileName);\n  }\n\n  /**\n   * Load vocabulary by category\n   */\n  async loadByCategory(category: string): Promise<VocabularyEntry[]> {\n    // Sanitize category name to match file naming convention\n    const sanitizedCategory = category\n      .toLowerCase()\n      .replaceAll(/[^\\da-zßäöü]/g, '-')\n      .replaceAll(/-+/g, '-')\n      .replaceAll(/^-|-$/g, '');\n    \n    const fileName = `${sanitizedCategory}.json`;\n    return this.loadChunk(fileName);\n  }\n\n  /**\n   * Load all vocabulary (combines all chunks)\n   */\n  async loadAll(): Promise<VocabularyEntry[]> {\n    if (!this.index) {\n      await this.loadIndex();\n    }\n\n    if (!this.index) {\n      throw new Error('Vocabulary index not available');\n    }\n\n    const allEntries: VocabularyEntry[] = [];\n    const loadedIds = new Set<string>();\n\n    // Load each chunk and combine entries, avoiding duplicates\n    for (const fileInfo of this.index.splitFiles) {\n      try {\n        const entries = await this.loadChunk(fileInfo.file);\n        \n        for (const entry of entries) {\n          if (!loadedIds.has(entry.id)) {\n            loadedIds.add(entry.id);\n            allEntries.push(entry);\n          }\n        }\n      } catch {\n        console.warn(`[VocabularyAPI] Failed to load chunk ${fileInfo.file}, skipping`);\n      }\n    }\n\n    console.log(`[VocabularyAPI] Loaded ${allEntries.length} unique entries from all chunks`);\n    return allEntries;\n  }\n\n  /**\n   * Load vocabulary with filters (level, category, search)\n   */\n  async loadFiltered(filters: { level?: string; category?: string; search?: string } = {}): Promise<VocabularyEntry[]> {\n    const allEntries = await this.loadAll();\n    \n    let filtered = allEntries;\n\n    if (filters.level) {\n      filtered = filtered.filter(item => item.level === filters.level);\n    }\n\n    if (filters.category) {\n      filtered = filtered.filter(item => item.category === filters.category);\n    }\n\n    if (filters.search) {\n      const searchTerm = filters.search.toLowerCase();\n      filtered = filtered.filter(item => \n        item.word.toLowerCase().includes(searchTerm) ||\n        (item.translation && item.translation.toLowerCase().includes(searchTerm))\n      );\n    }\n\n    return filtered;\n  }\n\n  /**\n   * Get specific vocabulary item by ID\n   */\n  async getItemById(id: string): Promise<VocabularyEntry | null> {\n    if (!this.index) {\n      await this.loadIndex();\n    }\n\n    if (!this.index) {\n      return null;\n    }\n\n    // Search through chunks to find the item\n    for (const fileInfo of this.index.splitFiles) {\n      try {\n        const entries = await this.loadChunk(fileInfo.file);\n        const item = entries.find(entry => entry.id === id);\n        if (item) {\n          return item;\n        }\n      } catch {\n        // Continue searching other chunks\n        continue;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get available levels from index\n   */\n  getAvailableLevels(): string[] {\n    if (!this.index) return [];\n    \n    const levels = new Set<string>();\n    for (const file of this.index.splitFiles) {\n      if (/^(A1|A2|B1|B2)\\.json$/.test(file.file)) {\n        levels.add(file.file.replace('.json', ''));\n      }\n    }\n    return [...levels];\n  }\n\n  /**\n   * Get available categories from index\n   */\n  getAvailableCategories(): string[] {\n    if (!this.index) return [];\n    \n    const categories = new Set<string>();\n    for (const file of this.index.splitFiles) {\n      if (!/^(A1|A2|B1|B2)\\.json$/.test(file.file)) {\n        for (const cat of file.categories) categories.add(cat);\n      }\n    }\n    return [...categories];\n  }\n\n  /**\n   * Clear loaded chunks to free memory\n   */\n  clearCache(): void {\n    this.loadedChunks.clear();\n    console.log('[VocabularyAPI] Cache cleared');\n  }\n\n  /**\n   * Get memory usage statistics\n   */\n  getMemoryStats(): { loadedChunks: number; totalEntries: number; cacheSizeKB: number } {\n    let totalEntries = 0;\n    let cacheSizeKB = 0;\n\n    for (const entries of this.loadedChunks) {\n      totalEntries += entries.length;\n      // Rough estimate: 1KB per entry\n      cacheSizeKB += entries.length;\n    }\n\n    return {\n      loadedChunks: this.loadedChunks.size,\n      totalEntries,\n      cacheSizeKB\n    };\n  }\n}\n\n// Create singleton instance\nconst vocabularyAPI = new VocabularyAPI();\n\n// Export for use in other modules\nexport { vocabularyAPI, VocabularyAPI, VocabularyEntry };\nexport default vocabularyAPI;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/vocabulary-manager.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/modules/vocabulary-page.js","messages":[{"ruleId":"unicorn/prefer-ternary","severity":2,"message":"This `if` statement can be replaced by a ternary expression.","line":77,"column":9,"nodeType":"IfStatement","messageId":"prefer-ternary","endLine":81,"endColumn":10},{"ruleId":"unicorn/prefer-number-properties","severity":2,"message":"Prefer `Number.isNaN` over `isNaN`.","line":156,"column":33,"nodeType":"Identifier","messageId":"error","endLine":156,"endColumn":38,"suggestions":[{"messageId":"suggestion","fix":{"range":[5158,5163],"text":"Number.isNaN"},"data":{"description":"isNaN","property":"isNaN"},"desc":"Replace `isNaN` with `Number.isNaN`."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Vocabulary Page Module - Lazy loaded only on vocabulary pages\n * Handles vocabulary listing, filtering, and selection\n */\n\nclass VocabularyPageModule {\n  constructor(options = {}) {\n    this.container = options.container || '#vocabulary-grid';\n    this.adapter = options.adapter;\n    this.enhancedVocab = null;\n    this.culturalToggle = null;\n    this.filters = {};\n    this.searchTimeout = null;\n    this.isSearching = false;\n\n    // Performance optimization: Virtual scrolling threshold\n    this.virtualScrollThreshold = 1000;\n    this.virtualScrollEnabled = false;\n    this.visibleItems = [];\n    this.allItems = [];\n\n    // Pagination state\n    this.currentPage = 1;\n    this.itemsPerPage = 50;\n    this.totalPages = 1;\n    this.totalItems = 0; // Total items in dataset (unfiltered)\n    this.paginatedItems = [];\n\n    // Pagination persistence\n    this.persistenceKey = 'bgde:vocabulary-pagination';\n    this.filterPersistenceKey = 'bgde:vocabulary-filters';\n  }\n\n  domApplyFilters() {\n    const levelSel = document.querySelector('#level-filter');\n    const catSel = document.querySelector('#category-filter');\n    const searchInput = document.querySelector('#search-input');\n    const level = levelSel ? levelSel.value : '';\n    const cat = catSel ? catSel.value : '';\n    const q = (searchInput?.value || '').toLowerCase();\n    const phase = this.activePhaseFilter || '';\n\n    let shown = 0;\n    for (const card of document.querySelectorAll('#vocabulary-grid .vocab-card')) {\n      const l = card.dataset.level || '';\n      const c = card.dataset.category || '';\n      const w = (card.dataset.word || '').toLowerCase();\n      const t = (card.dataset.translation || '').toLowerCase();\n      const itemId = card.dataset.id;\n\n      // Check phase match if phase filter is active\n      let phaseMatches = true;\n      if (phase && itemId) {\n        const itemPhase = this.getItemPhase(itemId);\n        phaseMatches = itemPhase.toString() === phase;\n      }\n\n      const matches = (!level || l === level) && (!cat || c === cat) && (!q || w.includes(q) || t.includes(q)) && phaseMatches;\n      card.style.display = matches ? '' : 'none';\n      if (matches) {\n        shown++;\n      }\n    }\n    const showing = document.querySelector('#showing-count');\n    if (showing) {\n      showing.textContent = shown;\n    }\n  }\n\n  updateDirectionUI(dir) {\n    // Update all vocabulary cards to show correct direction\n    for (const card of document.querySelectorAll('#vocabulary-grid .vocab-card')) {\n      // Update direction-aware notes (show only the relevant direction)\n      const directionNotes = card.querySelectorAll('.vocab-note-direction');\n      for (const note of directionNotes) {\n        const noteDirection = note.dataset.direction;\n        if (noteDirection === dir) {\n          note.style.display = ''; // Show\n        } else {\n          note.style.display = 'none'; // Hide\n        }\n      }\n          \n      // If using vocabById data, also update word/translation\n      if (this.vocabById) {\n        const id = card.dataset.id;\n        const item = id && this.vocabById.get(id);\n        if (!item) {\n          continue;\n        }\n\n        const wordEl = card.querySelector('.vocab-word');\n        const transEl = card.querySelector('.vocab-translation');\n\n        if (wordEl && transEl) {\n          if (dir === 'de-bg') {\n            wordEl.textContent = item.translation || '';\n            transEl.textContent = item.word || '';\n          } else {\n            wordEl.textContent = item.word || '';\n            transEl.textContent = item.translation || '';\n          }\n        }\n      }\n    }\n      \n    console.log(`[VocabularyPage] Updated direction UI to: ${dir}`);\n  }\n\n  async init() {\n    try {\n      // Ensure any optional globals are in place\n      await this.loadDependencies();\n      // Parse inline data for direction-aware DOM updates\n      this.loadInlineData();\n\n      // Initialize pagination from URL\n      this.initializePaginationFromURL();\n\n      // Initialize components\n      this.initializeFilters();\n      this.initializeVocabularyCards();\n      this.initializeCulturalToggle();\n      this.initializeEventListeners();\n      this.initializePagination();\n      this.initializeVirtualScrolling();\n\n      // Initial render with performance optimization\n      this.performInitialRender();\n\n      console.log('VocabularyPageModule initialized successfully');\n    } catch (error) {\n      console.error('Failed to initialize VocabularyPageModule:', error);\n      this.showErrorState();\n    }\n  }\n\n  initializePaginationFromURL() {\n    const urlParams = new URLSearchParams(window.location.search);\n\n    // Read page from URL or localStorage or default to 1\n    let pageParam = urlParams.get('page');\n\n    if (!pageParam) {\n      // Try to restore from localStorage\n      const persisted = this.loadPersistedPagination();\n      if (persisted && persisted.page) {\n        pageParam = persisted.page;\n        console.log(`[Pagination] Restored from localStorage: page ${pageParam}`);\n      }\n    }\n\n    this.currentPage = pageParam ? Number.parseInt(pageParam, 10) : 1;\n\n    // Validate page number\n    if (this.currentPage < 1 || isNaN(this.currentPage)) {\n      this.currentPage = 1;\n    }\n\n    // Read filters from URL\n    this.initializeFiltersFromURL(urlParams);\n\n    console.log(`[Pagination] Initialized from URL: page ${this.currentPage}`);\n  }\n\n  /**\n     * Initialize filters from URL query parameters\n     * Supports: ?level=A1&category=Verb&search=hello\n     */\n  initializeFiltersFromURL(urlParams) {\n    if (!urlParams) {\n      urlParams = new URLSearchParams(window.location.search);\n    }\n\n    const level = urlParams.get('level');\n    const category = urlParams.get('category');\n    const search = urlParams.get('search');\n\n    if (level && this.filters.level) {\n      this.filters.level.value = level;\n    }\n\n    if (category && this.filters.category) {\n      this.filters.category.value = category;\n    }\n\n    if (search && this.filters.search) {\n      this.filters.search.value = search;\n    }\n\n    console.log(`[Filters] Initialized from URL: level=${level}, category=${category}, search=${search}`);\n  }\n\n  /**\n     * Load persisted pagination state from localStorage\n     */\n  loadPersistedPagination() {\n    try {\n      const stored = localStorage.getItem(this.persistenceKey);\n      if (stored) {\n        return JSON.parse(stored);\n      }\n    } catch (error) {\n      console.warn('[Pagination] Failed to load persisted state:', error);\n    }\n    return null;\n  }\n\n  /**\n     * Save pagination state to localStorage\n     */\n  savePaginationState() {\n    try {\n      const state = {\n        page: this.currentPage,\n        timestamp: Date.now()\n      };\n      localStorage.setItem(this.persistenceKey, JSON.stringify(state));\n    } catch (error) {\n      console.warn('[Pagination] Failed to save state:', error);\n    }\n  }\n\n  /**\n     * Save filter state to localStorage\n     */\n  saveFilterState() {\n    try {\n      const state = {\n        level: this.filters.level?.value || '',\n        category: this.filters.category?.value || '',\n        search: this.filters.search?.value || '',\n        timestamp: Date.now()\n      };\n      localStorage.setItem(this.filterPersistenceKey, JSON.stringify(state));\n    } catch (error) {\n      console.warn('[Filters] Failed to save state:', error);\n    }\n  }\n\n  initializePagination() {\n    // Calculate total pages based on all items\n    this.calculatePagination();\n\n    // Setup pagination controls\n    this.setupPaginationControls();\n\n    // Setup keyboard shortcuts\n    this.setupKeyboardShortcuts();\n\n    // Listen for browser back/forward navigation\n    window.addEventListener('popstate', () => {\n      this.initializePaginationFromURL();\n      this.renderCurrentPage();\n    });\n\n    // Enable virtual scrolling if item count exceeds threshold\n    if (this.allItems.length >= this.virtualScrollThreshold) {\n      this.virtualScrollEnabled = true;\n      console.log(`[VirtualScroll] Enabled for ${this.allItems.length} items`);\n    }\n\n    console.log(`[Pagination] Setup complete: ${this.totalPages} pages (virtual scroll: ${this.virtualScrollEnabled})`);\n  }\n\n  /**\n     * Setup keyboard shortcuts for pagination navigation\n     */\n  setupKeyboardShortcuts() {\n    document.addEventListener('keydown', (e) => {\n      // Ignore if user is typing in an input field\n      if (e.target.matches('input, textarea, select')) {\n        return;\n      }\n\n      // Ignore if modifier keys are pressed (Ctrl, Alt, Meta)\n      if (e.ctrlKey || e.altKey || e.metaKey) {\n        return;\n      }\n\n      switch(e.key) {\n      case 'PageDown': {\n        e.preventDefault();\n        this.goToPage(this.currentPage + 1);\n        this.announceToScreenReader(`Page ${this.currentPage} of ${this.totalPages}`);\n        break;\n      }\n\n      case 'PageUp': {\n        e.preventDefault();\n        this.goToPage(this.currentPage - 1);\n        this.announceToScreenReader(`Page ${this.currentPage} of ${this.totalPages}`);\n        break;\n      }\n\n      case 'Home': {\n        // Ctrl+Home or just Home if not in input\n        if (e.ctrlKey || !e.target.matches('input, textarea, select')) {\n          e.preventDefault();\n          this.goToPage(1);\n          this.announceToScreenReader('First page');\n        }\n        break;\n      }\n\n      case 'End': {\n        // Ctrl+End or just End if not in input\n        if (e.ctrlKey || !e.target.matches('input, textarea, select')) {\n          e.preventDefault();\n          this.goToPage(this.totalPages);\n          this.announceToScreenReader('Last page');\n        }\n        break;\n      }\n\n      case 'ArrowLeft': {\n        // Alt+Left Arrow for previous page\n        if (e.altKey) {\n          e.preventDefault();\n          this.goToPage(this.currentPage - 1);\n        }\n        break;\n      }\n\n      case 'ArrowRight': {\n        // Alt+Right Arrow for next page\n        if (e.altKey) {\n          e.preventDefault();\n          this.goToPage(this.currentPage + 1);\n        }\n        break;\n      }\n      }\n    });\n\n    console.log('[KeyboardShortcuts] Pagination shortcuts enabled (PageUp/PageDown, Home/End, Alt+Arrows)');\n  }\n\n  /**\n     * Announce message to screen readers\n     */\n  announceToScreenReader(message) {\n    const announcement = document.createElement('div');\n    announcement.setAttribute('role', 'status');\n    announcement.setAttribute('aria-live', 'polite');\n    announcement.setAttribute('aria-atomic', 'true');\n    announcement.className = 'sr-only';\n    announcement.style.position = 'absolute';\n    announcement.style.left = '-10000px';\n    announcement.style.width = '1px';\n    announcement.style.height = '1px';\n    announcement.style.overflow = 'hidden';\n    announcement.textContent = message;\n\n    document.body.append(announcement);\n\n    setTimeout(() => {\n      announcement.remove();\n    }, 1000);\n  }\n\n  calculatePagination() {\n    const vocabGrid = document.querySelector('#vocabulary-grid');\n    if (!vocabGrid) {\n      console.warn('[Pagination] vocabulary-grid not found');\n      return;\n    }\n\n    // Get all vocabulary cards\n    const allCards = [...vocabGrid.querySelectorAll('.vocab-card')];\n    this.allItems = allCards;\n    this.totalItems = allCards.length; // Store total unfiltered count\n\n    // Calculate total pages based on all items\n    this.totalPages = Math.ceil(this.totalItems / this.itemsPerPage);\n\n    // Ensure current page is within bounds\n    if (this.currentPage > this.totalPages && this.totalPages > 0) {\n      this.currentPage = this.totalPages;\n    }\n\n    console.log(`[Pagination] Calculated: ${this.totalItems} total items, ${this.totalPages} pages`);\n  }\n\n  setupPaginationControls() {\n    // Previous button\n    const prevBtns = document.querySelectorAll('.pagination-prev');\n    for (const btn of prevBtns) {\n      btn.addEventListener('click', (e) => {\n        e.preventDefault();\n        this.goToPage(this.currentPage - 1);\n      });\n    }\n\n    // Next button\n    const nextBtns = document.querySelectorAll('.pagination-next');\n    for (const btn of nextBtns) {\n      btn.addEventListener('click', (e) => {\n        e.preventDefault();\n        this.goToPage(this.currentPage + 1);\n      });\n    }\n\n    // Page jump dropdown\n    const pageJump = document.querySelector('#page-jump');\n    if (pageJump) {\n      pageJump.addEventListener('change', (e) => {\n        const page = Number.parseInt(e.target.value, 10);\n        this.goToPage(page);\n      });\n    }\n\n    // Page number links\n    const pageNumbers = document.querySelectorAll('.pagination-number');\n    for (const link of pageNumbers) {\n      link.addEventListener('click', (e) => {\n        e.preventDefault();\n        const page = Number.parseInt(link.textContent, 10);\n        this.goToPage(page);\n      });\n    }\n  }\n\n  goToPage(page) {\n    // Validate page number\n    if (page < 1 || page > this.totalPages) {\n      console.warn(`[Pagination] Invalid page: ${page}`);\n      return;\n    }\n\n    this.currentPage = page;\n\n    // Update URL without reload (including current filters)\n    this.updateURLWithState();\n\n    // Save to localStorage for persistence\n    this.savePaginationState();\n\n    // Render the new page\n    this.renderCurrentPage();\n\n    // Scroll to top\n    window.scrollTo({ top: 0, behavior: 'smooth' });\n\n    console.log(`[Pagination] Navigated to page ${page}`);\n  }\n\n  /**\n     * Update URL with current pagination and filter state\n     */\n  updateURLWithState() {\n    const url = new URL(window.location);\n\n    // Update page\n    url.searchParams.set('page', this.currentPage);\n\n    // Update filters if they have values\n    const level = this.filters.level?.value;\n    const category = this.filters.category?.value;\n    const search = this.filters.search?.value;\n\n    if (level) {\n      url.searchParams.set('level', level);\n    } else {\n      url.searchParams.delete('level');\n    }\n\n    if (category) {\n      url.searchParams.set('category', category);\n    } else {\n      url.searchParams.delete('category');\n    }\n\n    if (search) {\n      url.searchParams.set('search', search);\n    } else {\n      url.searchParams.delete('search');\n    }\n\n    // Update browser history\n    window.history.pushState({\n      page: this.currentPage,\n      level,\n      category,\n      search\n    }, '', url);\n  }\n\n  renderCurrentPage() {\n    const vocabGrid = document.querySelector('#vocabulary-grid');\n    if (!vocabGrid) {\n      return;\n    }\n\n    // Get all cards (respecting current filters)\n    const allCards = [...vocabGrid.querySelectorAll('.vocab-card')];\n    const visibleCards = allCards.filter(card => card.style.display !== 'none');\n\n    // Calculate pagination for visible cards\n    const totalVisible = visibleCards.length;\n    this.totalPages = Math.ceil(totalVisible / this.itemsPerPage);\n\n    // Ensure current page is within bounds\n    if (this.currentPage > this.totalPages && this.totalPages > 0) {\n      this.currentPage = this.totalPages;\n    }\n\n    // Calculate slice indices\n    const startIndex = (this.currentPage - 1) * this.itemsPerPage;\n    const endIndex = startIndex + this.itemsPerPage;\n\n    // Use virtual scrolling for large datasets\n    if (this.virtualScrollEnabled && totalVisible >= this.virtualScrollThreshold) {\n      this.renderVirtualScrollPage(visibleCards, startIndex, endIndex);\n    } else {\n      // Standard rendering: hide all, show current page\n      for (const card of allCards) {\n        if (card.style.display !== 'none') {\n          card.style.display = 'none';\n          card.dataset.paginated = 'true';\n        }\n      }\n\n      // Show only cards for current page\n      const pageCards = visibleCards.slice(startIndex, endIndex);\n      for (const card of pageCards) {\n        card.style.display = '';\n      }\n    }\n\n    // Update pagination UI\n    this.updatePaginationUI();\n\n    // Update showing count\n    const showingCount = document.querySelector('#showing-count');\n    if (showingCount) {\n      const actualShowing = Math.min(this.itemsPerPage, totalVisible - startIndex);\n      showingCount.textContent = actualShowing;\n    }\n\n    console.log(`[Pagination] Rendered page ${this.currentPage}: showing ${Math.min(this.itemsPerPage, totalVisible - startIndex)} of ${totalVisible} items (virtual: ${this.virtualScrollEnabled})`);\n  }\n\n  /**\n     * Virtual scrolling optimization for large datasets\n     * Only renders visible items + buffer zone\n     */\n  renderVirtualScrollPage(visibleCards, startIndex, endIndex) {\n    const vocabGrid = document.querySelector('#vocabulary-grid');\n    if (!vocabGrid) {\n      return;\n    }\n\n    // Buffer zone: render extra items above/below for smooth scrolling\n    const bufferSize = 10;\n    const renderStart = Math.max(0, startIndex - bufferSize);\n    const renderEnd = Math.min(visibleCards.length, endIndex + bufferSize);\n\n    // Hide all cards\n    for (const card of visibleCards) {\n      card.style.display = 'none';\n    }\n\n    // Show only cards in render range\n    for (let i = renderStart; i < renderEnd; i++) {\n      visibleCards[i].style.display = '';\n    }\n\n    console.log(`[VirtualScroll] Rendered items ${renderStart}-${renderEnd} (visible: ${startIndex}-${endIndex})`);\n  }\n\n  updatePaginationUI() {\n    // Update pagination info\n    const paginationInfo = document.querySelector('.pagination-info');\n    if (paginationInfo) {\n      const span = paginationInfo.querySelector('span');\n      if (span) {\n        span.textContent = `Seite ${this.currentPage} von ${this.totalPages} / Страница ${this.currentPage} от ${this.totalPages}`;\n      }\n    }\n\n    // Update previous button\n    const prevBtns = document.querySelectorAll('.pagination-prev');\n    for (const btn of prevBtns) {\n      btn.style.display = this.currentPage <= 1 ? 'none' : '';\n    }\n\n    // Update next button\n    const nextBtns = document.querySelectorAll('.pagination-next');\n    for (const btn of nextBtns) {\n      btn.style.display = this.currentPage >= this.totalPages ? 'none' : '';\n    }\n\n    // Update page jump dropdown\n    const pageJump = document.querySelector('#page-jump');\n    if (pageJump) {\n      // Rebuild options\n      pageJump.innerHTML = '';\n      for (let i = 1; i <= this.totalPages; i++) {\n        const option = document.createElement('option');\n        option.value = i;\n        option.textContent = i;\n        if (i === this.currentPage) {\n          option.selected = true;\n        }\n        pageJump.append(option);\n      }\n    }\n\n    // Show/hide pagination controls\n    // CRITICAL FIX: Always show pagination if total items > itemsPerPage,\n    // even if current filter shows fewer items. This prevents pagination\n    // from disappearing when filters are applied or during initial load.\n    const paginationNav = document.querySelector('.pagination');\n    if (paginationNav) {\n      const shouldShowPagination = this.totalItems > this.itemsPerPage || this.totalPages > 1;\n      paginationNav.style.display = shouldShowPagination ? '' : 'none';\n\n      if (shouldShowPagination) {\n        console.log(`[Pagination] Showing pagination: ${this.totalItems} total items, ${this.totalPages} pages`);\n      }\n    }\n  }\n\n  loadInlineData() {\n    try {\n      const script = document.querySelector('#vocabulary-data');\n      const parsed = script ? JSON.parse(script.textContent || '[]') : [];\n      this.inlineVocab = Array.isArray(parsed) ? parsed : [];\n      this.vocabById = new Map(this.inlineVocab.map(it => [it.id, it]));\n    } catch (error) {\n      this.inlineVocab = [];\n      this.vocabById = new Map();\n      console.warn('Failed to parse inline vocabulary data', error);\n    }\n  }\n\n  async loadDependencies() {\n    // All dependencies are loaded via classic script tags; nothing to do here.\n    return [];\n  }\n\n  initializeFilters() {\n    this.filters = {\n      level: document.querySelector('#level-filter'),\n      category: document.querySelector('#category-filter'),\n      search: document.querySelector('#search-input'),\n      phase: null // Phase is filter type only, no single input element\n    };\n\n    // Store active phase filter value\n    this.activePhaseFilter = '';\n  }\n\n  initializeVocabularyCards() {\n    if (!window.EnhancedVocabCards) {\n      return;\n    }\n\n    try {\n      this.enhancedVocab = new window.EnhancedVocabCards();\n    } catch (error) {\n      console.warn('Failed to initialise EnhancedVocabCards:', error);\n      this.enhancedVocab = null;\n    }\n  }\n\n  initializeCulturalToggle() {\n    const container = document.querySelector('#cultural-context-container');\n    if (!container || !window.CulturalContextToggle) {\n      return;\n    }\n\n    try {\n      this.culturalToggle = new window.CulturalContextToggle({\n        container\n      });\n      this.culturalToggle.init();\n    } catch (error) {\n      console.warn('Failed to initialise CulturalContextToggle:', error);\n      this.culturalToggle = null;\n    }\n  }\n\n  initializeEventListeners() {\n    // Optimized event listeners with debouncing\n    if (this.filters.level) {\n      this.filters.level.addEventListener('change', () => this.applyFilters());\n    }\n        \n    if (this.filters.category) {\n      this.filters.category.addEventListener('change', () => this.applyFilters());\n    }\n\n    if (this.filters.search) {\n      this.filters.search.addEventListener('input', (e) => this.handleSearch(e));\n      this.filters.search.addEventListener('keydown', (e) => this.handleSearchKeydown(e));\n    }\n\n    // Practice selected functionality\n    const practiceBtn = document.querySelector('#practice-selected');\n    if (practiceBtn) {\n      practiceBtn.addEventListener('click', () => this.handlePracticeSelected());\n    }\n\n    // Clear filters\n    const clearBtn = document.querySelector('#clear-filters');\n    if (clearBtn) {\n      clearBtn.addEventListener('click', () => this.clearFilters());\n    }\n\n    // Individual practice buttons (using event delegation for dynamic content)\n    const vocabGrid = document.querySelector('#vocabulary-grid');\n    if (vocabGrid) {\n      vocabGrid.addEventListener('click', (e) => {\n        const practiceBtn = e.target.closest('.practice-single-btn');\n        if (practiceBtn) {\n          this.handlePracticeSingle(practiceBtn);\n        }\n      });\n    }\n\n    // Quick filter buttons (icon-based)\n    const quickFilterButtons = document.querySelectorAll('.quick-filter-btn');\n    for (const btn of quickFilterButtons) {\n      btn.addEventListener('click', (e) => this.handleQuickFilter(e));\n    }\n\n    // Language direction changes\n    document.addEventListener('learning-direction-changed', () => {\n      this.updateDirectionUI(this.getCurrentDirection());\n      this.applyFilters();\n    });\n    document.addEventListener('language-direction-changed', (e) => {\n      const dir = e?.detail?.direction || this.getCurrentDirection();\n      this.updateDirectionUI(dir);\n      this.applyFilters();\n    });\n  }\n\n  initializeVirtualScrolling() {\n    if (!this.container) {\n      return;\n    }\n\n    const container = document.querySelector(this.container);\n    if (!container) {\n      return;\n    }\n\n    // Implement intersection observer for virtual scrolling\n    this.intersectionObserver = new IntersectionObserver(\n      (entries) => this.handleIntersection(entries),\n      {\n        root: container,\n        rootMargin: '50px',\n        threshold: 0.1\n      }\n    );\n  }\n\n  handleIntersection(entries) {\n    for (const entry of entries) {\n      if (entry.isIntersecting) {\n        // Load more items when scrolling near bottom\n        this.loadMoreItems();\n      }\n    }\n  }\n\n  handleSearch(event) {\n    clearTimeout(this.searchTimeout);\n        \n    const query = event.target.value;\n        \n    if (!this.isSearching && query.length > 0) {\n      this.showSearchIndicator();\n    }\n\n    this.searchTimeout = setTimeout(() => {\n      this.performSearch(query);\n      this.hideSearchIndicator();\n    }, 250);\n  }\n\n  handleSearchKeydown(event) {\n    if (event.key === 'Escape') {\n      event.target.value = '';\n      this.applyFilters();\n      event.target.blur();\n    }\n  }\n\n  performSearch(query) {\n    // Optimized search with indexing\n    const searchIndex = this.buildSearchIndex();\n    const results = this.searchInIndex(searchIndex, query);\n    this.renderSearchResults(results);\n  }\n\n  buildSearchIndex() {\n    // Create search index for better performance\n    if (this.searchIndex) {\n      return this.searchIndex;\n    }\n\n    this.searchIndex = this.allItems.map(item => ({\n      id: item.id,\n      searchText: [\n        item.word,\n        item.translation,\n        item.category,\n        item.level,\n        item.notes || '',\n        item.etymology || '',\n        item.cultural_note || ''\n      ].join(' ').toLowerCase(),\n      item: item\n    }));\n\n    return this.searchIndex;\n  }\n\n  searchInIndex(index, query) {\n    const lowerQuery = query.toLowerCase();\n    return index.filter(entry => \n      entry.searchText.includes(lowerQuery)\n    ).map(entry => entry.item);\n  }\n\n  applyFilters() {\n    // Reset to page 1 when filters change\n    this.currentPage = 1;\n\n    // Save filter state\n    this.saveFilterState();\n\n    // Update URL with new filter state\n    this.updateURLWithState();\n\n    const currentDirection = this.getCurrentDirection();\n    const hasAdapter = this.adapter && typeof this.adapter.getItemsForDirection === 'function';\n    if (!hasAdapter) {\n      // Fallback: filter existing DOM cards\n      this.domApplyFilters();\n      // Ensure direction labels/notes are correct\n      this.updateDirectionUI(currentDirection);\n      // Re-render pagination after filtering\n      this.renderCurrentPage();\n      return;\n    }\n\n    const items = this.adapter.getItemsForDirection(currentDirection) || [];\n    const filtered = this.filterItems(items);\n    this.updateFilteredResults(filtered);\n    // Re-render pagination after filtering\n    this.renderCurrentPage();\n  }\n\n  filterItems(items) {\n    const levelValue = this.filters.level?.value || '';\n    const categoryValue = this.filters.category?.value || '';\n    const searchValue = this.filters.search?.value?.toLowerCase() || '';\n    const phaseValue = this.activePhaseFilter || '';\n\n    console.log(`[VocabPage] 🔧 Filtering ${items.length} items with:`, {\n      level: levelValue || '(any)',\n      category: categoryValue || '(any)',\n      search: searchValue || '(none)',\n      phase: phaseValue || '(any)'\n    });\n\n    const filtered = items.filter(item => {\n      const levelMatch = !levelValue || item.level === levelValue;\n      const categoryMatch = !categoryValue || item.category === categoryValue;\n      const searchMatch = !searchValue ||\n                item.word.toLowerCase().includes(searchValue) ||\n                item.translation.toLowerCase().includes(searchValue) ||\n                (item.notes && item.notes.toLowerCase().includes(searchValue));\n\n      // Phase filtering: get current phase for this item\n      let phaseMatch = true;\n      if (phaseValue) {\n        const itemPhase = this.getItemPhase(item.id);\n        phaseMatch = itemPhase.toString() === phaseValue;\n      }\n\n      return levelMatch && categoryMatch && searchMatch && phaseMatch;\n    });\n\n    console.log(`[VocabPage] ✅ Filtered to ${filtered.length} items`);\n    return filtered;\n  }\n\n  updateFilteredResults(filtered) {\n    console.log(`[VocabPage] 🔍 updateFilteredResults called with ${filtered.length} items`);\n        \n    // Apply filtering to DOM cards based on filtered results\n    this.renderFilteredResults(filtered);\n\n    // Update counters\n    const showingCount = document.querySelector('#showing-count');\n    if (showingCount && Array.isArray(filtered)) {\n      showingCount.textContent = filtered.length;\n    }\n\n    // Show/hide no results message\n    this.toggleNoResultsMessage(filtered.length === 0);\n  }\n    \n  renderFilteredResults(filtered) {\n    const allCards = document.querySelectorAll('#vocabulary-grid .vocab-card');\n        \n    // Create a set of IDs from filtered results for fast lookup\n    const filteredIds = new Set(filtered.map(item => item.id));\n        \n    let visibleCount = 0;\n    for (const card of allCards) {\n      const cardId = card.dataset.id;\n      const shouldShow = filteredIds.has(cardId);\n            \n      card.style.display = shouldShow ? '' : 'none';\n      if (shouldShow) {\n        visibleCount++;\n      }\n    }\n        \n    console.log(`[VocabPage] 🎯 Rendered ${visibleCount} of ${allCards.length} cards`);\n  }\n\n  toggleNoResultsMessage(show) {\n    const noResults = document.querySelector('#no-results');\n    if (noResults) {\n      noResults.classList.toggle('hidden', !show);\n    }\n  }\n\n  showSearchIndicator() {\n    this.isSearching = true;\n    const searchContainer = this.filters.search?.parentElement;\n    if (searchContainer) {\n      searchContainer.classList.add('searching');\n            \n      if (!searchContainer.querySelector('.search-spinner')) {\n        const spinner = document.createElement('div');\n        spinner.className = 'search-spinner';\n        spinner.innerHTML = '<div class=\"spinner\"></div>';\n        searchContainer.append(spinner);\n      }\n    }\n  }\n\n  hideSearchIndicator() {\n    this.isSearching = false;\n    const searchContainer = this.filters.search?.parentElement;\n    if (searchContainer) {\n      searchContainer.classList.remove('searching');\n            \n      const spinner = searchContainer.querySelector('.search-spinner');\n      if (spinner) {\n        spinner.remove();\n      }\n    }\n  }\n\n  normalizeDirection(value) {\n    if (!value) {\n      return null;\n    }\n    const normalized = value.toString().toLowerCase();\n    if (normalized === 'bg-de' || normalized === 'bg_to_de') {\n      return 'bg-de';\n    }\n    if (normalized === 'de-bg' || normalized === 'de_to_bg') {\n      return 'de-bg';\n    }\n    return normalized === 'bg-de' || normalized === 'de-bg' ? normalized : null;\n  }\n\n  getCurrentDirection() {\n    if (window.languageToggle && typeof window.languageToggle.getDirection === 'function') {\n      return window.languageToggle.getDirection();\n    }\n\n    const stored =\n            localStorage.getItem('bgde:language-direction') ||\n            localStorage.getItem('bgde:learning_direction');\n\n    return this.normalizeDirection(stored) || 'de-bg';\n  }\n\n  handleQuickFilter(event) {\n    const button = event.currentTarget;\n    const filterType = button.dataset.filterType; // 'level', 'category', or 'phase'\n    const filterValue = button.dataset.filterValue;\n\n    // Update active state for visual feedback\n    const sameTypeButtons = document.querySelectorAll(`[data-filter-type=\"${filterType}\"]`);\n    for (const btn of sameTypeButtons) {\n      btn.classList.remove('active');\n    }\n    button.classList.add('active');\n\n    // Update corresponding select dropdown or active filter state\n    if (filterType === 'level' && this.filters.level) {\n      this.filters.level.value = filterValue;\n    } else if (filterType === 'category' && this.filters.category) {\n      this.filters.category.value = filterValue;\n    } else if (filterType === 'phase') {\n      // Phase filter doesn't have a dropdown, store value directly\n      this.activePhaseFilter = filterValue;\n    }\n\n    // Apply filters\n    this.applyFilters();\n\n    console.log(`[QuickFilter] Applied ${filterType}: ${filterValue || 'all'}`);\n  }\n\n  /**\n     * Get the current phase for a vocabulary item from localStorage\n     * @param {string} itemId - Vocabulary item ID\n     * @returns {number|string} Phase number (0-6) or 'not-started'\n     */\n  getItemPhase(itemId) {\n    if (!itemId) {\n      return 'not-started';\n    }\n\n    // Get current profile from profile manager\n    const profileId = window.profileManager?.getActiveProfileId() || 'german_learner';\n    const currentDirection = this.getCurrentDirection();\n\n    // Build storage key for this item\n    const storageKey = `bgde:${profileId}:review_${itemId}_${currentDirection}`;\n\n    try {\n      const reviewData = localStorage.getItem(storageKey);\n      if (!reviewData) {\n        return 'not-started'; // No review data = not started\n      }\n\n      const data = JSON.parse(reviewData);\n\n      // If phase is stored directly, use it\n      if (data.phase !== undefined) {\n        return data.phase;\n      }\n\n      // Otherwise calculate phase from easeFactor using PhaseCalculator\n      if (window.phaseCalculator && data.easeFactor !== undefined) {\n        const repetitions = data.repetitions || 0;\n        return window.phaseCalculator.calculatePhase(data.easeFactor, repetitions);\n      }\n\n      return 'not-started';\n    } catch (error) {\n      console.warn(`[Phase] Error getting phase for ${itemId}:`, error);\n      return 'not-started';\n    }\n  }\n\n  handlePracticeSingle(button) {\n    const word = button.dataset.word;\n    const cardElement = button.closest('.vocab-card');\n    const itemId = cardElement?.dataset.id;\n        \n    if (word || itemId) {\n      // Store single word for practice session\n      localStorage.setItem('bgde:practice_selection', JSON.stringify([word || itemId]));\n      // Navigate to practice page (relative to parent)\n      window.location.href = '../practice/';\n    } else {\n      console.warn('Cannot practice: no word or ID found');\n    }\n  }\n\n  handlePracticeSelected() {\n    const selected = [...document.querySelectorAll('.vocab-select:checked')]\n      .map(checkbox => checkbox.dataset.word);\n\n    if (selected.length > 0) {\n      localStorage.setItem('bgde:practice_selection', JSON.stringify(selected));\n      window.location.href = '../practice/';\n    } else {\n      this.showSelectionAlert();\n    }\n  }\n\n  showSelectionAlert() {\n    // Create modern alert instead of browser alert\n    const alert = document.createElement('div');\n    alert.className = 'selection-alert';\n    alert.innerHTML = `\n            <div class=\"alert-content\">\n                <p>Bitte wählen Sie mindestens ein Wortschatzelement zum Üben aus.</p>\n                <p>Моля, изберете поне един елемент от речника за упражнение.</p>\n                <button class=\"alert-close\">OK</button>\n            </div>\n        `;\n        \n    document.body.append(alert);\n        \n    // Auto-remove after 3 seconds or on click\n    setTimeout(() => alert.remove(), 3000);\n    alert.querySelector('.alert-close').addEventListener('click', () => alert.remove());\n  }\n\n  clearFilters() {\n    if (this.filters.level) {\n      this.filters.level.value = '';\n    }\n    if (this.filters.category) {\n      this.filters.category.value = '';\n    }\n    if (this.filters.search) {\n      this.filters.search.value = '';\n    }\n    this.activePhaseFilter = '';\n\n    // Clear active state from all quick filter buttons\n    for (const btn of document.querySelectorAll('.quick-filter-btn.active')) {\n      btn.classList.remove('active');\n    }\n\n    // Set \"Alle\" buttons as active for each filter type\n    for (const btn of document.querySelectorAll('.quick-filter-btn[data-filter-value=\"\"]')) {\n      btn.classList.add('active');\n    }\n\n    this.applyFilters();\n  }\n\n  performInitialRender() {\n    const currentDirection = this.getCurrentDirection();\n    this.updateDirectionUI(currentDirection);\n    this.domApplyFilters();\n    // Render the current page after initial load\n    this.renderCurrentPage();\n  }\n\n  renderInitialBatch() {\n    const initialBatch = this.allItems.slice(0, 50); // Show first 50 items\n    this.updateFilteredResults(initialBatch);\n        \n    // Schedule remaining items for next frame\n    if (this.allItems.length > 50) {\n      requestAnimationFrame(() => {\n        this.loadMoreItems();\n      });\n    }\n  }\n\n  loadMoreItems() {\n    // Implement progressive loading for better performance\n    const currentVisible = this.visibleItems.length;\n    const nextBatch = this.allItems.slice(currentVisible, currentVisible + 25);\n        \n    if (nextBatch.length > 0) {\n      this.visibleItems = [...this.visibleItems, ...nextBatch];\n      // Update display efficiently\n      this.appendItems(nextBatch);\n    }\n  }\n\n  appendItems(items) {\n    if (this.enhancedVocab && this.enhancedVocab.appendItems) {\n      this.enhancedVocab.appendItems(items);\n    }\n  }\n\n  showErrorState() {\n    const container = document.querySelector(this.container);\n    if (container) {\n      container.innerHTML = `\n                <div class=\"error-state\">\n                    <h3>⚠️ Loading Error</h3>\n                    <p>Failed to load vocabulary module. Please refresh the page.</p>\n                    <button onclick=\"location.reload()\" class=\"btn-primary\">Refresh Page</button>\n                </div>\n            `;\n    }\n  }\n\n  // Cleanup method for memory management\n  destroy() {\n    if (this.intersectionObserver) {\n      this.intersectionObserver.disconnect();\n    }\n        \n    clearTimeout(this.searchTimeout);\n        \n    // Remove event listeners\n    for (const filter of Object.values(this.filters)) {\n      if (filter) {\n        filter.removeEventListener('change', this.applyFilters);\n        filter.removeEventListener('input', this.handleSearch);\n      }\n    }\n  }\n}\n\n// Expose globally for classic script inclusion\nif (typeof window !== 'undefined') {\n  window.VocabularyPageModule = VocabularyPageModule;\n}\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/onboarding.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":375,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":375,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12966,12969],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12966,12969],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":377,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":377,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13073,13076],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13073,13076],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":667,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":667,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[23569,23572],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[23569,23572],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Onboarding System for Bulgarian-German Learning App\n * Provides first-time user experience for Vincent (DE) and Ida (BG)\n */\n\nconst ONBOARDING_STORAGE_KEY = 'bgde:onboarding-completed';\nconst ONBOARDING_VERSION = '1.0';\n\ntype Language = 'de' | 'bg';\ntype LearningGoal = 'travel' | 'work' | 'family' | 'personal';\n\ninterface Step {\n  id: string;\n  title: {\n    de: string;\n    bg: string;\n  };\n  content?: {\n    de: string;\n    bg: string;\n  };\n  options?: Array<{\n    value: string;\n    label?: string;\n    secondary?: string;\n    icon?: string;\n    bilingualLabel?: {\n      de: string;\n      bg: string;\n    };\n  }>;\n  visual?: string;\n}\n\ninterface UserData {\n  nativeLanguage: Language | null;\n  learningGoal: LearningGoal | null;\n  hasCompleted: boolean;\n}\n\ninterface OnboardingStorage {\n  version: string;\n  completed: boolean;\n  nativeLanguage: Language | null;\n  learningGoal: LearningGoal | null;\n  completedAt: string;\n}\n\nclass OnboardingFlow {\n  private currentStep = 0;\n  private userData: UserData = {\n    nativeLanguage: null,\n    learningGoal: null,\n    hasCompleted: false\n  };\n  \n  private steps: Step[] = [\n    {\n      id: 'welcome',\n      title: {\n        de: 'Willkommen!',\n        bg: 'Добре дошли!'\n      },\n      content: {\n        de: 'Lernen Sie Bulgarisch mit intelligentem Wiederholungssystem',\n        bg: 'Научете немски с интелигентна система за повторение'\n      }\n    },\n    {\n      id: 'language-selection',\n      title: {\n        de: 'Welche Sprache sprechen Sie?',\n        bg: 'Кой език говорите?'\n      },\n      options: [\n        { value: 'de', label: '🇩🇪 Deutsch', secondary: 'German' },\n        { value: 'bg', label: '🇧🇬 Български', secondary: 'Bulgarian' }\n      ]\n    },\n    {\n      id: 'learning-goal',\n      title: {\n        de: 'Warum lernen Sie?',\n        bg: 'Защо учите?'\n      },\n      options: [\n        { value: 'travel', icon: '✈️', bilingualLabel: { de: 'Reisen', bg: 'Пътуване' } },\n        { value: 'work', icon: '💼', bilingualLabel: { de: 'Arbeit', bg: 'Работа' } },\n        { value: 'family', icon: '👨‍👩‍👧', bilingualLabel: { de: 'Familie', bg: 'Семейство' } },\n        { value: 'personal', icon: '📚', bilingualLabel: { de: 'Persönliches Interesse', bg: 'Личен интерес' } }\n      ]\n    },\n    {\n      id: 'tutorial-flashcards',\n      title: {\n        de: 'Wie Lernkarten funktionieren',\n        bg: 'Как работят флашкартите'\n      },\n      content: {\n        de: 'Sie sehen ein Wort und versuchen, die Übersetzung zu erraten. Klicken Sie dann, um die Antwort zu sehen.',\n        bg: 'Виждате дума и се опитвате да познаете превода. След това кликнете, за да видите отговора.'\n      },\n      visual: 'flashcard-demo'\n    },\n    {\n      id: 'tutorial-grading',\n      title: {\n        de: 'Bewerten Sie Ihr Wissen',\n        bg: 'Оценете знанията си'\n      },\n      content: {\n        de: 'Nach dem Anzeigen der Antwort bewerten Sie, wie gut Sie sie kannten. Das System passt sich Ihrem Lerntempo an.',\n        bg: 'След показване на отговора оценете колко добре го познавахте. Системата се адаптира към вашето темпо на обучение.'\n      },\n      visual: 'grading-demo'\n    },\n    {\n      id: 'tutorial-spaced-repetition',\n      title: {\n        de: 'Intelligente Wiederholung',\n        bg: 'Интелигентно повторение'\n      },\n      content: {\n        de: 'Wörter, die Sie gut kennen, werden seltener wiederholt. Schwierige Wörter erscheinen häufiger.',\n        bg: 'Думи, които познавате добре, се повтарят по-рядко. Трудни думи се появяват по-често.'\n      },\n      visual: 'spaced-repetition-demo'\n    },\n    {\n      id: 'ready',\n      title: {\n        de: 'Bereit loszulegen!',\n        bg: 'Готови да започнете!'\n      },\n      content: {\n        de: 'Starten Sie Ihre erste Übungssitzung mit 5 Wörtern.',\n        bg: 'Започнете вашата първа сесия с 5 думи.'\n      }\n    }\n  ];\n  \n  constructor() {\n    this.init();\n  }\n  \n  init(): void {\n    // DON'T auto-show onboarding - let user trigger it manually\n    // Check if help button exists and attach click handler\n    this.attachHelpButtonHandler();\n    \n    console.log('[Onboarding] Onboarding ready (manual trigger only)');\n  }\n  \n  private attachHelpButtonHandler(): void {\n    // Wait for DOM to be fully loaded\n    const helpButton = document.querySelector('#onboarding-help-btn');\n    if (helpButton) {\n      helpButton.addEventListener('click', () => {\n        console.log('[Onboarding] Starting onboarding flow (user triggered)');\n        this.showOnboarding();\n      });\n    }\n  }\n  \n  // Public method to manually trigger onboarding\n  startOnboarding(): void {\n    console.log('[Onboarding] Starting onboarding flow (programmatic)');\n    this.showOnboarding();\n  }\n  \n  hasCompletedOnboarding(): boolean {\n    try {\n      const stored = localStorage.getItem(ONBOARDING_STORAGE_KEY);\n      if (stored) {\n        const data: OnboardingStorage = JSON.parse(stored);\n        return data.version === ONBOARDING_VERSION && data.completed === true;\n      }\n    } catch (error) {\n      console.warn('[Onboarding] Error checking completion status:', error);\n    }\n    return false;\n  }\n  \n  shouldShowOnboarding(): boolean {\n    // Show on homepage or practice page for new users\n    const path = window.location.pathname;\n    const isHomepage = path === '/' || path.includes('/index.html');\n    const isPracticePage = path.includes('/practice/');\n    \n    return isHomepage || isPracticePage;\n  }\n  \n  private showOnboarding(): void {\n    this.createModal();\n    this.renderStep();\n  }\n  \n  private createModal(): void {\n    // Create modal overlay\n    const overlay = document.createElement('div');\n    overlay.id = 'onboarding-overlay';\n    overlay.className = 'onboarding-overlay';\n    overlay.setAttribute('role', 'dialog');\n    overlay.setAttribute('aria-modal', 'true');\n    overlay.setAttribute('aria-labelledby', 'onboarding-title');\n    \n    const modal = document.createElement('div');\n    modal.className = 'onboarding-modal';\n    modal.innerHTML = `\n      <div class=\"onboarding-header\">\n        <h2 id=\"onboarding-title\" class=\"onboarding-title\"></h2>\n        <button class=\"onboarding-skip\" aria-label=\"Skip onboarding\">\n          <span aria-hidden=\"true\">×</span>\n          <span class=\"sr-only\">Skip / Пропусни</span>\n        </button>\n      </div>\n      <div class=\"onboarding-content\" id=\"onboarding-content\"></div>\n      <div class=\"onboarding-footer\">\n        <div class=\"onboarding-progress\" role=\"progressbar\" aria-valuemin=\"0\" aria-valuemax=\"${this.steps.length}\" aria-valuenow=\"1\">\n          <div class=\"onboarding-progress-bar\" id=\"onboarding-progress-bar\"></div>\n          <span class=\"onboarding-progress-text\" id=\"onboarding-progress-text\">1 / ${this.steps.length}</span>\n        </div>\n        <div class=\"onboarding-actions\">\n          <button class=\"onboarding-back btn-secondary\" id=\"onboarding-back\" style=\"display: none;\">\n            <span class=\"btn-text\">← Zurück / Назад</span>\n          </button>\n          <button class=\"onboarding-next btn-primary\" id=\"onboarding-next\">\n            <span class=\"btn-text\">Weiter / Напред →</span>\n          </button>\n        </div>\n      </div>\n    `;\n    \n    overlay.append(modal);\n    document.body.append(overlay);\n    \n    // Bind events\n    overlay.querySelector('.onboarding-skip')?.addEventListener('click', () => this.skipOnboarding());\n    overlay.querySelector('#onboarding-back')?.addEventListener('click', () => this.previousStep());\n    overlay.querySelector('#onboarding-next')?.addEventListener('click', () => this.nextStep());\n    \n    // Prevent background scrolling\n    document.body.style.overflow = 'hidden';\n    \n    // Announce to screen readers\n    this.announceToScreenReader('Onboarding started. Welcome screen.');\n  }\n  \n  private renderStep(): void {\n    const step = this.steps[this.currentStep];\n    const title = document.querySelector('#onboarding-title');\n    const content = document.querySelector('#onboarding-content');\n    const backBtn = document.querySelector('#onboarding-back');\n    const nextBtn = document.querySelector('#onboarding-next');\n    const progressBar = document.querySelector('#onboarding-progress-bar');\n    const progressText = document.querySelector('#onboarding-progress-text');\n    \n    // Update progress\n    const progress = ((this.currentStep + 1) / this.steps.length) * 100;\n    (progressBar as HTMLElement).style.width = `${progress}%`;\n    progressText!.textContent = `${this.currentStep + 1} / ${this.steps.length}`;\n    \n    // Update back button visibility\n    (backBtn as HTMLElement).style.display = this.currentStep > 0 ? 'block' : 'none';\n    \n    // Update next button text for last step\n    if (this.currentStep === this.steps.length - 1) {\n      nextBtn!.querySelector('.btn-text')!.textContent = 'Los geht\\'s! / Да започнем!';\n      nextBtn!.classList.add('btn-success');\n    } else {\n      nextBtn!.querySelector('.btn-text')!.textContent = 'Weiter / Напред →';\n      nextBtn!.classList.remove('btn-success');\n    }\n    \n    // Render step content based on type\n    if (!step) return;\n    switch (step.id) {\n    case 'welcome': {\n      if (step) this.renderWelcomeStep(title!, content!, step);\n      break;\n    }\n    case 'language-selection': {\n      if (step) this.renderLanguageSelectionStep(title!, content!, step);\n      break;\n    }\n    case 'learning-goal': {\n      if (step) this.renderLearningGoalStep(title!, content!, step);\n      break;\n    }\n    case 'tutorial-flashcards':\n    case 'tutorial-grading':\n    case 'tutorial-spaced-repetition': {\n      if (step) this.renderTutorialStep(title!, content!, step);\n      break;\n    }\n    case 'ready': {\n      if (step) this.renderReadyStep(title!, content!, step);\n      break;\n    }\n    }\n    \n    // Announce step to screen readers\n    const lang = this.userData.nativeLanguage || 'de';\n    if (step) this.announceToScreenReader(`Step ${this.currentStep + 1} of ${this.steps.length}: ${step.title[lang as Language]}`);\n  }\n  \n  private renderWelcomeStep(title: Element, content: Element, step: Step): void {\n    title.innerHTML = `\n      <span lang=\"de\">${step.title.de}</span> / \n      <span lang=\"bg\">${step.title.bg}</span>\n    `;\n    \n    content.innerHTML = `\n      <div class=\"onboarding-welcome\">\n        <div class=\"welcome-icon\">🎓</div>\n        <p lang=\"de\" class=\"welcome-text\">${step.content?.de}</p>\n        <p lang=\"bg\" class=\"welcome-text\">${step.content?.bg}</p>\n        <div class=\"welcome-features\">\n          <div class=\"feature-item\">\n            <span class=\"feature-icon\">🧠</span>\n            <span lang=\"de\">Intelligentes Lernen</span> / <span lang=\"bg\">Интелигентно обучение</span>\n          </div>\n          <div class=\"feature-item\">\n            <span class=\"feature-icon\">↔️</span>\n            <span lang=\"de\">Beide Richtungen</span> / <span lang=\"bg\">В двете посоки</span>\n          </div>\n          <div class=\"feature-item\">\n            <span class=\"feature-icon\">📱</span>\n            <span lang=\"de\">Überall lernen</span> / <span lang=\"bg\">Учете навсякъде</span>\n          </div>\n        </div>\n      </div>\n    `;\n  }\n  \n  private renderLanguageSelectionStep(title: Element, content: Element, step: Step): void {\n    const bilingual = !this.userData.nativeLanguage;\n    \n    title.innerHTML = bilingual \n      ? `<span lang=\"de\">${step.title.de}</span> / <span lang=\"bg\">${step.title.bg}</span>`\n      : `<span lang=\"${this.userData.nativeLanguage}\">${step.title[this.userData.nativeLanguage as Language]}</span>`;\n    \n    content.innerHTML = `\n      <div class=\"onboarding-language-selection\">\n        ${step.options?.map(option => `\n          <button class=\"language-option ${this.userData.nativeLanguage === option.value ? 'selected' : ''}\" \n                  data-language=\"${option.value}\"\n                  aria-pressed=\"${this.userData.nativeLanguage === option.value}\">\n            <span class=\"option-label\">${option.label}</span>\n            <span class=\"option-secondary\">${option.secondary}</span>\n            ${this.userData.nativeLanguage === option.value ? '<span class=\"option-check\">✓</span>' : ''}\n          </button>\n        `).join('') || ''}\n      </div>\n    `;\n    \n    // Bind selection events\n    for (const btn of content.querySelectorAll('.language-option')) {\n      btn.addEventListener('click', (e) => {\n        const target = e.currentTarget as HTMLElement;\n        const lang = target.dataset.language as Language;\n        this.userData.nativeLanguage = lang;\n        \n        // Update UI\n        for (const b of content.querySelectorAll('.language-option')) {\n          b.classList.remove('selected');\n          b.setAttribute('aria-pressed', 'false');\n          b.querySelector('.option-check')?.remove();\n        }\n        target.classList.add('selected');\n        target.setAttribute('aria-pressed', 'true');\n        target.innerHTML += '<span class=\"option-check\">✓</span>';\n        \n        // Set language direction in language toggle\n        if ((window as any).languageToggle) {\n          const direction = lang === 'de' ? 'de-bg' : 'bg-de';\n          (window as any).languageToggle.setDirection(direction);\n        }\n        \n        this.announceToScreenReader(`Selected ${lang === 'de' ? 'German' : 'Bulgarian'}`);\n      });\n    }\n  }\n  \n  private renderLearningGoalStep(title: Element, content: Element, step: Step): void {\n    const lang = this.userData.nativeLanguage || 'de';\n    title.textContent = step.title[lang as Language];\n    \n    content.innerHTML = `\n      <div class=\"onboarding-learning-goal\">\n        ${step.options?.map(option => `\n          <button class=\"goal-option ${this.userData.learningGoal === option.value ? 'selected' : ''}\" \n                  data-goal=\"${option.value}\"\n                  aria-pressed=\"${this.userData.learningGoal === option.value}\">\n            <span class=\"goal-icon\" aria-hidden=\"true\">${option.icon}</span>\n            <span class=\"goal-label\">${option.bilingualLabel?.[lang as Language] || option.label}</span>\n            ${this.userData.learningGoal === option.value ? '<span class=\"option-check\">✓</span>' : ''}\n          </button>\n        `).join('') || ''}\n      </div>\n    `;\n    \n    // Bind selection events\n    for (const btn of content.querySelectorAll('.goal-option')) {\n      btn.addEventListener('click', (e) => {\n        const target = e.currentTarget as HTMLElement;\n        const goal = target.dataset.goal as LearningGoal;\n        this.userData.learningGoal = goal;\n        \n        // Update UI\n        for (const b of content.querySelectorAll('.goal-option')) {\n          b.classList.remove('selected');\n          b.setAttribute('aria-pressed', 'false');\n          b.querySelector('.option-check')?.remove();\n        }\n        target.classList.add('selected');\n        target.setAttribute('aria-pressed', 'true');\n        target.innerHTML += '<span class=\"option-check\">✓</span>';\n        \n        this.announceToScreenReader(`Selected ${goal}`);\n      });\n    }\n  }\n  \n  private renderTutorialStep(title: Element, content: Element, step: Step): void {\n    const lang = this.userData.nativeLanguage || 'de';\n    title.textContent = step.title[lang as Language];\n    \n    let visualContent = '';\n    switch (step.visual) {\n    case 'flashcard-demo': {\n      visualContent = `\n        <div class=\"tutorial-visual flashcard-demo\">\n          <div class=\"demo-flashcard\">\n            <div class=\"demo-card-front\">\n              <span class=\"demo-word\">${lang === 'de' ? 'Здравей' : 'Hallo'}</span>\n              <span class=\"demo-level\">A1</span>\n            </div>\n            <div class=\"demo-card-back\" style=\"display: none;\">\n              <span class=\"demo-translation\">${lang === 'de' ? 'Hallo' : 'Здравей'}</span>\n            </div>\n          </div>\n          <button class=\"demo-flip-btn\">\n            ${lang === 'de' ? 'Antwort zeigen' : 'Покажи отговора'}\n          </button>\n        </div>\n      `;\n    \n      break;\n    }\n    case 'grading-demo': {\n      visualContent = `\n        <div class=\"tutorial-visual grading-demo\">\n          <div class=\"demo-grade-buttons\">\n            <button class=\"demo-grade demo-grade-wrong\">\n              <span class=\"grade-emoji\">❌</span>\n              <span class=\"grade-label\">${lang === 'de' ? 'Falsch' : 'Грешно'}</span>\n            </button>\n            <button class=\"demo-grade demo-grade-hard\">\n              <span class=\"grade-emoji\">🤔</span>\n              <span class=\"grade-label\">${lang === 'de' ? 'Schwer' : 'Трудно'}</span>\n            </button>\n            <button class=\"demo-grade demo-grade-good\">\n              <span class=\"grade-emoji\">👍</span>\n              <span class=\"grade-label\">${lang === 'de' ? 'Gut' : 'Добре'}</span>\n            </button>\n            <button class=\"demo-grade demo-grade-easy\">\n              <span class=\"grade-emoji\">😊</span>\n              <span class=\"grade-label\">${lang === 'de' ? 'Leicht' : 'Лесно'}</span>\n            </button>\n          </div>\n        </div>\n      `;\n    \n      break;\n    }\n    case 'spaced-repetition-demo': {\n      visualContent = `\n        <div class=\"tutorial-visual spaced-repetition-demo\">\n          <div class=\"demo-timeline\">\n            <div class=\"demo-timeline-item\">\n              <div class=\"demo-timeline-dot demo-dot-today\"></div>\n              <span class=\"demo-timeline-label\">${lang === 'de' ? 'Heute' : 'Днес'}</span>\n            </div>\n            <div class=\"demo-timeline-item\">\n              <div class=\"demo-timeline-dot demo-dot-tomorrow\"></div>\n              <span class=\"demo-timeline-label\">${lang === 'de' ? 'Morgen' : 'Утре'}</span>\n            </div>\n            <div class=\"demo-timeline-item\">\n              <div class=\"demo-timeline-dot demo-dot-week\"></div>\n              <span class=\"demo-timeline-label\">${lang === 'de' ? '1 Woche' : '1 седмица'}</span>\n            </div>\n            <div class=\"demo-timeline-item\">\n              <div class=\"demo-timeline-dot demo-dot-month\"></div>\n              <span class=\"demo-timeline-label\">${lang === 'de' ? '1 Monat' : '1 месец'}</span>\n            </div>\n          </div>\n        </div>\n      `;\n    \n      break;\n    }\n    // No default\n    }\n    \n    content.innerHTML = `\n      <div class=\"onboarding-tutorial\">\n        <p class=\"tutorial-text\">${step.content?.[lang as Language]}</p>\n        ${visualContent}\n      </div>\n    `;\n    \n    // Add interactivity to flashcard demo\n    if (step.visual === 'flashcard-demo') {\n      const flipBtn = content.querySelector('.demo-flip-btn');\n      const cardFront = content.querySelector('.demo-card-front');\n      const cardBack = content.querySelector('.demo-card-back');\n      \n      if (flipBtn) {\n        flipBtn.addEventListener('click', () => {\n          if ((cardFront as HTMLElement).style.display === 'none') {\n            (cardFront as HTMLElement).style.display = 'block';\n            (cardBack as HTMLElement).style.display = 'none';\n            flipBtn.textContent = lang === 'de' ? 'Antwort zeigen' : 'Покажи отговора';\n          } else {\n            (cardFront as HTMLElement).style.display = 'none';\n            (cardBack as HTMLElement).style.display = 'block';\n            flipBtn.textContent = lang === 'de' ? 'Zurück' : 'Назад';\n          }\n        });\n      }\n    }\n  }\n  \n  private renderReadyStep(title: Element, content: Element, step: Step): void {\n    const lang = this.userData.nativeLanguage || 'de';\n    title.textContent = step.title[lang as Language];\n    \n    const learningFrom = lang === 'de' ? 'Deutsch' : 'Български';\n    const learningTo = lang === 'de' ? 'Bulgarisch' : 'Немски';\n    \n    content.innerHTML = `\n      <div class=\"onboarding-ready\">\n        <div class=\"ready-icon\">🎉</div>\n        <p class=\"ready-text\">${step.content?.[lang as Language]}</p>\n        <div class=\"ready-summary\">\n          <div class=\"summary-item\">\n            <span class=\"summary-label\">${lang === 'de' ? 'Sie sprechen' : 'Вие говорите'}:</span>\n            <span class=\"summary-value\">${learningFrom}</span>\n          </div>\n          <div class=\"summary-item\">\n            <span class=\"summary-label\">${lang === 'de' ? 'Sie lernen' : 'Вие учите'}:</span>\n            <span class=\"summary-value\">${learningTo}</span>\n          </div>\n          ${this.userData.learningGoal ? `\n          <div class=\"summary-item\">\n            <span class=\"summary-label\">${lang === 'de' ? 'Ihr Ziel' : 'Вашата цел'}:</span>\n            <span class=\"summary-value\">${this.getGoalLabel(this.userData.learningGoal, lang as Language)}</span>\n          </div>\n          ` : ''}\n        </div>\n      </div>\n    `;\n  }\n  \n  private getGoalLabel(goal: LearningGoal, lang: Language): string {\n    const labels = {\n      travel: { de: 'Reisen', bg: 'Пътуване' },\n      work: { de: 'Arbeit', bg: 'Работа' },\n      family: { de: 'Familie', bg: 'Семейство' },\n      personal: { de: 'Persönliches Interesse', bg: 'Личен интерес' }\n    };\n    return labels[goal]?.[lang] || goal;\n  }\n  \n  private nextStep(): void {\n    // Validation\n    const currentStep = this.steps[this.currentStep];\n    if (currentStep && currentStep.id === 'language-selection' && !this.userData.nativeLanguage) {\n      this.announceToScreenReader('Please select a language / Моля изберете език');\n      return;\n    }\n    \n    if (this.currentStep < this.steps.length - 1) {\n      this.currentStep++;\n      this.renderStep();\n    } else {\n      this.completeOnboarding();\n    }\n  }\n  \n  private previousStep(): void {\n    if (this.currentStep > 0) {\n      this.currentStep--;\n      this.renderStep();\n    }\n  }\n  \n  private skipOnboarding(): void {\n    const lang = this.userData.nativeLanguage || 'de';\n    const confirmMessage = lang === 'de' \n      ? 'Möchten Sie die Einführung überspringen?' \n      : 'Искате ли да пропуснете въведението?';\n    \n    if (confirm(confirmMessage)) {\n      this.closeOnboarding(false);\n    }\n  }\n  \n  private completeOnboarding(): void {\n    this.userData.hasCompleted = true;\n    \n    // Save to localStorage\n    try {\n      localStorage.setItem(ONBOARDING_STORAGE_KEY, JSON.stringify({\n        version: ONBOARDING_VERSION,\n        completed: true,\n        nativeLanguage: this.userData.nativeLanguage,\n        learningGoal: this.userData.learningGoal,\n        completedAt: new Date().toISOString()\n      }));\n    } catch (error) {\n      console.warn('[Onboarding] Error saving completion status:', error);\n    }\n    \n    this.closeOnboarding(true);\n    \n    // Redirect to practice page if not already there\n    if (window.location.pathname.includes('/practice/')) {\n      // Reload to start practice session\n      window.location.reload();\n    } else {\n      window.location.href = '/BulgarianGermanLearningApp/practice/';\n    }\n  }\n  \n  private closeOnboarding(completed = false): void {\n    const overlay = document.querySelector('#onboarding-overlay');\n    if (overlay) {\n      overlay.remove();\n    }\n    \n    // Restore body scrolling\n    document.body.style.overflow = '';\n    \n    if (completed) {\n      this.announceToScreenReader('Onboarding completed. Starting practice session.');\n    } else {\n      this.announceToScreenReader('Onboarding skipped.');\n    }\n  }\n  \n  private announceToScreenReader(message: string): void {\n    const announcer = document.querySelector('#sr-announcements');\n    if (announcer) {\n      announcer.textContent = message;\n      setTimeout(() => {\n        announcer.textContent = '';\n      }, 3000);\n    }\n  }\n}\n\n// Initialize onboarding when DOM is ready\nif (typeof window !== 'undefined' && typeof document !== 'undefined') {\n  document.addEventListener('DOMContentLoaded', () => {\n    (window as any).onboardingFlow = new OnboardingFlow();\n  });\n  \n  console.log('[Onboarding] Module loaded');\n}\n\nexport default OnboardingFlow;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/performance-monitor.ts","messages":[{"ruleId":"unicorn/no-array-push-push","severity":2,"message":"Do not call `Array#push()` multiple times.","line":292,"column":15,"nodeType":"Identifier","messageId":"error","endLine":292,"endColumn":19,"suggestions":[{"messageId":"suggestion","fix":{"range":[7666,7735],"text":", `    Avg: ${metric.avgDuration.toFixed(2)}ms`);"},"data":{},"desc":"Merge with previous one."}]},{"ruleId":"unicorn/no-array-push-push","severity":2,"message":"Do not call `Array#push()` multiple times.","line":293,"column":15,"nodeType":"Identifier","messageId":"error","endLine":293,"endColumn":19,"suggestions":[{"messageId":"suggestion","fix":{"range":[7733,7802],"text":", `    Min: ${metric.minDuration.toFixed(2)}ms`);"},"data":{},"desc":"Merge with previous one."}]},{"ruleId":"unicorn/no-array-push-push","severity":2,"message":"Do not call `Array#push()` multiple times.","line":294,"column":15,"nodeType":"Identifier","messageId":"error","endLine":294,"endColumn":19,"suggestions":[{"messageId":"suggestion","fix":{"range":[7800,7869],"text":", `    Max: ${metric.maxDuration.toFixed(2)}ms`);"},"data":{},"desc":"Merge with previous one."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":327,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":327,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8492,8495],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8492,8495],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":330,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":330,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8593,8596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8593,8596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Performance Monitor for Bulgarian-German Learning App\n *\n * Tracks and reports performance metrics for optimization\n */\n\ninterface PageLoadMetrics {\n  dns: number;\n  tcp: number;\n  request: number;\n  response: number;\n  dom: number;\n  load: number;\n  total: number;\n}\n\ninterface StorageItemMetrics {\n  size: number;\n  sizeKB: string;\n}\n\ninterface StorageMetrics {\n  totalSize: number;\n  totalKB: string;\n  totalMB: string;\n  items: Record<string, StorageItemMetrics>;\n  itemCount: number;\n}\n\ninterface FunctionMetrics {\n  count: number;\n  totalDuration: number;\n  minDuration: number;\n  maxDuration: number;\n  avgDuration: number;\n}\n\ninterface MemoryMetrics {\n  usedMB: string;\n  limitMB: string;\n}\n\ninterface PerformanceMetrics {\n  pageLoad?: PageLoadMetrics;\n  storage?: StorageMetrics;\n  memory?: MemoryMetrics;\n  functions?: Record<string, FunctionMetrics>;\n}\n\nclass PerformanceMonitor {\n  private metrics: PerformanceMetrics = {};\n  private isProduction: boolean;\n\n  constructor() {\n    this.isProduction = !window.location.hostname.includes('localhost');\n    this.init();\n  }\n\n  /**\n   * Initialize performance monitoring\n   */\n  init(): void {\n    // Track page load performance\n    if (window.performance && performance.timing) {\n      window.addEventListener('load', () => {\n        this.trackPageLoad();\n      });\n    }\n\n    // Track localStorage usage\n    this.trackStorageUsage();\n\n    // Setup periodic checks\n    if (!this.isProduction) {\n      setInterval(() => this.checkPerformance(), 30_000); // Every 30 seconds in dev\n    }\n  }\n\n  /**\n   * Track page load metrics\n   */\n  trackPageLoad(): void {\n    const timing = performance.timing;\n    const metrics: PageLoadMetrics = {\n      dns: timing.domainLookupEnd - timing.domainLookupStart,\n      tcp: timing.connectEnd - timing.connectStart,\n      request: timing.responseStart - timing.requestStart,\n      response: timing.responseEnd - timing.responseStart,\n      dom: timing.domContentLoadedEventEnd - timing.domContentLoadedEventStart,\n      load: timing.loadEventEnd - timing.loadEventStart,\n      total: timing.loadEventEnd - timing.navigationStart\n    };\n\n    this.metrics.pageLoad = metrics;\n\n    if (!this.isProduction) {\n      console.log('[PerformanceMonitor] Page Load Metrics:', metrics);\n    }\n\n    // Store in localStorage\n    try {\n      localStorage.setItem('bgde:performance:pageLoad', JSON.stringify(metrics));\n    } catch (error) {\n      console.warn('Could not store performance metrics:', error);\n    }\n  }\n\n  /**\n   * Track localStorage usage\n   */\n  trackStorageUsage(): void {\n    try {\n      let totalSize = 0;\n      const items: Record<string, StorageItemMetrics> = {};\n\n      for (const key in localStorage) {\n        if (key.startsWith('bgde:')) {\n          const value = localStorage.getItem(key);\n          if (value) {\n            const size = new Blob([value]).size;\n            totalSize += size;\n            items[key] = {\n              size,\n              sizeKB: (size / 1024).toFixed(2)\n            };\n          }\n        }\n      }\n\n      this.metrics.storage = {\n        totalSize,\n        totalKB: (totalSize / 1024).toFixed(2),\n        totalMB: (totalSize / 1024 / 1024).toFixed(2),\n        items,\n        itemCount: Object.keys(items).length\n      };\n\n      if (!this.isProduction) {\n        console.log('[PerformanceMonitor] Storage Usage:', this.metrics.storage);\n      }\n\n      // Warn if storage is getting full (> 4MB)\n      if (totalSize > 4 * 1024 * 1024) {\n        console.warn('[PerformanceMonitor] Storage usage high:', this.metrics.storage.totalMB, 'MB');\n      }\n    } catch (error) {\n      console.warn('Could not track storage usage:', error);\n    }\n  }\n\n  /**\n   * Measure function execution time\n   * @param name - Metric name\n   * @param fn - Function to measure\n   * @returns Function result\n   */\n  async measure<T>(name: string, fn: () => Promise<T>): Promise<T> {\n    const startTime = performance.now();\n\n    try {\n      const result = await fn();\n      const duration = performance.now() - startTime;\n\n      if (!this.metrics.functions) {\n        this.metrics.functions = {};\n      }\n\n      if (!this.metrics.functions[name]) {\n        this.metrics.functions[name] = {\n          count: 0,\n          totalDuration: 0,\n          minDuration: Number.POSITIVE_INFINITY,\n          maxDuration: 0,\n          avgDuration: 0\n        };\n      }\n\n      const metric = this.metrics.functions[name];\n      metric.count++;\n      metric.totalDuration += duration;\n      metric.minDuration = Math.min(metric.minDuration, duration);\n      metric.maxDuration = Math.max(metric.maxDuration, duration);\n      metric.avgDuration = metric.totalDuration / metric.count;\n\n      if (!this.isProduction) {\n        console.log(`[PerformanceMonitor] ${name}: ${duration.toFixed(2)}ms`);\n      }\n\n      return result;\n    } catch (error) {\n      console.error(`[PerformanceMonitor] Error in ${name}:`, error);\n      throw error;\n    }\n  }\n\n  /**\n   * Mark a custom timing point\n   * @param name - Mark name\n   */\n  mark(name: string): void {\n    if (performance.mark) {\n      performance.mark(name);\n    }\n  }\n\n  /**\n   * Measure between two marks\n   * @param measureName - Measure name\n   * @param startMark - Start mark name\n   * @param endMark - End mark name\n   * @returns Duration in ms\n   */\n  measureBetween(measureName: string, startMark: string, endMark: string): number {\n    try {\n      performance.measure(measureName, startMark, endMark);\n      const measure = performance.getEntriesByName(measureName)[0];\n\n      if (measure && !this.isProduction) {\n        console.log(`[PerformanceMonitor] ${measureName}: ${measure.duration.toFixed(2)}ms`);\n      }\n\n      return measure ? measure.duration : 0;\n    } catch (error) {\n      console.warn(`Could not measure ${measureName}:`, error);\n      return 0;\n    }\n  }\n\n  /**\n   * Check current performance\n   */\n  checkPerformance(): string[] {\n    const warnings: string[] = [];\n\n    // Check memory (if available)\n    if (performance.memory) {\n      const memoryMB = performance.memory.usedJSHeapSize / 1024 / 1024;\n      this.metrics.memory = {\n        usedMB: memoryMB.toFixed(2),\n        limitMB: (performance.memory.jsHeapSizeLimit / 1024 / 1024).toFixed(2)\n      };\n\n      if (memoryMB > 50) { // More than 50MB\n        warnings.push(`High memory usage: ${memoryMB.toFixed(2)}MB`);\n      }\n    }\n\n    // Check localStorage usage\n    this.trackStorageUsage();\n\n    // Report warnings\n    if (warnings.length > 0 && !this.isProduction) {\n      console.warn('[PerformanceMonitor] Performance Warnings:', warnings);\n    }\n\n    return warnings;\n  }\n\n  /**\n   * Get all metrics\n   * @returns All collected metrics\n   */\n  getMetrics(): PerformanceMetrics {\n    this.checkPerformance();\n    return this.metrics;\n  }\n\n  /**\n   * Get performance summary\n   * @returns Human-readable summary\n   */\n  getSummary(): string {\n    const metrics = this.getMetrics();\n    const lines: string[] = ['=== Performance Summary ==='];\n\n    if (metrics.pageLoad) {\n      lines.push('\\nPage Load:', `  Total: ${metrics.pageLoad.total}ms`, `  DOM: ${metrics.pageLoad.dom}ms`, `  Load: ${metrics.pageLoad.load}ms`);\n    }\n\n    if (metrics.storage) {\n      lines.push('\\nStorage:', `  Total: ${metrics.storage.totalKB} KB`, `  Items: ${metrics.storage.itemCount}`);\n    }\n\n    if (metrics.memory) {\n      lines.push('\\nMemory:', `  Used: ${metrics.memory.usedMB} MB`, `  Limit: ${metrics.memory.limitMB} MB`);\n    }\n\n    if (metrics.functions) {\n      lines.push('\\nFunction Timings:');\n      for (const [name, metric] of Object.entries(metrics.functions)) {\n        lines.push(`  ${name}:`, `    Calls: ${metric.count}`);\n        lines.push(`    Avg: ${metric.avgDuration.toFixed(2)}ms`);\n        lines.push(`    Min: ${metric.minDuration.toFixed(2)}ms`);\n        lines.push(`    Max: ${metric.maxDuration.toFixed(2)}ms`);\n      }\n    }\n\n    return lines.join('\\n');\n  }\n\n  /**\n   * Export metrics for analysis\n   * @returns JSON string of metrics\n   */\n  export(): string {\n    return JSON.stringify({\n      metrics: this.getMetrics(),\n      timestamp: new Date().toISOString(),\n      userAgent: navigator.userAgent,\n      url: window.location.href\n    }, null, 2);\n  }\n\n  /**\n   * Clear all metrics\n   */\n  clear(): void {\n    this.metrics = {};\n    localStorage.removeItem('bgde:performance:pageLoad');\n  }\n}\n\n// Create global instance\nconst performanceMonitor = new PerformanceMonitor();\n\n// Make available globally for debugging\n(window as any).bgdePerformanceMonitor = performanceMonitor;\n\n// Log initialization\nif (!(performanceMonitor as any).isProduction) {\n  console.log('[PerformanceMonitor] Initialized. Access via window.bgdePerformanceMonitor');\n  console.log('[PerformanceMonitor] Commands: .getMetrics(), .getSummary(), .export()');\n}\n\nexport default performanceMonitor;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/profile-system.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[688,691],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[688,691],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":49,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":49,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[996,999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[996,999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1024,1027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1024,1027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Profile System\n * Complete dual-profile system with UI for Bulgarian-German Learning App\n * Combines ProfileManager and ProfileSwitcherUI into a single file for Hugo compatibility\n */\n\ninterface ProfileStatistics {\n  totalReviews: number;\n  totalCorrect: number;\n  totalTime: number;\n  streak: number;\n}\n\ninterface ProfileSettings {\n  dailyGoal: number;\n  autoPlayAudio: boolean;\n  voiceGender: string;\n}\n\ninterface Profile {\n  id: string;\n  name: string;\n  displayName: string;\n  direction: string;\n  sourceLanguage: string;\n  targetLanguage: string;\n  createdAt: string;\n  lastAccessedAt: string;\n  statistics: ProfileStatistics;\n  settings: ProfileSettings;\n  customVocabulary: any[];\n  customTags: string[];\n  customCategories: string[];\n}\n\ninterface ProfileSwitchDetail {\n  profileId: string;\n  profile: Profile;\n  previousProfileId: string;\n}\n\ninterface ProfileIds {\n  GERMAN_LEARNER: string;\n  BULGARIAN_LEARNER: string;\n}\n\ndeclare global {\n  interface Window {\n    profileManager: any;\n    profileSwitcherUI: any;\n  }\n}\n\n// ProfileManager Class\nclass ProfileManager {\n  private PROFILES_KEY = 'bgde:profiles';\n  private ACTIVE_PROFILE_KEY = 'bgde:active_profile';\n  public PROFILE_IDS: ProfileIds = {\n    GERMAN_LEARNER: 'german_learner',\n    BULGARIAN_LEARNER: 'bulgarian_learner'\n  };\n\n  constructor() {\n    this.initializeProfiles();\n  }\n\n  /**\n   * Initialize profile system\n   */\n  private initializeProfiles(): void {\n    const existing = localStorage.getItem(this.PROFILES_KEY);\n\n    if (!existing) {\n      console.log('[ProfileManager] No profiles found, initializing...');\n      this.createDefaultProfiles();\n      this.migrateLegacyData();\n    }\n\n    // Ensure active profile is set\n    const activeProfile = localStorage.getItem(this.ACTIVE_PROFILE_KEY);\n    if (!activeProfile) {\n      localStorage.setItem(this.ACTIVE_PROFILE_KEY, this.PROFILE_IDS.GERMAN_LEARNER);\n    }\n  }\n\n  /**\n   * Create default profile structure\n   */\n  private createDefaultProfiles(): void {\n    const profiles: Record<string, Profile> = {\n      [this.PROFILE_IDS.GERMAN_LEARNER]: {\n        id: this.PROFILE_IDS.GERMAN_LEARNER,\n        name: 'German Learner',\n        displayName: 'Deutsch lernen (BG→DE)',\n        direction: 'bg-de',\n        sourceLanguage: 'bg',\n        targetLanguage: 'de',\n        createdAt: new Date().toISOString(),\n        lastAccessedAt: new Date().toISOString(),\n        statistics: {\n          totalReviews: 0,\n          totalCorrect: 0,\n          totalTime: 0,\n          streak: 0\n        },\n        settings: {\n          dailyGoal: 20,\n          autoPlayAudio: true,\n          voiceGender: 'female'\n        },\n        customVocabulary: [],\n        customTags: [],\n        customCategories: []\n      },\n      [this.PROFILE_IDS.BULGARIAN_LEARNER]: {\n        id: this.PROFILE_IDS.BULGARIAN_LEARNER,\n        name: 'Bulgarian Learner',\n        displayName: 'Български език (DE→BG)',\n        direction: 'de-bg',\n        sourceLanguage: 'de',\n        targetLanguage: 'bg',\n        createdAt: new Date().toISOString(),\n        lastAccessedAt: new Date().toISOString(),\n        statistics: {\n          totalReviews: 0,\n          totalCorrect: 0,\n          totalTime: 0,\n          streak: 0\n        },\n        settings: {\n          dailyGoal: 20,\n          autoPlayAudio: true,\n          voiceGender: 'female'\n        },\n        customVocabulary: [],\n        customTags: [],\n        customCategories: []\n      }\n    };\n\n    localStorage.setItem(this.PROFILES_KEY, JSON.stringify(profiles));\n    console.log('[ProfileManager] Created default profiles');\n  }\n\n  /**\n   * Migrate legacy localStorage data to profile system\n   */\n  private migrateLegacyData(): void {\n    console.log('[ProfileManager] Checking for legacy data to migrate...');\n\n    const legacyKeys: string[] = [];\n    for (let i = 0; i < localStorage.length; i++) {\n      const key = localStorage.key(i);\n      if (key && key.startsWith('bgde:') &&\n          !key.includes(this.PROFILES_KEY) &&\n          !key.includes(this.ACTIVE_PROFILE_KEY)) {\n        legacyKeys.push(key);\n      }\n    }\n\n    if (legacyKeys.length === 0) {\n      console.log('[ProfileManager] No legacy data found');\n      return;\n    }\n\n    console.log(`[ProfileManager] Migrating ${legacyKeys.length} legacy keys...`);\n\n    // Migrate to german_learner profile (default)\n    for (const key of legacyKeys) {\n      const value = localStorage.getItem(key);\n      const newKey = key.replace('bgde:', `bgde:${this.PROFILE_IDS.GERMAN_LEARNER}:`);\n      if (value) {\n        localStorage.setItem(newKey, value);\n        console.log(`[ProfileManager] Migrated: ${key} → ${newKey}`);\n      }\n    }\n\n    console.log('[ProfileManager] Legacy data migration complete');\n  }\n\n  /**\n   * Get all profiles\n   */\n  getAllProfiles(): Record<string, Profile> {\n    const profiles = localStorage.getItem(this.PROFILES_KEY);\n    return profiles ? JSON.parse(profiles) : {};\n  }\n\n  /**\n   * Get specific profile by ID\n   */\n  getProfile(profileId: string): Profile | null {\n    const profiles = this.getAllProfiles();\n    return profiles[profileId] || null;\n  }\n\n  /**\n   * Get active profile\n   */\n  getActiveProfile(): Profile | null {\n    const activeId = localStorage.getItem(this.ACTIVE_PROFILE_KEY);\n    return activeId ? this.getProfile(activeId) : null;\n  }\n\n  /**\n   * Get active profile ID\n   */\n  getActiveProfileId(): string {\n    return localStorage.getItem(this.ACTIVE_PROFILE_KEY) || this.PROFILE_IDS.GERMAN_LEARNER;\n  }\n\n  /**\n   * Switch to a different profile\n   */\n  switchProfile(profileId: string): boolean {\n    const profileObj = this.getProfile(profileId);\n\n    if (!profileObj) {\n      console.error(`[ProfileManager] Profile not found: ${profileId}`);\n      return false;\n    }\n\n    // Update last accessed timestamp\n    const profiles = this.getAllProfiles();\n    const profileToUpdate = profiles[profileId];\n    if (profileToUpdate) {\n      profileToUpdate.lastAccessedAt = new Date().toISOString();\n      localStorage.setItem(this.PROFILES_KEY, JSON.stringify(profiles));\n    }\n\n    // Switch active profile\n    localStorage.setItem(this.ACTIVE_PROFILE_KEY, profileId);\n\n    console.log(`[ProfileManager] Switched to profile: ${profileObj.displayName}`);\n\n    // Dispatch event for UI updates\n    window.dispatchEvent(new CustomEvent('profile-switched', {\n      detail: {\n        profileId,\n        profile: profileObj || undefined,\n        previousProfileId: this.getActiveProfileId()\n      }\n    }));\n\n    return true;\n  }\n\n  /**\n   * Get namespaced localStorage key for profile\n   */\n  getNamespacedKey(key: string, profileId: string | null = null): string {\n    const activeId = profileId || this.getActiveProfileId();\n    return `bgde:${activeId}:${key}`;\n  }\n}\n\n// ProfileSwitcherUI Class\nclass ProfileSwitcherUI {\n  private profileManager: ProfileManager | undefined;\n  private container: HTMLElement | null = null;\n  private isOpen: boolean = false;\n\n  constructor(profileManager: ProfileManager) {\n    if (!profileManager) {\n      console.error('[ProfileSwitcherUI] ProfileManager is required');\n      return;\n    }\n\n    this.profileManager = profileManager;\n    this.container = null;\n    this.isOpen = false;\n\n    this.init();\n  }\n\n  /**\n   * Initialize the UI component\n   */\n  private init(): void {\n    this.findContainer();\n\n    if (!this.container) {\n      console.warn('[ProfileSwitcherUI] Container not found, waiting for DOM...');\n      if (document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', () => this.findContainer() && this.render());\n      }\n      return;\n    }\n\n    this.render();\n    this.attachEventListeners();\n  }\n\n  /**\n   * Find the container element in the DOM\n   */\n  private findContainer(): boolean {\n    this.container = document.querySelector('[data-profile-switcher]');\n    return this.container !== null;\n  }\n\n  /**\n   * Render the profile switcher UI\n   */\n  private render(): void {\n    if (!this.container) {\n      return;\n    }\n\n    const activeProfile = this.profileManager?.getActiveProfile();\n    if (!activeProfile) {\n      console.error('[ProfileSwitcherUI] No active profile found');\n      return;\n    }\n\n    this.container.innerHTML = `\n      <div class=\"profile-switcher\">\n        <button\n          id=\"profile-toggle\"\n          class=\"profile-toggle\"\n          aria-label=\"Switch learning profile\"\n          aria-expanded=\"false\"\n          aria-haspopup=\"true\"\n        >\n          <span class=\"profile-icon\">${this.getProfileIcon(activeProfile.id)}</span>\n          <span class=\"profile-label\">${this.getProfileShortLabel(activeProfile.direction)}</span>\n        </button>\n\n        <div class=\"profile-dropdown hidden\" id=\"profile-dropdown\">\n          <div class=\"profile-dropdown-header\">\n            <h3>Learning Profile</h3>\n          </div>\n\n          <div class=\"profile-options\">\n            ${this.renderProfileOptions()}\n          </div>\n        </div>\n      </div>\n    `;\n\n    console.log('[ProfileSwitcherUI] Rendered profile switcher');\n  }\n\n  /**\n   * Render profile option buttons\n   */\n  private renderProfileOptions(): string {\n    if (!this.profileManager) return '';\n    const profiles = this.profileManager.getAllProfiles();\n    const activeId = this.profileManager.getActiveProfileId();\n\n    return Object.values(profiles).map(profile => {\n      const isActive = profile.id === activeId;\n\n      return `\n        <button\n          class=\"profile-option ${isActive ? 'active' : ''}\"\n          data-profile-id=\"${profile.id}\"\n          aria-pressed=\"${isActive}\"\n        >\n          <span class=\"profile-option-icon\">${this.getProfileIcon(profile.id)}</span>\n          <div class=\"profile-option-content\">\n            <div class=\"profile-option-name\">${profile.displayName}</div>\n            <div class=\"profile-option-meta\">\n              <span class=\"profile-direction\">${this.getDirectionLabel(profile.direction)}</span>\n              ${isActive ? '<span class=\"profile-option-badge\">Active</span>' : ''}\n            </div>\n          </div>\n          ${isActive ? '<span class=\"profile-option-check\">✓</span>' : ''}\n        </button>\n      `;\n    }).join('');\n  }\n\n  /**\n   * Get profile icon (flag emoji)\n   */\n  private getProfileIcon(profileId: string): string {\n    switch (profileId) {\n    case this.profileManager?.PROFILE_IDS.GERMAN_LEARNER: {\n      return '🇩🇪';\n    }\n    case this.profileManager?.PROFILE_IDS.BULGARIAN_LEARNER: {\n      return '🇧🇬';\n    }\n    default: {\n      return '🌍';\n    }\n    }\n  }\n\n  /**\n   * Get short label for profile direction\n   */\n  private getProfileShortLabel(direction: string): string {\n    switch (direction) {\n    case 'bg-de': {\n      return 'BG→DE';\n    }\n    case 'de-bg': {\n      return 'DE→BG';\n    }\n    default: {\n      return direction.toUpperCase();\n    }\n    }\n  }\n\n  /**\n   * Get full label for profile direction\n   */\n  private getDirectionLabel(direction: string): string {\n    switch (direction) {\n    case 'bg-de': {\n      return 'Bulgarian → German';\n    }\n    case 'de-bg': {\n      return 'German → Bulgarian';\n    }\n    default: {\n      return direction;\n    }\n    }\n  }\n\n  /**\n   * Attach event listeners\n   */\n  private attachEventListeners(): void {\n    // Toggle dropdown\n    const toggleBtn = document.querySelector('#profile-toggle');\n    if (toggleBtn) {\n      toggleBtn.addEventListener('click', (e: Event) => {\n        e.stopPropagation();\n        this.toggleDropdown();\n      });\n    }\n\n    // Profile option clicks\n    document.addEventListener('click', (e: Event) => {\n      const optionBtn = (e.target as HTMLElement).closest('.profile-option');\n      if (optionBtn) {\n        const profileId = optionBtn.dataset.profileId;\n        if (profileId && profileId !== this.profileManager?.getActiveProfileId()) {\n          this.handleProfileSwitch(profileId);\n        }\n      }\n    });\n\n    // Close dropdown when clicking outside\n    document.addEventListener('click', (e: Event) => {\n      const switcher = (e.target as HTMLElement).closest('.profile-switcher');\n      if (!switcher && this.isOpen) {\n        this.closeDropdown();\n      }\n    });\n\n    // Close dropdown on escape key\n    document.addEventListener('keydown', (e: KeyboardEvent) => {\n      if (e.key === 'Escape' && this.isOpen) {\n        this.closeDropdown();\n        const toggleBtn = document.querySelector('#profile-toggle') as HTMLElement | null;\n        toggleBtn?.focus();\n      }\n    });\n\n    // Listen for profile switch events from other sources\n    window.addEventListener('profile-switched', (e: CustomEvent<ProfileSwitchDetail>) => {\n      this.handleProfileSwitched(e.detail);\n    });\n\n    console.log('[ProfileSwitcherUI] Event listeners attached');\n  }\n\n  /**\n   * Toggle dropdown visibility\n   */\n  private toggleDropdown(): void {\n    if (this.isOpen) {\n      this.closeDropdown();\n    } else {\n      this.openDropdown();\n    }\n  }\n\n  /**\n   * Open dropdown\n   */\n  private openDropdown(): void {\n    const dropdown = document.querySelector('#profile-dropdown');\n    const toggleBtn = document.querySelector('#profile-toggle');\n\n    if (dropdown && toggleBtn) {\n      dropdown.classList.remove('hidden');\n      toggleBtn.setAttribute('aria-expanded', 'true');\n      this.isOpen = true;\n    }\n  }\n\n  /**\n   * Close dropdown\n   */\n  private closeDropdown(): void {\n    const dropdown = document.querySelector('#profile-dropdown');\n    const toggleBtn = document.querySelector('#profile-toggle');\n\n    if (dropdown && toggleBtn) {\n      dropdown.classList.add('hidden');\n      toggleBtn.setAttribute('aria-expanded', 'false');\n      this.isOpen = false;\n    }\n  }\n\n  /**\n   * Handle profile switch\n   */\n  private handleProfileSwitch(profileId: string): void {\n    console.log(`[ProfileSwitcherUI] Switching to profile: ${profileId}`);\n\n    const success = this.profileManager?.switchProfile(profileId);\n\n    if (success) {\n      this.closeDropdown();\n\n      // Show brief confirmation message\n      this.showSwitchConfirmation(profileId);\n\n      // Reload page content after a brief delay\n      setTimeout(() => {\n        window.location.reload();\n      }, 500);\n    } else {\n      console.error(`[ProfileSwitcherUI] Failed to switch to profile: ${profileId}`);\n      alert('Failed to switch profile. Please try again.');\n    }\n  }\n\n  /**\n   * Handle profile switched event (from other sources)\n   */\n  private handleProfileSwitched(detail: ProfileSwitchDetail): void {\n    console.log('[ProfileSwitcherUI] Profile switched event received', detail);\n\n    // Re-render to update active profile indicator\n    this.render();\n    this.attachEventListeners();\n  }\n\n  /**\n   * Show switch confirmation message\n   */\n  private showSwitchConfirmation(profileId: string): void {\n    if (!this.profileManager) return;\n    const profile = this.profileManager.getProfile(profileId);\n    if (!profile) {\n      return;\n    }\n\n    // Create temporary toast notification\n    const toast = document.createElement('div');\n    toast.className = 'profile-switch-toast';\n    toast.innerHTML = `\n      <span class=\"toast-icon\">${this.getProfileIcon(profileId)}</span>\n      <span class=\"toast-message\">Switched to ${profile.displayName}</span>\n    `;\n\n    document.body.append(toast);\n\n    // Animate in\n    setTimeout(() => toast.classList.add('show'), 10);\n\n    // Remove after 2 seconds\n    setTimeout(() => {\n      toast.classList.remove('show');\n      setTimeout(() => toast.remove(), 300);\n    }, 2000);\n  }\n}\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    window.profileManager = new ProfileManager();\n    window.profileSwitcherUI = new ProfileSwitcherUI(window.profileManager);\n    console.log('[ProfileSystem] Initialized');\n  });\n} else {\n  window.profileManager = new ProfileManager();\n  window.profileSwitcherUI = new ProfileSwitcherUI(window.profileManager);\n  console.log('[ProfileSystem] Initialized');\n}\n\nexport { ProfileManager, ProfileSwitcherUI, type Profile, type ProfileStatistics, type ProfileSettings };","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/progress-dashboard-init.ts","messages":[{"ruleId":"no-var","severity":2,"message":"Unexpected var, use let or const instead.","line":7,"column":3,"nodeType":"VariableDeclaration","messageId":"unexpectedVar","endLine":7,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[176,179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[176,179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":117,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":120,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[484,487],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[484,487],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over an async function `initializeProgressDashboard` call.","line":37,"column":3,"nodeType":"CallExpression","messageId":"identifier","endLine":37,"endColumn":32,"suggestions":[{"messageId":"add-await","fix":{"range":[1195,1195],"text":"await "},"data":{"name":"initializeProgressDashboard"},"desc":"Insert `await`."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Progress Dashboard Initialization Script\n * Loads the progress dashboard module and initializes it when the page is ready\n */\n\ndeclare global {\n  var progressDashboard: any;\n}\n\nconsole.log('[ProgressDashboard-Init] Module loaded');\n\n// Import the ProgressDashboard class with error handling\nasync function initializeProgressDashboard(): Promise<void> {\n  try {\n    const { ProgressDashboard } = await import('./modules/progress-dashboard.js') as { ProgressDashboard: new () => any };\n\n    // Check if dashboard container exists\n    const container = document.querySelector('.progress-dashboard');\n    if (!container) {\n      console.log('[ProgressDashboard] Container not found');\n      return;\n    }\n\n    console.log('[ProgressDashboard] Initializing...');\n    window.progressDashboard = new ProgressDashboard();\n    await window.progressDashboard.initialize();\n    console.log('[ProgressDashboard] Initialization complete');\n  } catch (error) {\n    console.error('[ProgressDashboard] Initialization failed:', error);\n  }\n}\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', initializeProgressDashboard);\n} else {\n  initializeProgressDashboard();\n}\n\nexport { initializeProgressDashboard };","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/session-stats-dashboard.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[180,183],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[180,183],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1194,1197],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1194,1197],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"unicorn/prefer-query-selector","severity":2,"message":"Prefer `.querySelector()` over `.getElementById()`.","line":110,"column":32,"nodeType":"Identifier","messageId":"prefer-query-selector","endLine":110,"endColumn":46},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":259,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":259,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7994,7997],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7994,7997],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":264,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8148,8151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8148,8151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":718,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":718,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21509,21512],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21509,21512],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":719,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":719,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21580,21583],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21580,21583],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":719,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":719,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21588,21591],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21588,21591],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":727,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":727,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21860,21863],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21860,21863],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":746,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":746,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22468,22471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22468,22471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":747,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":747,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22540,22543],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22540,22543],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":747,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":747,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22548,22551],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22548,22551],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":755,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":755,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22826,22829],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22826,22829],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":814,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":814,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24273,24276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24273,24276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Session Statistics Dashboard\n * Provides comprehensive analytics and visualizations for learning progress\n */\n\ninterface SessionStatsDashboardOptions {\n  spacedRepetition?: any;\n  containerId?: string;\n}\n\ninterface SessionData {\n  date: string;\n  duration?: number;\n  accuracy: number;\n  categories?: Array<{ name: string; correct: number; total: number }>;\n  direction?: string;\n}\n\ninterface SessionStats {\n  total: number;\n  totalTime: number;\n  avgAccuracy: number;\n}\n\ninterface ReviewStats {\n  total: number;\n  correct: number;\n}\n\ninterface StreakStats {\n  current: number;\n  max: number;\n}\n\ninterface CategoryStats {\n  [key: string]: { correct: number; total: number };\n}\n\ninterface DirectionStats {\n  [key: string]: { sessions: number; accuracy: number };\n}\n\ninterface ActivityData {\n  [key: string]: number;\n}\n\ninterface DashboardData {\n  sessions: SessionStats;\n  reviews: ReviewStats;\n  streaks: StreakStats;\n  categories: CategoryStats;\n  directions: DirectionStats;\n  activity: ActivityData;\n}\n\ninterface ChartOptions {\n  labels: string[];\n  data: number[];\n  color?: string;\n  colors?: string[];\n  title?: string;\n}\n\nclass SessionStatsDashboard {\n  private spacedRepetition: any;\n  private containerId: string;\n  private chartColors = {\n    primary: '#3b82f6',\n    success: '#10b981',\n    warning: '#f59e0b',\n    error: '#ef4444',\n    secondary: '#6b7280'\n  };\n        \n  private initialized = false;\n  private data: DashboardData = {\n    sessions: { total: 0, totalTime: 0, avgAccuracy: 0 },\n    reviews: { total: 0, correct: 0 },\n    streaks: { current: 0, max: 0 },\n    categories: {},\n    directions: {},\n    activity: {}\n  };\n\n  constructor(options: SessionStatsDashboardOptions = {}) {\n    this.spacedRepetition = options.spacedRepetition;\n    this.containerId = options.containerId || 'stats-dashboard';\n  }\n    \n  /**\n     * Initialize the dashboard\n     */\n  init(): void {\n    if (this.initialized) {\n      return;\n    }\n        \n    this.createDashboardStructure();\n    this.loadData();\n    this.renderCharts();\n    this.setupEventListeners();\n        \n    this.initialized = true;\n  }\n    \n  /**\n     * Create the dashboard HTML structure\n     */\n  createDashboardStructure(): void {\n    const container = document.getElementById(this.containerId);\n    if (!container) {\n      return;\n    }\n        \n    container.innerHTML = `\n            <div class=\"stats-dashboard\">\n                <div class=\"dashboard-header\">\n                    <h2>Lernstatistiken / Статистики за обучение</h2>\n                    <div class=\"time-filter\">\n                        <select id=\"time-range\">\n                            <option value=\"7\">Letzte 7 Tage / Последните 7 дни</option>\n                            <option value=\"30\" selected>Letzter Monat / Последният месец</option>\n                            <option value=\"90\">Letzte 3 Monate / Последните 3 месеца</option>\n                            <option value=\"all\">Alle Zeit / Цялото време</option>\n                        </select>\n                    </div>\n                </div>\n                \n                <div class=\"stats-grid\">\n                    <div class=\"stat-card\">\n                        <div class=\"stat-icon\">📊</div>\n                        <div class=\"stat-content\">\n                            <div class=\"stat-value\" id=\"total-sessions\">0</div>\n                            <div class=\"stat-label\">Sitzungen / Сесии</div>\n                        </div>\n                    </div>\n                    \n                    <div class=\"stat-card\">\n                        <div class=\"stat-icon\">⚡</div>\n                        <div class=\"stat-content\">\n                            <div class=\"stat-value\" id=\"avg-accuracy\">0%</div>\n                            <div class=\"stat-label\">Genauigkeit / Точност</div>\n                        </div>\n                    </div>\n                    \n                    <div class=\"stat-card\">\n                        <div class=\"stat-icon\">🔥</div>\n                        <div class=\"stat-content\">\n                            <div class=\"stat-value\" id=\"current-streak\">0</div>\n                            <div class=\"stat-label\">Aktuelle Serie / Текуща серия</div>\n                        </div>\n                    </div>\n                    \n                    <div class=\"stat-card\">\n                        <div class=\"stat-icon\">⏱️</div>\n                        <div class=\"stat-content\">\n                            <div class=\"stat-value\" id=\"total-time\">0m</div>\n                            <div class=\"stat-label\">Lernzeit / Време за учене</div>\n                        </div>\n                    </div>\n                </div>\n                \n                <div class=\"charts-grid\">\n                    <div class=\"chart-container\">\n                        <h3>Fortschritt über Zeit / Прогрес във времето</h3>\n                        <canvas id=\"progress-chart\"></canvas>\n                    </div>\n                    \n                    <div class=\"chart-container\">\n                        <h3>Genauigkeit nach Kategorie / Точност по категория</h3>\n                        <canvas id=\"category-chart\"></canvas>\n                    </div>\n                    \n                    <div class=\"chart-container\">\n                        <h3>Lernrichtung / Посока на обучение</h3>\n                        <canvas id=\"direction-chart\"></canvas>\n                    </div>\n                    \n                    <div class=\"chart-container\">\n                        <h3>Wöchentliche Aktivität / Седмична активност</h3>\n                        <canvas id=\"activity-chart\"></canvas>\n                    </div>\n                </div>\n                \n                <div class=\"detailed-stats\">\n                    <div class=\"stats-section\">\n                        <h3>Schwierige Wörter / Трудни думи</h3>\n                        <div id=\"difficult-words\" class=\"word-list\"></div>\n                    </div>\n                    \n                    <div class=\"stats-section\">\n                        <h3>Gemeisterte Wörter / Овладени думи</h3>\n                        <div id=\"mastered-words\" class=\"word-list\"></div>\n                    </div>\n                </div>\n            </div>\n        `;\n  }\n    \n  /**\n     * Load statistical data\n     */\n  loadData(): void {\n    const timeRange = (document.querySelector('#time-range') as HTMLSelectElement)?.value || '30';\n    const cutoffDate = this.getCutoffDate(timeRange);\n        \n    this.data = {\n      sessions: this.getSessionData(cutoffDate),\n      reviews: this.getReviewData(cutoffDate),\n      streaks: this.getStreakData(),\n      categories: this.getCategoryStats(cutoffDate),\n      directions: this.getDirectionStats(cutoffDate),\n      activity: this.getActivityData(cutoffDate)\n    };\n  }\n    \n  /**\n     * Get cutoff date for time range\n     */\n  getCutoffDate(timeRange: string): Date | null {\n    if (timeRange === 'all') {\n      return null;\n    }\n        \n    const days = Number.parseInt(timeRange);\n    const date = new Date();\n    date.setDate(date.getDate() - days);\n    return date;\n  }\n    \n  /**\n     * Get session statistics\n     */\n  getSessionData(cutoffDate: Date | null): SessionStats {\n    const sessions = this.getStoredSessions();\n    const filtered = cutoffDate \n      ? sessions.filter(s => new Date(s.date) >= cutoffDate)\n      : sessions;\n            \n    return {\n      total: filtered.length,\n      totalTime: filtered.reduce((sum, s) => sum + (s.duration || 0), 0),\n      avgAccuracy: filtered.length > 0 \n        ? Math.round(filtered.reduce((sum, s) => sum + s.accuracy, 0) / filtered.length)\n        : 0\n    };\n  }\n    \n  /**\n     * Get review statistics\n     */\n  getReviewData(cutoffDate: Date | null): ReviewStats {\n    if (!this.spacedRepetition) {\n      return { total: 0, correct: 0 };\n    }\n        \n    const reviews = Object.values(this.spacedRepetition?.reviewStates || {});\n    const filtered = cutoffDate\n      ? reviews.filter((r: any) => new Date(r.lastReview) >= cutoffDate)\n      : reviews;\n            \n    return {\n      total: filtered.length,\n      correct: filtered.filter((r: any) => r.repetitions > 0).length\n    };\n  }\n    \n  /**\n     * Get streak statistics\n     */\n  getStreakData(): StreakStats {\n    const sessions = this.getStoredSessions();\n    let currentStreak = 0;\n    let maxStreak = 0;\n    let tempStreak = 0;\n        \n    // Sort sessions by date\n    sessions.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime());\n        \n    // Calculate current streak\n    const today = new Date();\n    for (const [i, session] of sessions.entries()) {\n      if (!session) continue;\n      const sessionDate = new Date(session.date);\n      const daysDiff = Math.floor((today.getTime() - sessionDate.getTime()) / (1000 * 60 * 60 * 24));\n            \n      if (daysDiff === i) {\n        currentStreak++;\n      } else {\n        break;\n      }\n    }\n        \n    // Calculate max streak\n    let lastDate: Date | null = null;\n    for (const session of sessions) {\n      if (!session) continue;\n      const sessionDate = new Date(session.date);\n            \n      if (!lastDate || Math.abs(sessionDate.getTime() - lastDate.getTime()) <= 86_400_000) {\n        tempStreak++;\n        maxStreak = Math.max(maxStreak, tempStreak);\n      } else {\n        tempStreak = 1;\n      }\n            \n      lastDate = sessionDate;\n    }\n        \n    return { current: currentStreak, max: maxStreak };\n  }\n    \n  /**\n     * Get category statistics\n     */\n  getCategoryStats(cutoffDate: Date | null): CategoryStats {\n    const sessions = this.getStoredSessions();\n    const filtered = cutoffDate \n      ? sessions.filter(s => new Date(s.date) >= cutoffDate)\n      : sessions;\n            \n    const categoryStats: CategoryStats = {};\n        \n    for (const session of filtered) {\n      if (session?.categories) {\n        for (const cat of session.categories) {\n          if (!categoryStats[cat.name]) {\n            categoryStats[cat.name] = { correct: 0, total: 0 };\n          }\n          categoryStats[cat.name]!.correct += cat.correct;\n          categoryStats[cat.name]!.total += cat.total;\n        }\n      }\n    }\n        \n    return categoryStats;\n  }\n    \n  /**\n     * Get learning direction statistics\n     */\n  getDirectionStats(cutoffDate: Date | null): DirectionStats {\n    const sessions = this.getStoredSessions();\n    const filtered = cutoffDate \n      ? sessions.filter(s => new Date(s.date) >= cutoffDate)\n      : sessions;\n            \n    const directionStats: DirectionStats = {\n      'bg-de': { sessions: 0, accuracy: 0 },\n      'de-bg': { sessions: 0, accuracy: 0 }\n    };\n        \n    const normalizeDirection = (value: string | undefined): string | null => {\n      if (!value) {\n        return null;\n      }\n      const normalized = value.toString().toLowerCase();\n      if (normalized === 'bg-de' || normalized === 'bg_to_de') {\n        return 'bg-de';\n      }\n      if (normalized === 'de-bg' || normalized === 'de_to_bg') {\n        return 'de-bg';\n      }\n      return directionStats[normalized] ? normalized : null;\n    };\n        \n    for (const session of filtered) {\n      const directionKey = normalizeDirection(session.direction);\n      if (directionKey && directionStats[directionKey]) {\n        directionStats[directionKey].sessions++;\n        directionStats[directionKey].accuracy += session.accuracy;\n      }\n    }\n        \n    // Calculate averages\n    for (const direction of Object.keys(directionStats)) {\n      const stats = directionStats[direction];\n      if (stats && stats.sessions > 0) {\n        stats.accuracy = Math.round(stats.accuracy / stats.sessions);\n      }\n    }\n        \n    return directionStats;\n  }\n    \n  /**\n     * Get weekly activity data\n     */\n  getActivityData(cutoffDate: Date | null): ActivityData {\n    const sessions = this.getStoredSessions();\n    const filtered = cutoffDate \n      ? sessions.filter(s => new Date(s.date) >= cutoffDate)\n      : sessions;\n            \n    const activityByDay: ActivityData = {};\n    const daysOfWeek = ['So', 'Mo', 'Di', 'Mi', 'Do', 'Fr', 'Sa'];\n        \n    // Initialize all days\n    for (const day of daysOfWeek) {\n      activityByDay[day] = 0;\n    }\n        \n    // Count sessions by day of week\n    for (const session of filtered) {\n      const dayIndex = new Date(session.date).getDay();\n      const dayName = daysOfWeek[dayIndex];\n      if (dayName) {\n        activityByDay[dayName]!++;\n      }\n    }\n        \n    return activityByDay;\n  }\n    \n  /**\n     * Render all charts\n     */\n  renderCharts(): void {\n    this.renderProgressChart();\n    this.renderCategoryChart();\n    this.renderDirectionChart();\n    this.renderActivityChart();\n    this.updateStatCards();\n    this.updateWordLists();\n  }\n    \n  /**\n     * Render progress over time chart\n     */\n  renderProgressChart(): void {\n    const canvas = document.querySelector('#progress-chart') as HTMLCanvasElement;\n    if (!canvas) {\n      return;\n    }\n        \n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    \n    const sessions = this.getStoredSessions().slice(-30); // Last 30 sessions\n        \n    // Simple line chart implementation\n    this.drawLineChart(ctx, {\n      labels: sessions.map((_, i) => `S${i + 1}`),\n      data: sessions.map(s => s.accuracy),\n      color: this.chartColors.primary,\n      title: 'Accuracy Trend'\n    });\n  }\n    \n  /**\n     * Render category accuracy chart\n     */\n  renderCategoryChart(): void {\n    const canvas = document.querySelector('#category-chart') as HTMLCanvasElement;\n    if (!canvas) {\n      return;\n    }\n        \n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    \n    const categoryStats = this.data.categories;\n        \n    const categories = Object.keys(categoryStats);\n    const accuracies = categories.map(cat => {\n      const stats = categoryStats[cat];\n      return stats && stats.total > 0 ? Math.round((stats.correct / stats.total) * 100) : 0;\n    });\n        \n    this.drawBarChart(ctx, {\n      labels: categories,\n      data: accuracies,\n      colors: categories.map((_, i) => this.getColorByIndex(i)),\n      title: 'Category Accuracy'\n    });\n  }\n    \n  /**\n     * Render learning direction chart\n     */\n  renderDirectionChart(): void {\n    const canvas = document.querySelector('#direction-chart') as HTMLCanvasElement;\n    if (!canvas) {\n      return;\n    }\n        \n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    \n    const directionStats = this.data.directions;\n        \n    const bgToDe = directionStats['bg-de']?.sessions || 0;\n    const deToBg = directionStats['de-bg']?.sessions || 0;\n        \n    this.drawPieChart(ctx, {\n      labels: ['BG → DE', 'DE → BG'],\n      data: [bgToDe, deToBg],\n      colors: [this.chartColors.primary, this.chartColors.success]\n    });\n  }\n    \n  /**\n     * Render weekly activity chart\n     */\n  renderActivityChart(): void {\n    const canvas = document.querySelector('#activity-chart') as HTMLCanvasElement;\n    if (!canvas) {\n      return;\n    }\n        \n    const ctx = canvas.getContext('2d');\n    if (!ctx) return;\n    \n    const activityData = this.data.activity;\n        \n    this.drawBarChart(ctx, {\n      labels: Object.keys(activityData),\n      data: Object.values(activityData),\n      colors: Object.keys(activityData).map(() => this.chartColors.secondary),\n      title: 'Weekly Activity'\n    });\n  }\n    \n  /**\n     * Simple line chart implementation\n     */\n  drawLineChart(ctx: CanvasRenderingContext2D, options: ChartOptions): void {\n    const { data, color } = options;\n    const canvas = ctx.canvas;\n    const width = canvas.width = canvas.offsetWidth;\n    const height = canvas.height = canvas.offsetHeight;\n        \n    ctx.clearRect(0, 0, width, height);\n        \n    if (data.length === 0) {\n      return;\n    }\n        \n    const padding = 40;\n    const chartWidth = width - 2 * padding;\n    const chartHeight = height - 2 * padding;\n        \n    const maxValue = Math.max(...data, 100);\n    const minValue = Math.min(...data, 0);\n    const valueRange = maxValue - minValue || 1;\n        \n    // Draw axes\n    ctx.strokeStyle = '#e5e7eb';\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(padding, padding);\n    ctx.lineTo(padding, height - padding);\n    ctx.lineTo(width - padding, height - padding);\n    ctx.stroke();\n        \n    // Draw line\n    ctx.strokeStyle = color || this.chartColors.primary;\n    ctx.lineWidth = 2;\n    ctx.beginPath();\n        \n    for (const [index, value] of data.entries()) {\n      const x = padding + (index / (data.length - 1)) * chartWidth;\n      const y = height - padding - ((value - minValue) / valueRange) * chartHeight;\n            \n      if (index === 0) {\n        ctx.moveTo(x, y);\n      } else {\n        ctx.lineTo(x, y);\n      }\n    }\n        \n    ctx.stroke();\n        \n    // Draw points\n    ctx.fillStyle = color || this.chartColors.primary;\n    for (const [index, value] of data.entries()) {\n      const x = padding + (index / (data.length - 1)) * chartWidth;\n      const y = height - padding - ((value - minValue) / valueRange) * chartHeight;\n            \n      ctx.beginPath();\n      ctx.arc(x, y, 3, 0, 2 * Math.PI);\n      ctx.fill();\n    }\n  }\n    \n  /**\n     * Simple bar chart implementation\n     */\n  drawBarChart(ctx: CanvasRenderingContext2D, options: ChartOptions): void {\n    const { data, colors } = options;\n    const canvas = ctx.canvas;\n    const width = canvas.width = canvas.offsetWidth;\n    const height = canvas.height = canvas.offsetHeight;\n        \n    ctx.clearRect(0, 0, width, height);\n        \n    if (data.length === 0) {\n      return;\n    }\n        \n    const padding = 40;\n    const chartWidth = width - 2 * padding;\n    const chartHeight = height - 2 * padding;\n    const barWidth = chartWidth / data.length * 0.8;\n    const maxValue = Math.max(...data, 1);\n        \n    for (const [index, value] of data.entries()) {\n      const barHeight = (value / maxValue) * chartHeight;\n      const x = padding + (index + 0.1) * (chartWidth / data.length);\n      const y = height - padding - barHeight;\n            \n      ctx.fillStyle = colors?.[index] || this.chartColors.primary;\n      ctx.fillRect(x, y, barWidth, barHeight);\n            \n      // Draw value on top\n      ctx.fillStyle = '#374151';\n      ctx.font = '12px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(value.toString(), x + barWidth / 2, y - 5);\n    }\n  }\n    \n  /**\n     * Simple pie chart implementation\n     */\n  drawPieChart(ctx: CanvasRenderingContext2D, options: ChartOptions): void {\n    const { labels, data, colors } = options;\n    const canvas = ctx.canvas;\n    const width = canvas.width = canvas.offsetWidth;\n    const height = canvas.height = canvas.offsetHeight;\n        \n    ctx.clearRect(0, 0, width, height);\n        \n    const total = data.reduce((sum, value) => sum + value, 0);\n    if (total === 0) {\n      return;\n    }\n        \n    const centerX = width / 2;\n    const centerY = height / 2;\n    const radius = Math.min(width, height) / 3;\n        \n    let currentAngle = -Math.PI / 2;\n        \n    for (const [index, value] of data.entries()) {\n      const sliceAngle = (value / total) * 2 * Math.PI;\n            \n      ctx.fillStyle = colors?.[index] || this.getColorByIndex(index);\n      ctx.beginPath();\n      ctx.moveTo(centerX, centerY);\n      ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + sliceAngle);\n      ctx.closePath();\n      ctx.fill();\n            \n      // Draw label\n      const labelAngle = currentAngle + sliceAngle / 2;\n      const labelX = centerX + Math.cos(labelAngle) * (radius + 20);\n      const labelY = centerY + Math.sin(labelAngle) * (radius + 20);\n            \n      ctx.fillStyle = '#374151';\n      ctx.font = '12px sans-serif';\n      ctx.textAlign = 'center';\n      ctx.fillText(labels[index] || '', labelX, labelY);\n            \n      currentAngle += sliceAngle;\n    }\n  }\n    \n  /**\n     * Update stat cards with current data\n     */\n  updateStatCards(): void {\n    const elements = {\n      totalSessions: document.querySelector('#total-sessions'),\n      avgAccuracy: document.querySelector('#avg-accuracy'),\n      currentStreak: document.querySelector('#current-streak'),\n      totalTime: document.querySelector('#total-time')\n    };\n        \n    if (elements.totalSessions) {\n      elements.totalSessions.textContent = this.data.sessions.total.toString();\n    }\n        \n    if (elements.avgAccuracy) {\n      elements.avgAccuracy.textContent = `${this.data.sessions.avgAccuracy}%`;\n    }\n        \n    if (elements.currentStreak) {\n      elements.currentStreak.textContent = this.data.streaks.current.toString();\n    }\n        \n    if (elements.totalTime) {\n      const hours = Math.floor(this.data.sessions.totalTime / 3_600_000);\n      const minutes = Math.floor((this.data.sessions.totalTime % 3_600_000) / 60_000);\n      elements.totalTime.textContent = hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`;\n    }\n  }\n    \n  /**\n     * Update word lists (difficult and mastered)\n     */\n  updateWordLists(): void {\n    this.updateDifficultWords();\n    this.updateMasteredWords();\n  }\n    \n  /**\n     * Update difficult words list\n     */\n  updateDifficultWords(): void {\n    const container = document.querySelector('#difficult-words');\n    if (!container || !this.spacedRepetition) {\n      return;\n    }\n        \n    const reviewStates = Object.values(this.spacedRepetition?.reviewStates || {});\n    const difficultWords = reviewStates\n      .filter((state: any) => state.easeFactor < 2 && state.repetitions > 2)\n      .sort((a: any, b: any) => a.easeFactor - b.easeFactor)\n      .slice(0, 10);\n        \n    if (difficultWords.length === 0) {\n      container.innerHTML = '<p>Keine schwierigen Wörter! / Няма трудни думи!</p>';\n      return;\n    }\n        \n    container.innerHTML = difficultWords.map((state: any) => `\n            <div class=\"word-item difficult\">\n                <span class=\"word\">${state.itemId}</span>\n                <span class=\"difficulty\">${state.easeFactor.toFixed(1)}</span>\n            </div>\n        `).join('');\n  }\n    \n  /**\n     * Update mastered words list\n     */\n  updateMasteredWords(): void {\n    const container = document.querySelector('#mastered-words');\n    if (!container || !this.spacedRepetition) {\n      return;\n    }\n        \n    const reviewStates = Object.values(this.spacedRepetition?.reviewStates || {});\n    const masteredWords = reviewStates\n      .filter((state: any) => state.interval >= 30 && state.repetitions >= 5)\n      .sort((a: any, b: any) => b.interval - a.interval)\n      .slice(0, 10);\n        \n    if (masteredWords.length === 0) {\n      container.innerHTML = '<p>Noch keine gemeisterten Wörter! / Още няма овладени думи!</p>';\n      return;\n    }\n        \n    container.innerHTML = masteredWords.map((state: any) => `\n            <div class=\"word-item mastered\">\n                <span class=\"word\">${state.itemId}</span>\n                <span class=\"interval\">${state.interval}d</span>\n            </div>\n        `).join('');\n  }\n    \n  /**\n     * Setup event listeners\n     */\n  setupEventListeners(): void {\n    const timeRangeSelect = document.querySelector('#time-range');\n    if (timeRangeSelect) {\n      timeRangeSelect.addEventListener('change', () => {\n        this.loadData();\n        this.renderCharts();\n      });\n    }\n  }\n    \n  /**\n     * Get stored session data from localStorage\n     */\n  getStoredSessions(): SessionData[] {\n    try {\n      const stored = localStorage.getItem('bgde:session_history');\n      return stored ? JSON.parse(stored) : [];\n    } catch (error) {\n      console.warn('Failed to load session history:', error);\n      return [];\n    }\n  }\n    \n  /**\n     * Get color by index for charts\n     */\n  getColorByIndex(index: number): string {\n    const colors = [\n      this.chartColors.primary,\n      this.chartColors.success,\n      this.chartColors.warning,\n      this.chartColors.error,\n      this.chartColors.secondary\n    ];\n    return colors[index % colors.length] || this.chartColors.primary;\n  }\n    \n  /**\n     * Refresh dashboard data and charts\n     */\n  refresh(): void {\n    this.loadData();\n    this.renderCharts();\n  }\n}\n\n// Global availability for browser\nif (typeof window !== 'undefined') {\n  (window as any).SessionStatsDashboard = SessionStatsDashboard;\n}\n\nexport default SessionStatsDashboard;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/spaced-repetition-system.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":165,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":165,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5366,5369],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5366,5369],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5417,5420],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5417,5420],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5452,5455],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5452,5455],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"unicorn/no-useless-switch-case","severity":2,"message":"Useless case in switch statement.","line":187,"column":5,"nodeType":"SwitchCase","messageId":"no-useless-switch-case/error","endLine":187,"endColumn":12,"suggestions":[{"messageId":"no-useless-switch-case/suggestion","fix":{"range":[5805,5812],"text":""},"data":{},"desc":"Remove this case."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":700,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":700,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25331,25334],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25331,25334],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":701,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":701,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25392,25395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25392,25395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":702,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":702,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25469,25472],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25469,25472],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":703,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":703,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25508,25511],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25508,25511],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":708,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":708,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25709,25712],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25709,25712],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":709,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":709,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25768,25771],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25768,25771],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":710,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":710,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25843,25846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25843,25846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":711,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":711,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[25880,25883],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[25880,25883],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file spaced-repetition-system.ts\n * @description Bundled file containing PhaseCalculator and UnifiedSpacedRepetition with profile isolation\n * @version 3.1.0 - Added profile namespacing support\n * @updated November 2025\n */\n\nimport type { \n  ReviewState, \n  LegacyReviewState, \n  MigrationLogEntry, \n  MigrationResults, \n  ExportData, \n  ImportResults, \n  DueItemsStats,\n  PhaseDetails,\n  PhaseStatistics\n} from './types.js';\n\n// ============================================================================\n// PHASE CALCULATOR\n// ============================================================================\n\n/**\n * Phase Calculator Module\n * Maps SM-2 ease factors to 6-phase learning progression system\n *\n * Phase System:\n * - Phase 1 (New): EF < 2.0 - Just introduced, frequent reviews\n * - Phase 2 (Learning): EF 2.0-2.2 - Building familiarity\n * - Phase 3 (Familiar): EF 2.2-2.4 - Recognizable but needs practice\n * - Phase 4 (Known): EF 2.4-2.6 - Comfortable recall\n * - Phase 5 (Mastered): EF 2.6-2.8 - Strong retention\n * - Phase 6 (Expert): EF 2.8-3.0 - Nearly perfect\n * - Learned: EF ≥ 3.0 - Long-term memory, periodic maintenance\n */\nclass PhaseCalculator {\n  // Phase thresholds based on ease factor\n  private PHASE_THRESHOLDS: Record<string, PhaseDetails> = {\n    PHASE_1: { min: 0, max: 2, name: 'New', color: '#ef4444' },\n    PHASE_2: { min: 2, max: 2.2, name: 'Learning', color: '#f97316' },\n    PHASE_3: { min: 2.2, max: 2.4, name: 'Familiar', color: '#eab308' },\n    PHASE_4: { min: 2.4, max: 2.6, name: 'Known', color: '#84cc16' },\n    PHASE_5: { min: 2.6, max: 2.8, name: 'Mastered', color: '#22c55e' },\n    PHASE_6: { min: 2.8, max: 3, name: 'Expert', color: '#10b981' },\n    LEARNED: { min: 3, max: Number.POSITIVE_INFINITY, name: 'Learned', color: '#06b6d4' }\n  };\n\n  // Minimum correct reviews required to advance from Phase 1\n  private MIN_REVIEWS_TO_ADVANCE: number = 3;\n\n  // Learned status requires sustained high performance\n  private LEARNED_MIN_REPETITIONS: number = 5;\n\n  calculatePhase(easeFactor: number, repetitions: number = 0): number {\n    const ef = Math.max(1.3, easeFactor);\n    if (ef >= 3 && repetitions >= this.LEARNED_MIN_REPETITIONS) {\n      return 0; // Learned status\n    }\n    if (ef < 2) return 1;\n    if (ef < 2.2) return 2;\n    if (ef < 2.4) return 3;\n    if (ef < 2.6) return 4;\n    if (ef < 2.8) return 5;\n    if (ef < 3) return 6;\n    return 6;\n  }\n\n  getPhaseDetails(phase: number): PhaseDetails {\n    switch (phase) {\n    case 0: { return this.PHASE_THRESHOLDS.LEARNED!;\n    }\n    case 1: { return this.PHASE_THRESHOLDS.PHASE_1!;\n    }\n    case 2: { return this.PHASE_THRESHOLDS.PHASE_2!;\n    }\n    case 3: { return this.PHASE_THRESHOLDS.PHASE_3!;\n    }\n    case 4: { return this.PHASE_THRESHOLDS.PHASE_4!;\n    }\n    case 5: { return this.PHASE_THRESHOLDS.PHASE_5!;\n    }\n    case 6: { return this.PHASE_THRESHOLDS.PHASE_6!;\n    }\n    default: { return this.PHASE_THRESHOLDS.PHASE_1!;\n    }\n    }\n  }\n\n  calculateNewPhase(currentPhase: number, quality: number, newEaseFactor: number, repetitions: number): number {\n    if (quality < 3) {\n      return Math.max(1, currentPhase - 1);\n    }\n    const newPhase = this.calculatePhase(newEaseFactor, repetitions);\n    if (newPhase === 0 && currentPhase === 6) {\n      return 0;\n    }\n    if (newPhase > currentPhase) {\n      return Math.min(newPhase, currentPhase + 1);\n    }\n    return newPhase;\n  }\n\n  canAdvanceToNextPhase(currentPhase: number, repetitions: number, easeFactor: number): boolean {\n    if (currentPhase === 0) {\n      return false;\n    }\n    if (currentPhase === 1 && repetitions < this.MIN_REVIEWS_TO_ADVANCE) {\n      return false;\n    }\n    const nextPhaseThreshold = this.getPhaseDetails(currentPhase + 1).min;\n    return easeFactor >= nextPhaseThreshold;\n  }\n\n  getPhaseProgress(phase: number, easeFactor: number): number {\n    if (phase === 0) {\n      return 100;\n    }\n    const phaseDetails = this.getPhaseDetails(phase);\n    const range = phaseDetails.max - phaseDetails.min;\n    if (range === 0 || range === Number.POSITIVE_INFINITY) {\n      return 0;\n    }\n    const progress = (easeFactor - phaseDetails.min) / range;\n    return Math.max(0, Math.min(100, progress * 100));\n  }\n\n  getPhaseStatistics(reviews: ReviewState[]): PhaseStatistics {\n    const stats: PhaseStatistics = {\n      learned: { count: 0, percentage: '0' },\n      phase1: { count: 0, percentage: '0' },\n      phase2: { count: 0, percentage: '0' },\n      phase3: { count: 0, percentage: '0' },\n      phase4: { count: 0, percentage: '0' },\n      phase5: { count: 0, percentage: '0' },\n      phase6: { count: 0, percentage: '0' },\n      total: reviews.length\n    };\n\n    if (reviews.length === 0) {\n      return stats;\n    }\n\n    for (const review of reviews) {\n      const phase = review.phase ?? this.calculatePhase(review.easeFactor || 2.5, review.repetitions || 0);\n      switch (phase) {\n      case 0: { stats.learned.count++; break;\n      }\n      case 1: { stats.phase1.count++; break;\n      }\n      case 2: { stats.phase2.count++; break;\n      }\n      case 3: { stats.phase3.count++; break;\n      }\n      case 4: { stats.phase4.count++; break;\n      }\n      case 5: { stats.phase5.count++; break;\n      }\n      case 6: { stats.phase6.count++; break;\n      }\n      }\n    }\n\n    for (const key of Object.keys(stats)) {\n      if (key !== 'total' && (stats as any)[key].count !== undefined) {\n        (stats as any)[key].percentage = (((stats as any)[key].count / stats.total) * 100).toFixed(1);\n      }\n    }\n\n    return stats;\n  }\n\n  getPhaseIntervalMultiplier(phase: number): number {\n    switch (phase) {\n    case 0: { return 3;\n    }\n    case 6: { return 2;\n    }\n    case 5: { return 1.5;\n    }\n    case 4: { return 1.2;\n    }\n    case 3: { return 1;\n    }\n    case 2: { return 0.9;\n    }\n    case 1:\n    default: { return 0.8;\n    }\n    }\n  }\n\n  needsMaintenanceReview(lastReviewDate: Date | string | number | null, easeFactor: number): boolean {\n    if (!lastReviewDate) {\n      return true;\n    }\n    const lastReviewTime = typeof lastReviewDate === 'number' \n      ? lastReviewDate \n      : new Date(lastReviewDate).getTime();\n    \n    const daysSinceReview = (Date.now() - lastReviewTime) / (1000 * 60 * 60 * 24);\n    let maintenanceInterval = 90;\n    if (easeFactor >= 3.5) {\n      maintenanceInterval = 180;\n    } else if (easeFactor >= 3.2) {\n      maintenanceInterval = 120;\n    }\n    return daysSinceReview >= maintenanceInterval;\n  }\n\n  getPhaseName(phase: number, language: 'en' | 'de' | 'bg' = 'en'): string {\n    const names: Record<number, Record<string, string>> = {\n      0: { en: 'Learned', de: 'Gelernt', bg: 'Научен' },\n      1: { en: 'New', de: 'Neu', bg: 'Нов' },\n      2: { en: 'Learning', de: 'Lernen', bg: 'Учене' },\n      3: { en: 'Familiar', de: 'Vertraut', bg: 'Познат' },\n      4: { en: 'Known', de: 'Bekannt', bg: 'Известен' },\n      5: { en: 'Mastered', de: 'Gemeistert', bg: 'Овладян' },\n      6: { en: 'Expert', de: 'Experte', bg: 'Експерт' }\n    };\n    return names[phase]?.[language] || names[phase]?.en || 'Unknown';\n  }\n\n  getPhaseIcon(phase: number): string {\n    const icons: Record<number, string> = {\n      0: '🎓', 1: '🌱', 2: '📖', 3: '👁️',\n      4: '✅', 5: '⭐', 6: '🏆'\n    };\n    return icons[phase] || '❓';\n  }\n}\n\n// ============================================================================\n// UNIFIED SPACED REPETITION\n// ============================================================================\n\n/**\n * @file unified-spaced-repetition.ts\n * @description Unified SM-2 spaced repetition with bidirectional support, 6-phase system, profile isolation, and legacy migration\n * @status ACTIVE\n * @features\n *   - Direction-aware SM-2 (bg-de, de-bg with difficulty multipliers)\n *   - 6-phase learning progression system integrated with SM-2\n *   - Profile-isolated data storage (dual profile support)\n *   - Automatic migration from non-profiled to profile-namespaced storage\n *   - Automatic migration from legacy schema to enhanced schema\n *   - Phase tracking and progression based on ease factor\n *   - Backward-compatible state loading\n *   - Export/import with schema version tracking\n * @version 3.1.0 - Added profile isolation\n * @updated November 2025\n */\n\n// Type for ProfileManager (will be properly typed when profile-manager.ts is created)\ninterface ProfileManager {\n  getNamespacedKey(key: string, profileId?: string | null): string;\n  getActiveProfileId(): string;\n}\n\nclass UnifiedSpacedRepetition {\n  private storagePrefix: string = 'bgde:';\n  private schemaVersion: number = 3; // Incremented for phase system\n  private difficultyMultipliers: Record<string, number> = {\n    'bg-de': 1.1, // Bulgarian to German\n    'de-bg': 1.2  // German to Bulgarian (harder)\n  };\n  private legacyKeyPattern: RegExp = /^bgde:review:/; // Legacy format (no profile namespace)\n  private enhancedKeyPattern: RegExp = /^bgde:review_(.+)_(bg-de|de-bg)$/; // Enhanced format (no profile namespace)\n  private profiledKeyPattern: RegExp = /^bgde:([^:]+):review_(.+)_(bg-de|de-bg)$/; // Profile-namespaced format\n\n  // Phase calculator integration\n  private phaseCalculator: PhaseCalculator | null;\n\n  // Profile manager integration for data isolation\n  private profileManager: ProfileManager | null;\n\n  // Track migration status\n  private migrationLog: MigrationLogEntry[] = [];\n\n  constructor(phaseCalculator: PhaseCalculator | null = null, profileManager: ProfileManager | null = null) {\n    this.phaseCalculator = phaseCalculator;\n    this.profileManager = profileManager;\n    this.init();\n  }\n\n  private init(): void {\n    const profileStatus = this.profileManager ? 'with profile isolation' : 'without profile isolation';\n    console.log(`[UnifiedSR] Initialized unified spaced repetition system v3.1 with 6-phase progression ${profileStatus}`);\n    this.detectLegacyData();\n    this.detectPhaselessReviews();\n  }\n\n  private detectPhaselessReviews(): void {\n    const phaselessKeys: string[] = [];\n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && this.enhancedKeyPattern.test(key)) {\n          const data = this.loadFromStorage(key);\n          if (data && data.phase === undefined) {\n            phaselessKeys.push(key);\n          }\n        }\n      }\n      if (phaselessKeys.length > 0) {\n        console.log(`[UnifiedSR] Found ${phaselessKeys.length} reviews without phase field. Auto-migration will occur on next load.`);\n      }\n    } catch (error) {\n      console.warn('[UnifiedSR] Failed to detect phaseless reviews:', error);\n    }\n  }\n\n  private detectLegacyData(): void {\n    const legacyKeys: string[] = [];\n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && this.legacyKeyPattern.test(key)) {\n          legacyKeys.push(key);\n        }\n      }\n      if (legacyKeys.length > 0) {\n        console.log(`[UnifiedSR] Found ${legacyKeys.length} legacy review states. Migration available.`);\n        this.migrationLog.push({\n          timestamp: Date.now(),\n          type: 'detection',\n          count: legacyKeys.length\n        });\n      }\n    } catch (error) {\n      console.warn('[UnifiedSR] Failed to detect legacy data:', error);\n    }\n  }\n\n  initReviewState(itemId: string, direction: 'bg-de' | 'de-bg' = 'bg-de'): ReviewState {\n    const now = Date.now();\n    const initialPhase = this.phaseCalculator ? this.phaseCalculator.calculatePhase(2.5, 0) : 1;\n    return {\n      itemId, direction,\n      schemaVersion: this.schemaVersion,\n      interval: 1, easeFactor: 2.5, repetitions: 0,\n      phase: initialPhase,\n      nextReview: now, lastReview: null,\n      totalReviews: 0, correctAnswers: 0, correctStreak: 0,\n      created: now, updated: now\n    };\n  }\n\n  scheduleNext(state: ReviewState, grade: number, direction: 'bg-de' | 'de-bg' | null = null): ReviewState {\n    if (!state || grade < 0 || grade > 5) {\n      throw new Error('Invalid review state or grade');\n    }\n    const now = Date.now();\n    const updatedState: ReviewState = { ...state };\n    const activeDirection = direction || state.direction || 'bg-de';\n\n    updatedState.lastReview = now;\n    updatedState.totalReviews = (updatedState.totalReviews || 0) + 1;\n    updatedState.updated = now;\n    updatedState.direction = activeDirection;\n    updatedState.schemaVersion = this.schemaVersion;\n\n    const isCorrect = grade >= 3;\n    const currentPhase = updatedState.phase || 1;\n\n    if (isCorrect) {\n      updatedState.correctAnswers = (updatedState.correctAnswers || 0) + 1;\n      updatedState.correctStreak = (updatedState.correctStreak || 0) + 1;\n      const newEF = Math.max(1.3, updatedState.easeFactor + (0.1 - (5 - grade) * (0.08 + (5 - grade) * 0.02)));\n      updatedState.easeFactor = Math.round(newEF * 100) / 100;\n\n      if (updatedState.repetitions === 0) {\n        updatedState.interval = 1;\n      } else if (updatedState.repetitions === 1) {\n        updatedState.interval = 6;\n      } else {\n        const multiplier = this.difficultyMultipliers[activeDirection] || 1;\n        updatedState.interval = Math.round(updatedState.interval * updatedState.easeFactor * multiplier);\n      }\n      updatedState.repetitions = (updatedState.repetitions || 0) + 1;\n    } else {\n      updatedState.correctStreak = 0;\n      updatedState.repetitions = 0;\n      updatedState.interval = 1;\n      updatedState.easeFactor = Math.max(1.3, updatedState.easeFactor - 0.2);\n    }\n\n    updatedState.nextReview = now + (updatedState.interval * 24 * 60 * 60 * 1000);\n\n    if (this.phaseCalculator) {\n      const newPhase = this.phaseCalculator.calculateNewPhase(currentPhase, grade, updatedState.easeFactor, updatedState.repetitions);\n      updatedState.phase = newPhase;\n      if (newPhase === 0) {\n        const phaseMultiplier = this.phaseCalculator.getPhaseIntervalMultiplier(0);\n        updatedState.interval = Math.round(updatedState.interval * phaseMultiplier);\n        updatedState.nextReview = now + (updatedState.interval * 24 * 60 * 60 * 1000);\n      }\n      if (newPhase !== currentPhase) {\n        console.log(`[UnifiedSR] Phase transition: ${currentPhase} → ${newPhase} (EF: ${updatedState.easeFactor})`);\n      }\n    } else {\n      updatedState.phase = currentPhase;\n    }\n    return updatedState;\n  }\n\n  loadState(itemId: string, direction: 'bg-de' | 'de-bg' = 'bg-de'): ReviewState {\n    const baseKey = `review_${itemId}_${direction}`;\n    const profiledKey = this.profileManager\n      ? this.profileManager.getNamespacedKey(baseKey)\n      : `${this.storagePrefix}${baseKey}`;\n\n    const profiledData = this.loadFromStorage(profiledKey);\n    if (profiledData) {\n      if (profiledData.phase === undefined && this.phaseCalculator) {\n        profiledData.phase = this.phaseCalculator.calculatePhase(profiledData.easeFactor || 2.5, profiledData.repetitions || 0);\n        profiledData.schemaVersion = this.schemaVersion;\n        this.saveState(profiledData);\n        console.log(`[UnifiedSR] Auto-migrated review ${itemId} to v3 with phase ${profiledData.phase}`);\n      }\n      return profiledData;\n    }\n\n    const enhancedKey = `${this.storagePrefix}review_${itemId}_${direction}`;\n    const enhancedData = this.loadFromStorage(enhancedKey);\n    if (enhancedData) {\n      if (this.profileManager) {\n        console.log(`[UnifiedSR] Migrating ${itemId} to profile-namespaced storage`);\n        enhancedData.schemaVersion = this.schemaVersion;\n        if (enhancedData.phase === undefined && this.phaseCalculator) {\n          enhancedData.phase = this.phaseCalculator.calculatePhase(enhancedData.easeFactor || 2.5, enhancedData.repetitions || 0);\n        }\n        this.saveState(enhancedData);\n        localStorage.removeItem(enhancedKey);\n      }\n      return enhancedData;\n    }\n\n    const legacyKey = `${this.storagePrefix}review:${itemId}`;\n    const legacyData = this.loadFromStorage(legacyKey);\n    if (legacyData) {\n      console.log(`[UnifiedSR] Migrating legacy state for ${itemId}`);\n      const migrated = this.migrateLegacyState(legacyData, itemId, direction);\n      this.saveState(migrated);\n      this.migrationLog.push({\n        timestamp: Date.now(),\n        type: 'migration',\n        itemId, direction,\n        from: 'legacy',\n        to: 'enhanced'\n      });\n      return migrated;\n    }\n\n    return this.initReviewState(itemId, direction);\n  }\n\n  private migrateLegacyState(legacyState: LegacyReviewState, itemId: string, direction: 'bg-de' | 'de-bg'): ReviewState {\n    const now = Date.now();\n    const easeFactor = legacyState.easinessFactor || legacyState.easeFactor || 2.5;\n    const repetitions = legacyState.repetitions || 0;\n    const phase = this.phaseCalculator ? this.phaseCalculator.calculatePhase(easeFactor, repetitions) : 1;\n    return {\n      itemId, direction,\n      schemaVersion: this.schemaVersion,\n      interval: legacyState.interval || 1,\n      easeFactor, repetitions, phase,\n      nextReview: legacyState.nextReviewDate ? new Date(legacyState.nextReviewDate).getTime() : now,\n      lastReview: legacyState.lastReviewDate ? new Date(legacyState.lastReviewDate).getTime() : null,\n      totalReviews: legacyState.totalReviews || 0,\n      correctAnswers: legacyState.correctAnswers || 0,\n      correctStreak: legacyState.streak || legacyState.correctStreak || 0,\n      created: legacyState.created ? new Date(legacyState.created).getTime() : now,\n      updated: now\n    };\n  }\n\n  private loadFromStorage(key: string): ReviewState | null {\n    try {\n      const data = localStorage.getItem(key);\n      if (!data) return null;\n      const parsed = JSON.parse(data);\n      if (typeof parsed === 'object' && parsed !== null) {\n        return parsed as ReviewState;\n      }\n      return null;\n    } catch (error) {\n      console.warn(`[UnifiedSR] Failed to load state from ${key}:`, error);\n      return null;\n    }\n  }\n\n  saveState(state: ReviewState): boolean {\n    if (!state || !state.itemId || !state.direction) {\n      console.warn('[UnifiedSR] Cannot save invalid state:', state);\n      return false;\n    }\n    try {\n      const baseKey = `review_${state.itemId}_${state.direction}`;\n      const key = this.profileManager\n        ? this.profileManager.getNamespacedKey(baseKey)\n        : `${this.storagePrefix}${baseKey}`;\n      const data = JSON.stringify(state);\n      localStorage.setItem(key, data);\n      return true;\n    } catch (error) {\n      console.error('[UnifiedSR] Failed to save state:', error);\n      if (error instanceof Error && error.name === 'QuotaExceededError') {\n        console.warn('[UnifiedSR] Storage quota exceeded. Consider cleanup.');\n      }\n      return false;\n    }\n  }\n\n  getDueItems(direction: 'bg-de' | 'de-bg' | null = null): ReviewState[] {\n    const now = Date.now();\n    const dueStates: ReviewState[] = [];\n    const currentProfileId = this.profileManager ? this.profileManager.getActiveProfileId() : null;\n\n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && this.profiledKeyPattern.test(key)) {\n          const match = key.match(this.profiledKeyPattern);\n          const keyProfileId = match ? match[1] : null;\n          if (currentProfileId && keyProfileId !== currentProfileId) {\n            continue;\n          }\n          const state = this.loadFromStorage(key);\n          if (state && state.nextReview <= now && (!direction || state.direction === direction)) {\n            dueStates.push(state);\n          }\n        } else if (!this.profileManager && key && this.enhancedKeyPattern.test(key)) {\n          const state = this.loadFromStorage(key);\n          if (state && state.nextReview <= now && (!direction || state.direction === direction)) {\n            dueStates.push(state);\n          }\n        }\n      }\n    } catch (error) {\n      console.error('[UnifiedSR] Failed to get due items:', error);\n    }\n    return dueStates;\n  }\n\n  getStats(direction: 'bg-de' | 'de-bg' | null = null): DueItemsStats {\n    let total = 0, due = 0, totalEF = 0, totalAccuracy = 0, itemsWithReviews = 0;\n    const currentProfileId = this.profileManager ? this.profileManager.getActiveProfileId() : null;\n\n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && this.profiledKeyPattern.test(key)) {\n          const match = key.match(this.profiledKeyPattern);\n          const keyProfileId = match ? match[1] : null;\n          if (currentProfileId && keyProfileId !== currentProfileId) {\n            continue;\n          }\n          const state = this.loadFromStorage(key);\n          if (state && (!direction || state.direction === direction)) {\n            total++;\n            totalEF += state.easeFactor || 2.5;\n            if (state.nextReview <= Date.now()) {\n              due++;\n            }\n            if (state.totalReviews > 0) {\n              itemsWithReviews++;\n              totalAccuracy += (state.correctAnswers / state.totalReviews) * 100;\n            }\n          }\n        } else if (!this.profileManager && key && this.enhancedKeyPattern.test(key)) {\n          const state = this.loadFromStorage(key);\n          if (state && (!direction || state.direction === direction)) {\n            total++;\n            totalEF += state.easeFactor || 2.5;\n            if (state.nextReview <= Date.now()) {\n              due++;\n            }\n            if (state.totalReviews > 0) {\n              itemsWithReviews++;\n              totalAccuracy += (state.correctAnswers / state.totalReviews) * 100;\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error('[UnifiedSR] Failed to calculate stats:', error);\n    }\n    return {\n      total, due,\n      avgEaseFactor: total > 0 ? Math.round((totalEF / total) * 100) / 100 : 2.5,\n      avgAccuracy: itemsWithReviews > 0 ? Math.round(totalAccuracy / itemsWithReviews) : 0,\n      direction: direction || 'all'\n    };\n  }\n\n  migrateAllLegacy(defaultDirection: 'bg-de' | 'de-bg' = 'bg-de'): MigrationResults {\n    const results: MigrationResults = { migrated: 0, failed: 0, skipped: 0 };\n    try {\n      const legacyKeys: string[] = [];\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && this.legacyKeyPattern.test(key)) {\n          legacyKeys.push(key);\n        }\n      }\n      for (const legacyKey of legacyKeys) {\n        const itemId = legacyKey.replace(this.legacyKeyPattern, '');\n        const legacyData = this.loadFromStorage(legacyKey);\n        if (!legacyData) {\n          results.failed++;\n          continue;\n        }\n        const enhancedKey = `${this.storagePrefix}review_${itemId}_${defaultDirection}`;\n        if (localStorage.getItem(enhancedKey)) {\n          results.skipped++;\n          continue;\n        }\n        const migrated = this.migrateLegacyState(legacyData, itemId, defaultDirection);\n        if (this.saveState(migrated)) {\n          results.migrated++;\n          console.log(`[UnifiedSR] Migrated ${itemId} to enhanced schema`);\n        } else {\n          results.failed++;\n        }\n      }\n      this.migrationLog.push({ timestamp: Date.now(), type: 'batch_migration', results });\n    } catch (error) {\n      console.error('[UnifiedSR] Batch migration failed:', error);\n    }\n    return results;\n  }\n\n  exportData(): string {\n    const exportData: ExportData = { version: this.schemaVersion, exported: Date.now(), states: {} };\n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && this.enhancedKeyPattern.test(key)) {\n          const state = this.loadFromStorage(key);\n          if (state) {\n            exportData.states[key] = state;\n          }\n        }\n      }\n      return JSON.stringify(exportData, null, 2);\n    } catch (error) {\n      console.error('[UnifiedSR] Export failed:', error);\n      return '{}';\n    }\n  }\n\n  importData(jsonData: string): ImportResults {\n    const results: ImportResults = { imported: 0, skipped: 0, failed: 0 };\n    try {\n      const data = JSON.parse(jsonData) as ExportData;\n      if (!data.states || typeof data.states !== 'object') {\n        throw new Error('Invalid export format');\n      }\n      for (const [, state] of Object.entries(data.states)) {\n        if (this.validateState(state)) {\n          if (this.saveState(state)) {\n            results.imported++;\n          } else {\n            results.failed++;\n          }\n        } else {\n          results.skipped++;\n        }\n      }\n      console.log('[UnifiedSR] Import complete:', results);\n    } catch (error) {\n      console.error('[UnifiedSR] Import failed:', error);\n      results.failed++;\n    }\n    return results;\n  }\n\n  private validateState(state: ReviewState): boolean {\n    return !!(\n      state && typeof state === 'object' &&\n      state.itemId && state.direction &&\n      typeof state.easeFactor === 'number' &&\n      typeof state.interval === 'number'\n    );\n  }\n\n  getMigrationLog(): MigrationLogEntry[] {\n    return [...this.migrationLog];\n  }\n}\n\n// ============================================================================\n// INITIALIZATION\n// ============================================================================\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', () => {\n    (window as any).phaseCalculator = new PhaseCalculator();\n    (window as any).unifiedSpacedRepetition = new UnifiedSpacedRepetition(\n      (window as any).phaseCalculator,\n      (window as any).profileManager // Pass profileManager for data isolation\n    );\n    console.log('[SpacedRepetitionSystem] Initialized with 6-phase progression and profile isolation');\n  });\n} else {\n  (window as any).phaseCalculator = new PhaseCalculator();\n  (window as any).unifiedSpacedRepetition = new UnifiedSpacedRepetition(\n    (window as any).phaseCalculator,\n    (window as any).profileManager // Pass profileManager for data isolation\n  );\n  console.log('[SpacedRepetitionSystem] Initialized with 6-phase progression and profile isolation');\n}\n\nexport { PhaseCalculator, UnifiedSpacedRepetition };","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/speech-recognition.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[936,939],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[936,939],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[977,980],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[977,980],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1024,1027],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1024,1027],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1068,1071],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1068,1071],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1662,1665],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1662,1665],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":75,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2102,2105],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2102,2105],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2178,2181],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2178,2181],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2394,2397],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2394,2397],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Lightweight wrapper around the Web Speech API for pronunciation practice.\n * Provides a minimal event-driven interface so other modules can trigger\n * recognition without dealing with browser quirks.\n */\n\ninterface SpeechRecognitionConstructor {\n  new(): SpeechRecognition;\n}\n\ninterface SpeechRecognition extends EventTarget {\n  lang: string;\n  interimResults: boolean;\n  maxAlternatives: number;\n  start(): void;\n  stop(): void;\n  abort(): void;\n  addEventListener(type: string, listener: EventListenerOrEventListenerObject): void;\n}\n\ninterface SpeechPracticeHandlers {\n  onStatus?: (status: 'idle' | 'listening') => void;\n  onResult?: (transcript: string) => void;\n  onError?: (message: string) => void;\n}\n\ninterface SpeechPracticeOptions {\n  lang?: string;\n}\n\nconst getRecognitionConstructor = (): SpeechRecognitionConstructor | null => {\n  if (typeof window === 'undefined') {\n    return null;\n  }\n\n  return (\n    (window as any).SpeechRecognition ||\n    (window as any).webkitSpeechRecognition ||\n    (window as any).mozSpeechRecognition ||\n    (window as any).msSpeechRecognition ||\n    null\n  );\n};\n\nexport class SpeechPractice {\n  private handlers: SpeechPracticeHandlers;\n  private recognition: SpeechRecognition;\n  private isListening = false;\n\n  /**\n   * @param handlers - Event handlers for speech recognition\n   */\n  constructor(handlers: SpeechPracticeHandlers = {}) {\n    const Recognition = getRecognitionConstructor();\n    if (!Recognition) {\n      throw new Error('Speech recognition not supported in this browser');\n    }\n\n    this.handlers = handlers;\n    this.recognition = new Recognition();\n    this.recognition.lang = (handlers as any).lang || 'bg-BG';\n    this.recognition.interimResults = false;\n    this.recognition.maxAlternatives = 1;\n\n    this.recognition.addEventListener('start', () => {\n      this.isListening = true;\n      this.handlers.onStatus?.('listening');\n    });\n\n    this.recognition.addEventListener('end', () => {\n      this.isListening = false;\n      this.handlers.onStatus?.('idle');\n    });\n\n    this.recognition.addEventListener('result', (event: any) => {\n      const transcript = [...event.results]\n        .map((result: any) => result[0]?.transcript ?? '')\n        .join(' ')\n        .trim();\n\n      if (transcript) {\n        this.handlers.onResult?.(transcript);\n      }\n    });\n\n    this.recognition.addEventListener('error', (event: any) => {\n      this.handlers.onError?.(event.error ?? 'Speech recognition error');\n    });\n  }\n\n  /**\n   * Starts listening for speech.\n   * @param options - Configuration options\n   */\n  start(options: SpeechPracticeOptions = {}): void {\n    if (options.lang) {\n      this.recognition.lang = options.lang;\n    }\n\n    if (this.isListening) {\n      return;\n    }\n\n    try {\n      this.recognition.start();\n    } catch (error) {\n      // Chrome throws if start is called back-to-back; surface as friendly message.\n      this.handlers.onError?.(error instanceof Error ? error.message : 'Unable to start speech recognition');\n    }\n  }\n\n  stop(): void {\n    if (!this.isListening) {\n      return;\n    }\n\n    try {\n      this.recognition.stop();\n    } catch (error) {\n      this.handlers.onError?.(error instanceof Error ? error.message : 'Unable to stop speech recognition');\n    }\n  }\n\n  abort(): void {\n    if (!this.isListening) {\n      return;\n    }\n    try {\n      this.recognition.abort();\n    } catch {\n      // ignore – abort is best effort\n    }\n  }\n\n  destroy(): void {\n    this.abort();\n    this.handlers = {};\n  }\n\n  static isSupported(): boolean {\n    return Boolean(getRecognitionConstructor());\n  }\n}\n\nexport default SpeechPractice;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/tts-init.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'TTSOptions' is defined but never used.","line":6,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":6,"endColumn":21},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over an async IIFE.","line":16,"column":2,"nodeType":"CallExpression","messageId":"iife","endLine":16,"endColumn":30},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[480,483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[480,483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[642,645],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[642,645],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[997,1000],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[997,1000],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1036,1039],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1036,1039],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Text-to-Speech Initialization Script\n * Dynamically loads the TextToSpeech module and makes it globally available\n */\n\ninterface TTSOptions {\n  enabled: boolean;\n}\n\ninterface TTSToggleEvent extends CustomEvent {\n  detail: {\n    enabled: boolean;\n  };\n}\n\n(async function initializeTTS(): Promise<void> {\n  try {\n    // Import the TextToSpeech module\n    const { TextToSpeech } = await import('./modules/text-to-speech.js');\n\n    // Make it globally available\n    (window as any).TextToSpeech = TextToSpeech;\n\n    // Initialize a global TTS instance if speechSynthesis is supported\n    if (TextToSpeech.isSupported()) {\n      (window as any).globalTTS = new TextToSpeech({\n        enabled: localStorage.getItem('tts-enabled') !== 'false'\n      });\n\n      console.log('[TTS] Initialized successfully');\n\n      // Listen for TTS enabled/disabled changes\n      window.addEventListener('tts-toggle', (event: Event) => {\n        const customEvent = event as TTSToggleEvent;\n        if ((window as any).globalTTS) {\n          (window as any).globalTTS.enabled = customEvent.detail.enabled;\n        }\n      });\n    } else {\n      console.log('[TTS] Speech synthesis not supported in this browser');\n    }\n  } catch (error) {\n    console.error('[TTS] Failed to initialize:', error);\n  }\n})();","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":213,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":213,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4562,4565],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4562,4565],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":214,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":214,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4644,4647],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4644,4647],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":216,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":216,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4724,4727],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4724,4727],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":217,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4753,4756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4753,4756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":237,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":237,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5490,5493],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5490,5493],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":238,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":238,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5524,5527],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5524,5527],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":239,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":239,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5552,5555],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5552,5555],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":240,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":240,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5580,5583],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5580,5583],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":241,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":241,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5614,5617],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5614,5617],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":242,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5640,5643],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5640,5643],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":243,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5673,5676],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5673,5676],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":244,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":244,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5701,5704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5701,5704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":264,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6251,6254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6251,6254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":13,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Type definitions for BulgarianGermanLearningApp\n * @file types.ts\n * @description TypeScript interfaces and types for the application\n *\n * This file serves as both a global declaration file and exportable types.\n */\n\n// Exportable interfaces for module usage\nexport interface ReviewState {\n  itemId: string;\n  direction: 'bg-de' | 'de-bg';\n  schemaVersion: number;\n  interval: number;\n  easeFactor: number;\n  repetitions: number;\n  phase: number;\n  nextReview: number;\n  lastReview: number | null;\n  totalReviews: number;\n  correctAnswers: number;\n  correctStreak: number;\n  created: number;\n  updated: number;\n}\n\n/**\n * Legacy review state (for migration purposes)\n */\nexport interface LegacyReviewState {\n  interval?: number;\n  easeFactor?: number;\n  easinessFactor?: number;\n  repetitions?: number;\n  nextReviewDate?: string | number;\n  lastReviewDate?: string | number;\n  totalReviews?: number;\n  correctAnswers?: number;\n  streak?: number;\n  correctStreak?: number;\n  created?: string | number;\n}\n\n/**\n * Profile interface for dual-profile system\n */\nexport interface Profile {\n  id: string;\n  name: string;\n  displayName: string;\n  direction: 'bg-de' | 'de-bg';\n  sourceLanguage: 'bg' | 'de';\n  targetLanguage: 'bg' | 'de';\n  createdAt: string;\n  lastAccessedAt: string;\n  statistics: ProfileStatistics;\n  settings: ProfileSettings;\n  customVocabulary: CustomVocabularyEntry[];\n  customTags: string[];\n  customCategories: string[];\n}\n\n/**\n * Profile statistics\n */\nexport interface ProfileStatistics {\n  totalReviews: number;\n  totalCorrect: number;\n  totalTime: number;\n  streak: number;\n}\n\n/**\n * Profile settings\n */\nexport interface ProfileSettings {\n  dailyGoal: number;\n  autoPlayAudio: boolean;\n  voiceGender: 'male' | 'female';\n}\n\n/**\n * Custom vocabulary entry\n */\nexport interface CustomVocabularyEntry {\n  id: string;\n  bulgarian: string;\n  german: string;\n  category?: string;\n  level?: string;\n  examples?: string[];\n  notes?: string;\n  etymology?: string;\n  cultural_note?: string;\n  addedAt: string;\n  source: 'custom';\n  enrichmentStatus: 'complete' | 'partial' | 'minimal';\n}\n\n/**\n * Phase details for 6-phase learning system\n */\nexport interface PhaseDetails {\n  min: number;\n  max: number;\n  name: string;\n  color: string;\n}\n\n/**\n * Migration log entry\n */\nexport interface MigrationLogEntry {\n  timestamp: number;\n  type: 'detection' | 'migration' | 'batch_migration';\n  count?: number;\n  itemId?: string;\n  direction?: 'bg-de' | 'de-bg';\n  from?: string;\n  to?: string;\n  results?: MigrationResults;\n}\n\n/**\n * Migration results\n */\nexport interface MigrationResults {\n  migrated: number;\n  failed: number;\n  skipped: number;\n}\n\n/**\n * Export data structure\n */\nexport interface ExportData {\n  version: number;\n  exported: number;\n  states: Record<string, ReviewState>;\n}\n\n/**\n * Import results\n */\nexport interface ImportResults {\n  imported: number;\n  skipped: number;\n  failed: number;\n}\n\n/**\n * Statistics for due items\n */\nexport interface DueItemsStats {\n  total: number;\n  due: number;\n  avgEaseFactor: number;\n  avgAccuracy: number;\n  direction: 'bg-de' | 'de-bg' | 'all';\n}\n\n/**\n * Phase statistics\n */\nexport interface PhaseStatistics {\n  learned: { count: number; percentage: string };\n  phase1: { count: number; percentage: string };\n  phase2: { count: number; percentage: string };\n  phase3: { count: number; percentage: string };\n  phase4: { count: number; percentage: string };\n  phase5: { count: number; percentage: string };\n  phase6: { count: number; percentage: string };\n  total: number;\n}\n\n/**\n * Profile comparison data\n */\nexport interface ProfileComparison {\n  german_learner: ProfileComparisonItem;\n  bulgarian_learner: ProfileComparisonItem;\n}\n\n/**\n * Profile comparison item\n */\nexport interface ProfileComparisonItem {\n  name: string;\n  totalReviews: number;\n  accuracy: string;\n  streak: number;\n  lastAccessed: string;\n}\n\n/**\n * Global namespace for BulgarianGermanLearningApp\n */\ndeclare global {\n  interface Window {\n    BgDeApp: {\n      init: () => void;\n      initNavigation: () => void;\n      initLanguageToggle: () => void;\n      initPerformanceMonitor: () => void;\n      initVocabulary: () => void;\n      initGrammar: () => void;\n      initPracticeSession: () => void;\n      initProgressDashboard: () => void;\n      updateLanguageText: (lang: string) => void;\n      startPractice: (level: string, category: string) => void;\n      initChart: (container: HTMLElement, chartType: string) => void;\n      handleError: (error: Error, context: string) => void;\n      debounce: <T extends (...args: any[]) => void>(func: T, wait: number) => T;\n      throttle: <T extends (...args: any[]) => void>(func: T, limit: number) => T;\n      vocabulary: {\n        data: any[];\n        filteredData: any[];\n        selectedWords: Set<string>;\n        filters: {\n          level: string;\n          category: string;\n          search: string;\n        };\n      };\n      loadVocabularyData: () => void;\n      bindVocabularyEvents: () => void;\n      renderVocabulary: () => void;\n      updateVocabularyStats: () => void;\n      applyVocabularyFilters: () => void;\n      clearAllVocabularyFilters: () => void;\n      bindCardSelectionEvents: () => void;\n      toggleWordSelection: (word: string, cardElement: HTMLElement) => void;\n      flipVocabularyCard: (cardElement: HTMLElement) => void;\n      startPracticeWithSelected: () => void;\n      shuffleArray: <T>(array: T[]) => T[];\n    };\n    gtag: (command: string, eventName: string, params?: any) => void;\n    profileManager: any;\n    profileSwitcherUI: any;\n    progressDashboard: any;\n    unifiedSpacedRepetition: any;\n    languageToggle?: any;\n    UnifiedPracticeSession: any;\n    VocabularyAdapter: any; // Revert to any since VocabularyAdapter is not in scope here\n  }\n\n  // Extend DOM interfaces for custom properties\n  interface Element {\n    dataset: DOMStringMap;\n    style: CSSStyleDeclaration;\n  }\n\n  interface HTMLElement {\n    focus(): void;\n  }\n\n  // Extend DocumentEventMap for custom events\n  interface DocumentEventMap {\n    'language-direction-changed': CustomEvent<{ direction: string }>;\n  }\n\n  // Extend WindowEventMap for custom events\n  interface WindowEventMap {\n    'profile-switched': CustomEvent<{ profileId: string; profile: any; previousProfileId: string }>;\n  }\n\n  // Performance memory interface (non-standard but available in some browsers)\n  interface Performance {\n    memory?: {\n      usedJSHeapSize: number;\n      totalJSHeapSize: number;\n      jsHeapSizeLimit: number;\n    };\n  }\n}\n\n// Export the global declarations\nexport {};","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/unified-practice-session.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1987,1990],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1987,1990],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":78,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2013,2016],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2013,2016],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2046,2049],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2046,2049],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"unicorn/prefer-query-selector","severity":2,"message":"Prefer `.querySelector()` over `.getElementById()`.","line":220,"column":28,"nodeType":"Identifier","messageId":"prefer-query-selector","endLine":220,"endColumn":42},{"ruleId":"unicorn/prefer-query-selector","severity":2,"message":"Prefer `.querySelector()` over `.getElementById()`.","line":745,"column":25,"nodeType":"Identifier","messageId":"prefer-query-selector","endLine":745,"endColumn":39},{"ruleId":"unicorn/prefer-query-selector","severity":2,"message":"Prefer `.querySelector()` over `.getElementById()`.","line":753,"column":25,"nodeType":"Identifier","messageId":"prefer-query-selector","endLine":753,"endColumn":39}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file unified-practice-session.ts\n * @description Consolidated practice session with bidirectional support\n * @status ACTIVE\n * @replaces enhanced-practice-session.js, practice.js\n * @dependencies unified-spaced-repetition.ts (loaded globally)\n * @features\n *   - Direction-aware flashcards (respects language toggle)\n *   - Directional notes (notes_bg_to_de, notes_de_to_bg)\n *   - Keyboard shortcuts (Space/Enter flip, 1-5 grade)\n *   - Session statistics and progress tracking\n *   - Unified SM-2 integration with automatic migration\n * @version 2.0.1\n * @updated October 2025\n */\n\n// Type definitions for vocabulary items and session state\ninterface VocabularyItem {\n  id: string;\n  word: string;\n  translation: string;\n  level?: string;\n  category?: string;\n  difficulty?: number;\n  frequency?: number;\n  notes?: string;\n  notes_bg_to_de?: string;\n  notes_de_to_bg?: string;\n  etymology?: string;\n  cultural_note?: string;\n  linguistic_note?: string;\n  audio_url?: string;\n  examples?: Array<{\n    sentence: string;\n    translation: string;\n    context: string;\n  }>;\n}\n\ninterface SessionStats {\n  correct: number;\n  total: number;\n  startTime: number;\n  mistakes: Array<{\n    id: string;\n    word: string;\n    translation: string;\n  }>;\n}\n\ninterface PracticeSessionOptions {\n  sessionLength?: number;\n  enableAudio?: boolean;\n}\n\ninterface SpacedRepetitionState {\n  itemId: string;\n  direction: string;\n  interval: number;\n  repetition: number;\n  easeFactor: number;\n  nextReview: number;\n}\n\ninterface SpacedRepetitionSystem {\n  getDueItems(direction: string): SpacedRepetitionState[];\n  loadState(itemId: string, direction: string): SpacedRepetitionState;\n  scheduleNext(state: SpacedRepetitionState, grade: number, direction: string): SpacedRepetitionState;\n  saveState(state: SpacedRepetitionState): void;\n}\n\n// LanguageToggle interface removed as it's not used\n\n// Global declarations for window objects\ndeclare global {\n  interface Window {\n    unifiedSpacedRepetition: any;\n    languageToggle?: any;\n    UnifiedPracticeSession: any;\n  }\n}\n\nclass UnifiedPracticeSession {\n  private vocabularyData: VocabularyItem[] = [];\n  private sessionCards: VocabularyItem[] = [];\n  private currentIndex: number = 0;\n  private currentCard: VocabularyItem | null = null;\n  private isFlipped: boolean = false;\n  private currentDirection: string = 'bg-de';\n  \n  private sessionStats: SessionStats = {\n    correct: 0,\n    total: 0,\n    startTime: Date.now(),\n    mistakes: []\n  };\n  \n  // Session configuration\n  private sessionLength: number;\n  private enableAudio: boolean;\n  \n  // Reference to spaced repetition system (from global)\n  private spacedRepetition: SpacedRepetitionSystem;\n\n  constructor(options: PracticeSessionOptions = {}) {\n    this.sessionLength = options.sessionLength || 20;\n    this.enableAudio = options.enableAudio === undefined ? false : options.enableAudio;\n    \n    // Reference to spaced repetition system (from global)\n    this.spacedRepetition = window.unifiedSpacedRepetition;\n    \n    this.init();\n  }\n\n  private init(): void {\n    console.log('[UnifiedPractice] Initializing practice session v2.0');\n    \n    this.loadData();\n    \n    if (!this.vocabularyData || this.vocabularyData.length === 0) {\n      console.error('[UnifiedPractice] No vocabulary data available');\n      this.showError('No vocabulary data available. Please check your data files.');\n      return;\n    }\n    \n    console.log(`[UnifiedPractice] Loaded ${this.vocabularyData.length} vocabulary items`);\n    \n    this.bindEvents();\n    this.startSession();\n  }\n\n  private loadData(): void {\n    // Load vocabulary from embedded JSON script tag\n    const vocabScript = document.querySelector('#practice-vocabulary-data');\n    if (!vocabScript) {\n      console.error('[UnifiedPractice] Vocabulary data script not found');\n      return;\n    }\n    \n    try {\n      const data = JSON.parse(vocabScript.textContent) as VocabularyItem[];\n      \n      if (!Array.isArray(data) || data.length === 0) {\n        console.error('[UnifiedPractice] Invalid vocabulary data');\n        return;\n      }\n      \n      this.vocabularyData = data;\n      console.log('[UnifiedPractice] Successfully loaded vocabulary data');\n    } catch (error) {\n      console.error('[UnifiedPractice] Failed to parse vocabulary data:', error);\n    }\n    \n    // Get current language direction\n    this.currentDirection = this.getLanguageDirection();\n    console.log(`[UnifiedPractice] Current direction: ${this.currentDirection}`);\n  }\n\n  private getLanguageDirection(): string {\n    // Try language toggle first\n    if (window.languageToggle && typeof window.languageToggle.getDirection === 'function') {\n      return window.languageToggle.getDirection();\n    }\n    \n    // Fallback to localStorage\n    const stored = localStorage.getItem('bgde:language-direction') || \n                   localStorage.getItem('bgde:learning_direction');\n    \n    return this.normalizeDirection(stored) || 'de-bg';\n  }\n\n  private normalizeDirection(value: string | null): string | null {\n    if (!value) {\n      return null;\n    }\n    \n    const normalized = value.toString().toLowerCase();\n    \n    if (normalized === 'bg-de' || normalized === 'bg_to_de') {\n      return 'bg-de';\n    }\n    if (normalized === 'de-bg' || normalized === 'de_to_bg') {\n      return 'de-bg';\n    }\n    \n    return normalized === 'bg-de' || normalized === 'de-bg' ? normalized : null;\n  }\n\n  private bindEvents(): void {\n    // Flashcard click to flip\n    const flashcard = document.querySelector('#flashcard');\n    if (flashcard) {\n      flashcard.addEventListener('click', (e: Event) => {\n        if ((e.target as HTMLElement).tagName === 'BUTTON' || (e.target as HTMLElement).closest('button')) {\n          return;\n        }\n        if (!this.isFlipped) {\n          this.showAnswer();\n        }\n      });\n      flashcard.style.cursor = 'pointer';\n    }\n    \n    // Show answer button\n    const showAnswerBtn = document.querySelector('#show-answer');\n    if (showAnswerBtn) {\n      showAnswerBtn.addEventListener('click', () => this.showAnswer());\n    }\n    \n    // Grade buttons (1-5 scale)\n    const gradeButtons: Record<string, number> = {\n      'incorrect-btn': 1,\n      'hard-btn': 2,\n      'good-btn': 3,\n      'easy-btn': 4,\n      'perfect-btn': 5\n    };\n    \n    for (const [btnId, grade] of Object.entries(gradeButtons)) {\n      const btn = document.getElementById(btnId);\n      if (btn) {\n        btn.addEventListener('click', () => this.gradeCard(grade));\n      }\n    }\n    \n    // Legacy two-button support\n    const correctBtn = document.querySelector('#correct-btn');\n    const incorrectBtn = document.querySelector('#incorrect-btn');\n    \n    if (correctBtn) {\n      correctBtn.addEventListener('click', () => this.gradeCard(4));\n    }\n    if (incorrectBtn) {\n      incorrectBtn.addEventListener('click', () => this.gradeCard(1));\n    }\n    \n    // Keyboard shortcuts\n    document.addEventListener('keydown', (e: KeyboardEvent) => {\n      if ((e.target as HTMLElement).tagName === 'INPUT' || (e.target as HTMLElement).tagName === 'TEXTAREA') {\n        return;\n      }\n      \n      switch(e.key) {\n      case ' ':\n      case 'Enter': {\n        e.preventDefault();\n        if (!this.isFlipped) {\n          this.showAnswer();\n        }\n        break;\n      }\n      case '1': {\n        e.preventDefault();\n        if (this.isFlipped) {\n          this.gradeCard(1);\n        }\n        break;\n      }\n      case '2': {\n        e.preventDefault();\n        if (this.isFlipped) {\n          this.gradeCard(2);\n        }\n        break;\n      }\n      case '3': {\n        e.preventDefault();\n        if (this.isFlipped) {\n          this.gradeCard(3);\n        }\n        break;\n      }\n      case '4': {\n        e.preventDefault();\n        if (this.isFlipped) {\n          this.gradeCard(4);\n        }\n        break;\n      }\n      case '5': {\n        e.preventDefault();\n        if (this.isFlipped) {\n          this.gradeCard(5);\n        }\n        break;\n      }\n      }\n    });\n    \n    // Listen for language direction changes\n    document.addEventListener('language-direction-changed', (e: CustomEvent) => {\n      this.currentDirection = e.detail.direction;\n      this.updateCurrentCard();\n      console.log('[UnifiedPractice] Direction changed to:', this.currentDirection);\n    });\n\n    // End session button\n    const endSessionBtn = document.querySelector('#end-session');\n    if (endSessionBtn) {\n      endSessionBtn.addEventListener('click', () => {\n        if (confirm('Sitzung beenden? / Край на сесията?')) {\n          this.completeSession();\n        }\n      });\n    }\n\n    // New session button (restart)\n    const newSessionBtn = document.querySelector('#new-session');\n    if (newSessionBtn) {\n      newSessionBtn.addEventListener('click', () => {\n        console.log('[UnifiedPractice] Starting new session');\n        this.currentIndex = 0;\n        this.sessionStats = {\n          correct: 0,\n          total: 0,\n          startTime: Date.now(),\n          mistakes: []\n        };\n        this.startSession();\n      });\n    }\n\n    // Review mistakes button\n    const reviewMistakesBtn = document.querySelector('#review-mistakes');\n    if (reviewMistakesBtn) {\n      reviewMistakesBtn.addEventListener('click', () => {\n        console.log('[UnifiedPractice] Reviewing mistakes');\n        if (this.sessionStats.mistakes.length > 0) {\n          // Filter to only show mistakes for next session\n          const mistakeIds = new Set(this.sessionStats.mistakes.map(m => m.id));\n          this.sessionCards = this.sessionCards.filter(card => mistakeIds.has(card.id));\n          this.currentIndex = 0;\n          this.sessionStats = {\n            correct: 0,\n            total: 0,\n            startTime: Date.now(),\n            mistakes: []\n          };\n          this.showScreen('practice-session');\n          this.hideScreen('session-complete');\n          this.showCurrentCard();\n        }\n      });\n    }\n\n    // Settings panel toggle\n    const settingsToggle = document.querySelector('#settings-toggle');\n    const settingsPanel = document.querySelector('#settings-panel');\n    if (settingsToggle && settingsPanel) {\n      settingsToggle.addEventListener('click', () => {\n        settingsPanel.classList.toggle('hidden');\n      });\n    }\n  }\n\n  private startSession(): void {\n    console.log('[UnifiedPractice] Starting practice session');\n    \n    // Hide loading states\n    this.hideScreen('loading-state');\n    this.hideScreen('no-items-state');\n    this.hideScreen('session-complete');\n    \n    this.prepareSessionCards();\n    \n    if (this.sessionCards.length === 0) {\n      this.showNoItemsState();\n      return;\n    }\n    \n    this.showScreen('practice-session');\n    this.showCurrentCard();\n  }\n\n  private prepareSessionCards(): void {\n    let cards: VocabularyItem[] = [];\n\n    // Priority 1: Check for user-selected vocabulary\n    const selectionJson = localStorage.getItem('bgde:practice_selection');\n    if (selectionJson) {\n      try {\n        const selectedWords = JSON.parse(selectionJson) as string[];\n\n        if (Array.isArray(selectedWords) && selectedWords.length > 0) {\n          // Filter vocabulary to only include selected words\n          cards = this.vocabularyData.filter(item =>\n            selectedWords.includes(item.word) || selectedWords.includes(item.id)\n          );\n\n          console.log(`[UnifiedPractice] Using ${cards.length} user-selected items`);\n\n          // Clean up selection after loading\n          localStorage.removeItem('bgde:practice_selection');\n\n          // If we found the selected cards, use them and skip other checks\n          if (cards.length > 0) {\n            this.sessionCards = cards;\n            this.currentIndex = 0;\n            return;\n          }\n        }\n      } catch (error) {\n        console.warn('[UnifiedPractice] Failed to parse practice selection:', error);\n        localStorage.removeItem('bgde:practice_selection'); // Clean up bad data\n      }\n    }\n\n    // Priority 2: Get due items from spaced repetition\n    const dueItems = this.spacedRepetition.getDueItems(this.currentDirection);\n\n    if (dueItems && dueItems.length > 0) {\n      // Map due items to vocabulary data\n      cards = dueItems.map(state => {\n        const item = this.vocabularyData.find(item => item.id === state.itemId);\n        return item || null;\n      }).filter((item): item is VocabularyItem => item !== null);\n\n      console.log(`[UnifiedPractice] Found ${cards.length} due items for review`);\n    }\n\n    // Priority 3: If no selection or due items, use random selection with better randomization\n    if (cards.length === 0) {\n      // Apply difficulty filter if selected\n      const difficultyFilter = localStorage.getItem('bgde:practice_difficulty');\n      let filteredVocabulary = [...this.vocabularyData];\n\n      if (difficultyFilter && difficultyFilter !== '') {\n        filteredVocabulary = filteredVocabulary.filter(item => item.level === difficultyFilter);\n        console.log(`[UnifiedPractice] Filtered to ${filteredVocabulary.length} items for level ${difficultyFilter}`);\n      }\n\n      // Ensure we have enough vocabulary\n      if (filteredVocabulary.length === 0) {\n        filteredVocabulary = [...this.vocabularyData];\n      }\n\n      // Shuffle with better randomization (multiple passes for better distribution)\n      const shuffled = this.shuffleArray(filteredVocabulary);\n      cards = shuffled.slice(0, Math.min(this.sessionLength, shuffled.length));\n\n      console.log(`[UnifiedPractice] No due items, using ${cards.length} random cards from ${filteredVocabulary.length} total`);\n    }\n\n    this.sessionCards = cards;\n    this.currentIndex = 0;\n  }\n\n  private shuffleArray<T>(array: T[]): T[] {\n    const result = [...array];\n    for (let i = result.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      const temp = result[i]!;\n      result[i] = result[j]!;\n      result[j] = temp;\n    }\n    return result;\n  }\n\n  private showCurrentCard(): void {\n    if (this.currentIndex >= this.sessionCards.length) {\n      this.completeSession();\n      return;\n    }\n    \n    const card = this.sessionCards[this.currentIndex];\n    this.currentCard = card || null;\n    this.isFlipped = false;\n    \n    this.updateCurrentCard();\n    this.updateUI();\n    this.updateProgress();\n  }\n\n  private updateCurrentCard(): void {\n    if (!this.currentCard) {\n      return;\n    }\n    \n    const isReverse = this.currentDirection === 'de-bg';\n    const frontText = isReverse ? this.currentCard.translation : this.currentCard.word;\n    const backText = isReverse ? this.currentCard.word : this.currentCard.translation;\n    \n    // Update card content\n    const currentWord = document.querySelector('#current-word');\n    const currentTranslation = document.querySelector('#current-translation');\n    const currentNotes = document.querySelector('#current-notes');\n    const wordLevel = document.querySelector('#word-level');\n    const wordCategory = document.querySelector('#word-category');\n    \n    if (currentWord) {\n      currentWord.textContent = frontText || 'No word';\n    }\n    if (currentTranslation) {\n      currentTranslation.textContent = backText || 'No translation';\n    }\n    \n    // Directional notes\n    if (currentNotes) {\n      const directionalNotes = isReverse\n        ? (this.currentCard.notes_de_to_bg || this.currentCard.notes)\n        : (this.currentCard.notes_bg_to_de || this.currentCard.notes);\n      \n      currentNotes.textContent = directionalNotes || '';\n      currentNotes.style.display = directionalNotes ? 'block' : 'none';\n    }\n    \n    if (wordLevel) {\n      wordLevel.textContent = this.currentCard.level || 'A1';\n    }\n    if (wordCategory) {\n      wordCategory.textContent = this.currentCard.category || '';\n    }\n    \n    // Update hints/etymology if present\n    this.updateHints();\n  }\n\n  private updateHints(): void {\n    const card = this.currentCard;\n    if (!card) {\n      return;\n    }\n    \n    const hintElements = {\n      etymology: document.querySelector('#card-etymology'),\n      culturalNote: document.querySelector('#card-cultural-note'),\n      linguisticNote: document.querySelector('#card-linguistic-note')\n    };\n    \n    if (hintElements.etymology) {\n      hintElements.etymology.textContent = card.etymology || '';\n      hintElements.etymology.style.display = card.etymology ? 'block' : 'none';\n    }\n    \n    if (hintElements.culturalNote) {\n      hintElements.culturalNote.textContent = card.cultural_note || '';\n      hintElements.culturalNote.style.display = card.cultural_note ? 'block' : 'none';\n    }\n    \n    if (hintElements.linguisticNote) {\n      hintElements.linguisticNote.textContent = card.linguistic_note || '';\n      hintElements.linguisticNote.style.display = card.linguistic_note ? 'block' : 'none';\n    }\n  }\n\n  private updateProgress(): void {\n    const progress = document.querySelector('#progress');\n    const accuracy = document.querySelector('#accuracy');\n    \n    if (progress) {\n      progress.textContent = `${this.currentIndex + 1}/${this.sessionCards.length}`;\n    }\n    \n    if (accuracy) {\n      const accuracyPercent = this.sessionStats.total > 0 \n        ? Math.round((this.sessionStats.correct / this.sessionStats.total) * 100) \n        : 0;\n      accuracy.textContent = `${accuracyPercent}%`;\n    }\n  }\n\n  private updateUI(): void {\n    const flashcardFront = document.querySelector('#flashcard-front');\n    const flashcardBack = document.querySelector('#flashcard-back');\n    const flashcard = document.querySelector('#flashcard');\n    const showAnswerBtn = document.querySelector('#show-answer');\n    const responseButtons = document.querySelector('#response-buttons');\n    \n    if (flashcardFront && flashcardBack && flashcard) {\n      if (this.isFlipped) {\n        flashcardFront.style.display = 'none';\n        flashcardBack.style.display = 'block';\n        flashcard.classList.add('flipped');\n        \n        if (showAnswerBtn) {\n          showAnswerBtn.style.display = 'none';\n        }\n        if (responseButtons) {\n          responseButtons.style.display = 'flex';\n          responseButtons.classList.remove('hidden');\n        }\n      } else {\n        flashcardFront.style.display = 'block';\n        flashcardBack.style.display = 'none';\n        flashcard.classList.remove('flipped');\n        \n        if (showAnswerBtn) {\n          showAnswerBtn.style.display = 'inline-block';\n        }\n        if (responseButtons) {\n          responseButtons.style.display = 'none';\n          responseButtons.classList.add('hidden');\n        }\n      }\n    }\n  }\n\n  private showAnswer(): void {\n    if (this.isFlipped) {\n      return;\n    }\n    \n    this.isFlipped = true;\n    this.updateUI();\n    \n    // Auto-play audio if enabled\n    if (this.enableAudio) {\n      this.playAudio();\n    }\n  }\n\n  private playAudio(): void {\n    if (!this.currentCard || !this.currentCard.audio_url) {\n      return;\n    }\n    \n    try {\n      const audio = new Audio(this.currentCard.audio_url);\n      audio.play().catch(error => {\n        console.warn('[UnifiedPractice] Audio playback failed:', error);\n      });\n    } catch (error) {\n      console.warn('[UnifiedPractice] Audio error:', error);\n    }\n  }\n\n  private gradeCard(grade: number): void {\n    if (!this.isFlipped || !this.currentCard) {\n      return;\n    }\n    \n    console.log(`[UnifiedPractice] Grading card ${this.currentCard.id} with grade ${grade}`);\n    \n    // Update session stats\n    this.sessionStats.total += 1;\n    if (grade >= 3) {\n      this.sessionStats.correct += 1;\n    } else {\n      this.sessionStats.mistakes.push({\n        id: this.currentCard.id,\n        word: this.currentCard.word,\n        translation: this.currentCard.translation\n      });\n    }\n    \n    // Update spaced repetition state\n    const state = this.spacedRepetition.loadState(this.currentCard.id, this.currentDirection);\n    const newState = this.spacedRepetition.scheduleNext(state, grade, this.currentDirection);\n    this.spacedRepetition.saveState(newState);\n    \n    // Move to next card\n    this.currentIndex += 1;\n    \n    setTimeout(() => {\n      this.showCurrentCard();\n    }, 300);\n  }\n\n  private completeSession(): void {\n    console.log('[UnifiedPractice] Session complete');\n    \n    this.hideScreen('practice-session');\n    this.showScreen('session-complete');\n    \n    this.updateFinalStats();\n    \n    // Save session history\n    this.saveSessionHistory();\n  }\n\n  private updateFinalStats(): void {\n    const finalCorrect = document.querySelector('#final-correct');\n    const finalTotal = document.querySelector('#final-total');\n    const finalAccuracy = document.querySelector('#final-accuracy');\n    const finalTime = document.querySelector('#final-time');\n    \n    if (finalCorrect) {\n      finalCorrect.textContent = this.sessionStats.correct.toString();\n    }\n    if (finalTotal) {\n      finalTotal.textContent = this.sessionStats.total.toString();\n    }\n    \n    if (finalAccuracy && this.sessionStats.total > 0) {\n      const accuracyPercent = Math.round((this.sessionStats.correct / this.sessionStats.total) * 100);\n      finalAccuracy.textContent = `${accuracyPercent}%`;\n    }\n    \n    if (finalTime) {\n      const duration = Math.round((Date.now() - this.sessionStats.startTime) / 1000);\n      const minutes = Math.floor(duration / 60);\n      const seconds = duration % 60;\n      finalTime.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;\n    }\n  }\n\n  private saveSessionHistory(): void {\n    try {\n      const sessionRecord = {\n        timestamp: Date.now(),\n        direction: this.currentDirection,\n        stats: {\n          correct: this.sessionStats.correct,\n          total: this.sessionStats.total,\n          accuracy: this.sessionStats.total > 0 \n            ? Math.round((this.sessionStats.correct / this.sessionStats.total) * 100) \n            : 0,\n          duration: Date.now() - this.sessionStats.startTime\n        },\n        mistakes: this.sessionStats.mistakes\n      };\n      \n      const history = JSON.parse(localStorage.getItem('bgde:session_history') || '[]');\n      history.push(sessionRecord);\n      \n      // Keep last 50 sessions\n      if (history.length > 50) {\n        history.splice(0, history.length - 50);\n      }\n      \n      localStorage.setItem('bgde:session_history', JSON.stringify(history));\n    } catch (error) {\n      console.warn('[UnifiedPractice] Failed to save session history:', error);\n    }\n  }\n\n  private showError(message: string): void {\n    const errorEl = document.querySelector('#error-message');\n    if (errorEl) {\n      errorEl.textContent = message;\n      errorEl.style.display = 'block';\n    } else {\n      console.error('[UnifiedPractice]', message);\n    }\n  }\n\n  private showNoItemsState(): void {\n    this.hideScreen('practice-session');\n    this.hideScreen('loading-state');\n    this.hideScreen('session-complete');\n    this.showScreen('no-items-state');\n  }\n\n  private hideScreen(id: string): void {\n    const el = document.getElementById(id);\n    if (el) {\n      el.style.display = 'none';\n      el.classList.add('hidden');\n    }\n  }\n\n  private showScreen(id: string): void {\n    const el = document.getElementById(id);\n    if (el) {\n      el.style.display = 'block';\n      el.classList.remove('hidden');\n    }\n  }\n}\n\n// Global access\nif (typeof window !== 'undefined') {\n  window.UnifiedPracticeSession = UnifiedPracticeSession;\n}\n\nexport { UnifiedPracticeSession, type VocabularyItem, type SessionStats, type PracticeSessionOptions };","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/unified-spaced-repetition.ts","messages":[{"ruleId":"brace-style","severity":2,"message":"Closing curly brace does not appear on the same line as the subsequent block.","line":465,"column":9,"nodeType":"Punctuator","messageId":"nextLineClose","endLine":465,"endColumn":10},{"ruleId":"brace-style","severity":2,"message":"Closing curly brace does not appear on the same line as the subsequent block.","line":527,"column":9,"nodeType":"Punctuator","messageId":"nextLineClose","endLine":527,"endColumn":10}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file unified-spaced-repetition.ts\n * @description Unified SM-2 spaced repetition with bidirectional support, 6-phase system, and legacy migration\n * @status ACTIVE\n * @replaces enhanced-spaced-repetition.js, spaced-repetition.js\n * @features\n *   - Direction-aware SM-2 (bg-de, de-bg with difficulty multipliers)\n *   - 6-phase learning progression system integrated with SM-2\n *   - Automatic migration from legacy schema (bgde:review:<id>) to enhanced (bgde:review_<id>_<direction>)\n *   - Phase tracking and progression based on ease factor\n *   - Backward-compatible state loading\n *   - Export/import with schema version tracking\n * @version 3.0.0\n * @updated November 2025\n */\n\nimport type { \n  ReviewState, \n  LegacyReviewState, \n  MigrationLogEntry, \n  MigrationResults, \n  ExportData, \n  ImportResults, \n  DueItemsStats \n} from './types.js';\n\n// Type for PhaseCalculator (will be properly typed when phase-calculator.ts is created)\ninterface PhaseCalculator {\n  calculatePhase(easeFactor: number, repetitions?: number): number;\n  calculateNewPhase(currentPhase: number, quality: number, newEaseFactor: number, repetitions: number): number;\n  getPhaseIntervalMultiplier(phase: number): number;\n}\n\n// Type for ProfileManager (will be properly typed when profile-manager.ts is created)\ninterface ProfileManager {\n  getNamespacedKey(key: string, profileId?: string | null): string;\n  getActiveProfileId(): string;\n}\n\nclass UnifiedSpacedRepetition {\n  private storagePrefix: string = 'bgde:';\n  private schemaVersion: number = 3; // Incremented for phase system\n  private difficultyMultipliers: Record<string, number> = {\n    'bg-de': 1.1, // Bulgarian to German\n    'de-bg': 1.2  // German to Bulgarian (harder)\n  };\n  private legacyKeyPattern: RegExp = /^bgde:review:/; // Legacy format (no profile namespace)\n  private enhancedKeyPattern: RegExp = /^bgde:review_(.+)_(bg-de|de-bg)$/; // Enhanced format (no profile namespace)\n  private profiledKeyPattern: RegExp = /^bgde:([^:]+):review_(.+)_(bg-de|de-bg)$/; // Profile-namespaced format\n\n  // Phase calculator integration\n  private phaseCalculator: PhaseCalculator | null;\n\n  // Profile manager integration for data isolation\n  private profileManager: ProfileManager | null;\n\n  // Track migration status\n  private migrationLog: MigrationLogEntry[] = [];\n\n  constructor(phaseCalculator: PhaseCalculator | null = null, profileManager: ProfileManager | null = null) {\n    this.phaseCalculator = phaseCalculator;\n    this.profileManager = profileManager;\n    this.init();\n  }\n\n  private init(): void {\n    console.log('[UnifiedSR] Initialized unified spaced repetition system v3.0 with 6-phase progression');\n\n    // Check for legacy data and offer migration\n    this.detectLegacyData();\n\n    // Check for reviews without phase field (schema v2 -> v3 migration)\n    this.detectPhaselessReviews();\n  }\n\n  /**\n   * Detect reviews without phase field (v2 schema) and log migration opportunities\n   */\n  private detectPhaselessReviews(): void {\n    const phaselessKeys: string[] = [];\n\n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && this.enhancedKeyPattern.test(key)) {\n          const data = this.loadFromStorage(key);\n          if (data && data.phase === undefined) {\n            phaselessKeys.push(key);\n          }\n        }\n      }\n\n      if (phaselessKeys.length > 0) {\n        console.log(`[UnifiedSR] Found ${phaselessKeys.length} reviews without phase field. Auto-migration will occur on next load.`);\n      }\n    } catch (error) {\n      console.warn('[UnifiedSR] Failed to detect phaseless reviews:', error);\n    }\n  }\n\n  /**\n   * Detect legacy localStorage keys and log migration opportunities\n   */\n  private detectLegacyData(): void {\n    const legacyKeys: string[] = [];\n    \n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && this.legacyKeyPattern.test(key)) {\n          legacyKeys.push(key);\n        }\n      }\n      \n      if (legacyKeys.length > 0) {\n        console.log(`[UnifiedSR] Found ${legacyKeys.length} legacy review states. Migration available.`);\n        this.migrationLog.push({\n          timestamp: Date.now(),\n          type: 'detection',\n          count: legacyKeys.length\n        });\n      }\n    } catch (error) {\n      console.warn('[UnifiedSR] Failed to detect legacy data:', error);\n    }\n  }\n\n  /**\n   * Initialize review state for a new vocabulary item\n   * @param itemId - Unique identifier for the vocabulary item\n   * @param direction - Learning direction ('bg-de' or 'de-bg')\n   * @returns Initial review state\n   */\n  initReviewState(itemId: string, direction: 'bg-de' | 'de-bg' = 'bg-de'): ReviewState {\n    const now = Date.now();\n\n    // Calculate initial phase (should be Phase 1 for new items)\n    const initialPhase = this.phaseCalculator\n      ? this.phaseCalculator.calculatePhase(2.5, 0)\n      : 1;\n\n    return {\n      itemId,\n      direction,\n      schemaVersion: this.schemaVersion,\n      interval: 1,\n      easeFactor: 2.5,\n      repetitions: 0,\n      phase: initialPhase, // Phase tracking (1-6, or 0 for \"Learned\")\n      nextReview: now,\n      lastReview: null,\n      totalReviews: 0,\n      correctAnswers: 0,\n      correctStreak: 0,\n      created: now,\n      updated: now\n    };\n  }\n\n  /**\n   * Calculate next review using SM-2 algorithm with direction multipliers and phase tracking\n   * @param state - Current review state\n   * @param grade - Quality of response (0-5, where 3+ is correct)\n   * @param direction - Learning direction (optional, uses state.direction if not provided)\n   * @returns Updated review state\n   */\n  scheduleNext(state: ReviewState, grade: number, direction: 'bg-de' | 'de-bg' | null = null): ReviewState {\n    if (!state || grade < 0 || grade > 5) {\n      throw new Error('Invalid review state or grade');\n    }\n\n    const now = Date.now();\n    const updatedState: ReviewState = { ...state };\n    const activeDirection = direction || state.direction || 'bg-de';\n\n    // Update metadata\n    updatedState.lastReview = now;\n    updatedState.totalReviews = (updatedState.totalReviews || 0) + 1;\n    updatedState.updated = now;\n    updatedState.direction = activeDirection;\n    updatedState.schemaVersion = this.schemaVersion;\n\n    // Determine if response is correct (grade 3+)\n    const isCorrect = grade >= 3;\n\n    // Store current phase for phase progression calculation\n    const currentPhase = updatedState.phase || 1;\n\n    if (isCorrect) {\n      updatedState.correctAnswers = (updatedState.correctAnswers || 0) + 1;\n      updatedState.correctStreak = (updatedState.correctStreak || 0) + 1;\n\n      // Calculate new ease factor using SM-2 formula\n      const newEF = Math.max(1.3,\n        updatedState.easeFactor + (0.1 - (5 - grade) * (0.08 + (5 - grade) * 0.02))\n      );\n      updatedState.easeFactor = Math.round(newEF * 100) / 100;\n\n      // Calculate interval based on repetition count\n      if (updatedState.repetitions === 0) {\n        updatedState.interval = 1;\n      } else if (updatedState.repetitions === 1) {\n        updatedState.interval = 6;\n      } else {\n        // Apply direction-specific difficulty multiplier\n        const multiplier = this.difficultyMultipliers[activeDirection] || 1;\n        updatedState.interval = Math.round(updatedState.interval * updatedState.easeFactor * multiplier);\n      }\n\n      updatedState.repetitions = (updatedState.repetitions || 0) + 1;\n\n    } else {\n      // Reset on incorrect answer\n      updatedState.correctStreak = 0;\n      updatedState.repetitions = 0;\n      updatedState.interval = 1;\n      // Reduce ease factor but keep minimum at 1.3\n      updatedState.easeFactor = Math.max(1.3, updatedState.easeFactor - 0.2);\n    }\n\n    // Calculate next review date (interval is in days)\n    updatedState.nextReview = now + (updatedState.interval * 24 * 60 * 60 * 1000);\n\n    // Update phase based on new ease factor and repetitions\n    if (this.phaseCalculator) {\n      const newPhase = this.phaseCalculator.calculateNewPhase(\n        currentPhase,\n        grade,\n        updatedState.easeFactor,\n        updatedState.repetitions\n      );\n      updatedState.phase = newPhase;\n\n      // Apply phase-based interval multiplier for learned items\n      if (newPhase === 0) { // Learned status\n        const phaseMultiplier = this.phaseCalculator.getPhaseIntervalMultiplier(0);\n        updatedState.interval = Math.round(updatedState.interval * phaseMultiplier);\n        updatedState.nextReview = now + (updatedState.interval * 24 * 60 * 60 * 1000);\n      }\n\n      // Log phase transitions\n      if (newPhase !== currentPhase) {\n        console.log(`[UnifiedSR] Phase transition: ${currentPhase} → ${newPhase} (EF: ${updatedState.easeFactor})`);\n      }\n    } else {\n      // Fallback if no phase calculator\n      updatedState.phase = currentPhase;\n    }\n\n    return updatedState;\n  }\n\n  /**\n   * Load review state with automatic legacy migration and phase auto-migration\n   * @param itemId - Item identifier\n   * @param direction - Learning direction\n   * @returns Review state (migrated if necessary)\n   */\n  loadState(itemId: string, direction: 'bg-de' | 'de-bg' = 'bg-de'): ReviewState {\n    // Build base key\n    const baseKey = `review_${itemId}_${direction}`;\n\n    // Try profile-namespaced key first (if profileManager available)\n    const profiledKey = this.profileManager\n      ? this.profileManager.getNamespacedKey(baseKey)\n      : `${this.storagePrefix}${baseKey}`;\n\n    const profiledData = this.loadFromStorage(profiledKey);\n\n    if (profiledData) {\n      // Auto-migrate if phase field is missing (schema v2 -> v3)\n      if (profiledData.phase === undefined && this.phaseCalculator) {\n        profiledData.phase = this.phaseCalculator.calculatePhase(\n          profiledData.easeFactor || 2.5,\n          profiledData.repetitions || 0\n        );\n        profiledData.schemaVersion = this.schemaVersion;\n        this.saveState(profiledData);\n        console.log(`[UnifiedSR] Auto-migrated review ${itemId} to v3 with phase ${profiledData.phase}`);\n      }\n      return profiledData;\n    }\n\n    // Try non-profiled enhanced key for backward compatibility\n    const enhancedKey = `${this.storagePrefix}review_${itemId}_${direction}`;\n    const enhancedData = this.loadFromStorage(enhancedKey);\n\n    if (enhancedData) {\n      // Migrate to profile-namespaced storage if profileManager available\n      if (this.profileManager) {\n        console.log(`[UnifiedSR] Migrating ${itemId} to profile-namespaced storage`);\n        enhancedData.schemaVersion = this.schemaVersion;\n\n        // Add phase if missing\n        if (enhancedData.phase === undefined && this.phaseCalculator) {\n          enhancedData.phase = this.phaseCalculator.calculatePhase(\n            enhancedData.easeFactor || 2.5,\n            enhancedData.repetitions || 0\n          );\n        }\n\n        // Save to profile-namespaced key\n        this.saveState(enhancedData);\n\n        // Remove old non-profiled key\n        localStorage.removeItem(enhancedKey);\n      }\n      return enhancedData;\n    }\n\n    // Try legacy key and migrate if found\n    const legacyKey = `${this.storagePrefix}review:${itemId}`;\n    const legacyData = this.loadFromStorage(legacyKey);\n\n    if (legacyData) {\n      console.log(`[UnifiedSR] Migrating legacy state for ${itemId}`);\n      const migrated = this.migrateLegacyState(legacyData, itemId, direction);\n      this.saveState(migrated);\n\n      // Log migration\n      this.migrationLog.push({\n        timestamp: Date.now(),\n        type: 'migration',\n        itemId,\n        direction,\n        from: 'legacy',\n        to: 'enhanced'\n      });\n\n      return migrated;\n    }\n\n    // No existing state, return initialized state\n    return this.initReviewState(itemId, direction);\n  }\n\n  /**\n   * Migrate legacy state to enhanced schema with phase calculation\n   * @param legacyState - Legacy review state\n   * @param itemId - Item ID\n   * @param direction - Target direction\n   * @returns Enhanced state with phase field\n   */\n  private migrateLegacyState(legacyState: LegacyReviewState, itemId: string, direction: 'bg-de' | 'de-bg'): ReviewState {\n    const now = Date.now();\n    const easeFactor = legacyState.easinessFactor || legacyState.easeFactor || 2.5;\n    const repetitions = legacyState.repetitions || 0;\n\n    // Calculate phase based on ease factor and repetitions\n    const phase = this.phaseCalculator\n      ? this.phaseCalculator.calculatePhase(easeFactor, repetitions)\n      : 1; // Default to Phase 1 if no calculator\n\n    return {\n      itemId: itemId,\n      direction: direction,\n      schemaVersion: this.schemaVersion,\n      interval: legacyState.interval || 1,\n      easeFactor: easeFactor,\n      repetitions: repetitions,\n      phase: phase, // NEW: Include phase in migrated data\n      nextReview: legacyState.nextReviewDate ? new Date(legacyState.nextReviewDate).getTime() : now,\n      lastReview: legacyState.lastReviewDate ? new Date(legacyState.lastReviewDate).getTime() : null,\n      totalReviews: legacyState.totalReviews || 0,\n      correctAnswers: legacyState.correctAnswers || 0,\n      correctStreak: legacyState.streak || legacyState.correctStreak || 0,\n      created: legacyState.created ? new Date(legacyState.created).getTime() : now,\n      updated: now\n    };\n  }\n\n  /**\n   * Load data from localStorage with error handling\n   * @param key - Storage key\n   * @returns Parsed state or null\n   */\n  private loadFromStorage(key: string): ReviewState | null {\n    try {\n      const data = localStorage.getItem(key);\n      if (!data) return null;\n      \n      const parsed = JSON.parse(data);\n      \n      // Validate basic structure\n      if (typeof parsed === 'object' && parsed !== null) {\n        return parsed as ReviewState;\n      }\n      \n      return null;\n    } catch (error) {\n      console.warn(`[UnifiedSR] Failed to load state from ${key}:`, error);\n      return null;\n    }\n  }\n\n  /**\n   * Save review state to localStorage with profile namespacing\n   * @param state - Review state\n   * @returns Success status\n   */\n  saveState(state: ReviewState): boolean {\n    if (!state || !state.itemId || !state.direction) {\n      console.warn('[UnifiedSR] Cannot save invalid state:', state);\n      return false;\n    }\n\n    try {\n      // Build base key\n      const baseKey = `review_${state.itemId}_${state.direction}`;\n\n      // Use profile namespacing if profileManager is available\n      const key = this.profileManager\n        ? this.profileManager.getNamespacedKey(baseKey)\n        : `${this.storagePrefix}${baseKey}`;\n\n      const data = JSON.stringify(state);\n      localStorage.setItem(key, data);\n      return true;\n    } catch (error) {\n      console.error('[UnifiedSR] Failed to save state:', error);\n\n      // Handle quota exceeded\n      if (error instanceof Error && error.name === 'QuotaExceededError') {\n        console.warn('[UnifiedSR] Storage quota exceeded. Consider cleanup.');\n      }\n\n      return false;\n    }\n  }\n\n  /**\n   * Get all items due for review (profile-aware)\n   * @param direction - Optional direction filter\n   * @returns Array of due states\n   */\n  getDueItems(direction: 'bg-de' | 'de-bg' | null = null): ReviewState[] {\n    const now = Date.now();\n    const dueStates: ReviewState[] = [];\n\n    // Get current profile ID if profileManager available\n    const currentProfileId = this.profileManager\n      ? this.profileManager.getActiveProfileId()\n      : null;\n\n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n\n        // Check profile-namespaced keys\n        if (key && this.profiledKeyPattern.test(key)) {\n          const match = key.match(this.profiledKeyPattern);\n          const keyProfileId = match ? match[1] : null;\n\n          // Skip if doesn't match current profile\n          if (currentProfileId && keyProfileId !== currentProfileId) {\n            continue;\n          }\n\n          const state = this.loadFromStorage(key);\n\n          if (state && state.nextReview <= now && // Apply direction filter if specified\n            (!direction || state.direction === direction)) {\n            dueStates.push(state);\n          }\n        }\n        // Backward compatibility: check non-profiled keys if no profileManager\n        else if (!this.profileManager && key && this.enhancedKeyPattern.test(key)) {\n          const state = this.loadFromStorage(key);\n          if (state && state.nextReview <= now && (!direction || state.direction === direction)) {\n            dueStates.push(state);\n          }\n        }\n      }\n    } catch (error) {\n      console.error('[UnifiedSR] Failed to get due items:', error);\n    }\n\n    return dueStates;\n  }\n\n  /**\n   * Get statistics for a specific direction or overall (profile-aware)\n   * @param direction - Optional direction filter\n   * @returns Statistics\n   */\n  getStats(direction: 'bg-de' | 'de-bg' | null = null): DueItemsStats {\n    let total = 0;\n    let due = 0;\n    let totalEF = 0;\n    let totalAccuracy = 0;\n    let itemsWithReviews = 0;\n\n    // Get current profile ID if profileManager available\n    const currentProfileId = this.profileManager\n      ? this.profileManager.getActiveProfileId()\n      : null;\n\n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n\n        // Check profile-namespaced keys\n        if (key && this.profiledKeyPattern.test(key)) {\n          const match = key.match(this.profiledKeyPattern);\n          const keyProfileId = match ? match[1] : null;\n\n          // Skip if doesn't match current profile\n          if (currentProfileId && keyProfileId !== currentProfileId) {\n            continue;\n          }\n\n          const state = this.loadFromStorage(key);\n\n          if (state && (!direction || state.direction === direction)) {\n            total++;\n            totalEF += state.easeFactor || 2.5;\n\n            if (state.nextReview <= Date.now()) {\n              due++;\n            }\n\n            if (state.totalReviews > 0) {\n              itemsWithReviews++;\n              totalAccuracy += (state.correctAnswers / state.totalReviews) * 100;\n            }\n          }\n        }\n        // Backward compatibility: check non-profiled keys if no profileManager\n        else if (!this.profileManager && key && this.enhancedKeyPattern.test(key)) {\n          const state = this.loadFromStorage(key);\n\n          if (state && (!direction || state.direction === direction)) {\n            total++;\n            totalEF += state.easeFactor || 2.5;\n\n            if (state.nextReview <= Date.now()) {\n              due++;\n            }\n\n            if (state.totalReviews > 0) {\n              itemsWithReviews++;\n              totalAccuracy += (state.correctAnswers / state.totalReviews) * 100;\n            }\n          }\n        }\n      }\n    } catch (error) {\n      console.error('[UnifiedSR] Failed to calculate stats:', error);\n    }\n\n    return {\n      total,\n      due,\n      avgEaseFactor: total > 0 ? Math.round((totalEF / total) * 100) / 100 : 2.5,\n      avgAccuracy: itemsWithReviews > 0 ? Math.round(totalAccuracy / itemsWithReviews) : 0,\n      direction: direction || 'all'\n    };\n  }\n\n  /**\n   * Batch migrate all legacy keys to enhanced format\n   * @param defaultDirection - Default direction for migration ('bg-de' or 'de-bg')\n   * @returns Migration results\n   */\n  migrateAllLegacy(defaultDirection: 'bg-de' | 'de-bg' = 'bg-de'): MigrationResults {\n    const results: MigrationResults = {\n      migrated: 0,\n      failed: 0,\n      skipped: 0\n    };\n    \n    try {\n      const legacyKeys: string[] = [];\n      \n      // Collect all legacy keys\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        if (key && this.legacyKeyPattern.test(key)) {\n          legacyKeys.push(key);\n        }\n      }\n      \n      // Migrate each legacy key\n      for (const legacyKey of legacyKeys) {\n        const itemId = legacyKey.replace(this.legacyKeyPattern, '');\n        const legacyData = this.loadFromStorage(legacyKey);\n        \n        if (!legacyData) {\n          results.failed++;\n          continue;\n        }\n        \n        // Check if enhanced version already exists\n        const enhancedKey = `${this.storagePrefix}review_${itemId}_${defaultDirection}`;\n        if (localStorage.getItem(enhancedKey)) {\n          results.skipped++;\n          continue;\n        }\n        \n        // Migrate\n        const migrated = this.migrateLegacyState(legacyData, itemId, defaultDirection);\n        if (this.saveState(migrated)) {\n          results.migrated++;\n          console.log(`[UnifiedSR] Migrated ${itemId} to enhanced schema`);\n        } else {\n          results.failed++;\n        }\n      }\n      \n      this.migrationLog.push({\n        timestamp: Date.now(),\n        type: 'batch_migration',\n        results\n      });\n      \n    } catch (error) {\n      console.error('[UnifiedSR] Batch migration failed:', error);\n    }\n    \n    return results;\n  }\n\n  /**\n   * Export all review data with schema version\n   * @returns JSON string of all data\n   */\n  exportData(): string {\n    const exportData: ExportData = {\n      version: this.schemaVersion,\n      exported: Date.now(),\n      states: {}\n    };\n    \n    try {\n      for (let i = 0; i < localStorage.length; i++) {\n        const key = localStorage.key(i);\n        \n        if (key && this.enhancedKeyPattern.test(key)) {\n          const state = this.loadFromStorage(key);\n          if (state) {\n            exportData.states[key] = state;\n          }\n        }\n      }\n      \n      return JSON.stringify(exportData, null, 2);\n    } catch (error) {\n      console.error('[UnifiedSR] Export failed:', error);\n      return '{}';\n    }\n  }\n\n  /**\n   * Import review data with schema validation\n   * @param jsonData - JSON export string\n   * @returns Import results\n   */\n  importData(jsonData: string): ImportResults {\n    const results: ImportResults = {\n      imported: 0,\n      skipped: 0,\n      failed: 0\n    };\n    \n    try {\n      const data = JSON.parse(jsonData) as ExportData;\n      \n      if (!data.states || typeof data.states !== 'object') {\n        throw new Error('Invalid export format');\n      }\n      \n      for (const [, state] of Object.entries(data.states)) {\n        if (this.validateState(state)) {\n          if (this.saveState(state)) {\n            results.imported++;\n          } else {\n            results.failed++;\n          }\n        } else {\n          results.skipped++;\n        }\n      }\n      \n      console.log('[UnifiedSR] Import complete:', results);\n    } catch (error) {\n      console.error('[UnifiedSR] Import failed:', error);\n      results.failed++;\n    }\n    \n    return results;\n  }\n\n  /**\n   * Validate state object structure\n   * @param state - State to validate\n   * @returns Validation result\n   */\n  private validateState(state: ReviewState): boolean {\n    return !!(\n      state &&\n      typeof state === 'object' &&\n      state.itemId &&\n      state.direction &&\n      typeof state.easeFactor === 'number' &&\n      typeof state.interval === 'number'\n    );\n  }\n\n  /**\n   * Get migration log\n   * @returns Migration history\n   */\n  getMigrationLog(): MigrationLogEntry[] {\n    return [...this.migrationLog];\n  }\n}\n\n// Export class for use in bundled spaced-repetition-system.js\n// No singleton initialization here - handled by bundled file\nif (typeof window !== 'undefined') {\n  (window as { UnifiedSpacedRepetition?: typeof UnifiedSpacedRepetition }).UnifiedSpacedRepetition = UnifiedSpacedRepetition;\n}\n\nexport default UnifiedSpacedRepetition;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/vocab-cards.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'_index' is defined but never used.","line":353,"column":45,"nodeType":"Identifier","messageId":"unusedVar","endLine":353,"endColumn":59},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":448,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":448,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14404,14407],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14404,14407],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":454,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":454,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14585,14588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14585,14588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file vocab-cards.ts\n * @description Interactive vocabulary card display system\n * @status ACTIVE\n * @dependencies language-toggle.ts\n * @used_by layouts/_shortcodes/vocab.html, layouts/vocabulary/list.html\n * @features\n *   - Category and CEFR level filtering\n *   - Text search with debouncing\n *   - Card flip animations\n *   - Bidirectional display (Bulgarian↔German)\n *   - Accessibility (keyboard navigation, ARIA)\n * @see docs/ARCHITECTURE.md for system design\n * @version 1.0.0\n * @updated October 2025\n */\n\n// Remove unused import\n\ninterface VocabularyItem {\n  id: string;\n  word: string;\n  translation: string;\n  level?: string;\n  category?: string;\n  difficulty?: number;\n  frequency?: number;\n  notes?: string;\n  notes_bg_to_de?: string;\n  notes_de_to_bg?: string;\n  etymology?: string;\n  cultural_note?: string;\n  linguistic_note?: string;\n  audio_url?: string;\n  examples?: Array<{\n    sentence: string;\n    translation: string;\n    context: string;\n  }>;\n}\n\ninterface VocabularyAPI {\n  loadAll(): Promise<VocabularyItem[]>;\n  loadFiltered(filters: { level?: string; category?: string; search?: string }): Promise<VocabularyItem[]>;\n}\n\n// Remove unused interface\n\ninterface CardText {\n  frontText: string;\n  backText: string;\n}\n\nexport class VocabCards {\n  private container: HTMLElement;\n  private vocabularyData: VocabularyItem[] = [];\n  private filteredData: VocabularyItem[] = [];\n  private currentCategory: string;\n  private currentLevel: string;\n  private limit: number;\n  private interactive: boolean;\n  private languageDirection: string;\n\n  // DOM elements\n  private grid: HTMLElement | null;\n  private loading: HTMLElement | null;\n  private error: HTMLElement | null;\n  private cardCount: HTMLElement | null;\n  private categoryFilter: HTMLSelectElement | null;\n  private levelFilter: HTMLSelectElement | null;\n  private shuffleBtn: HTMLElement | null;\n  private retryBtn: HTMLElement | null;\n\n  // Bound event handlers for cleanup\n  private onLanguageDirectionChanged: (e: CustomEvent) => void;\n  private languageListenerAttached: boolean = false;\n\n  constructor(container: HTMLElement) {\n    this.container = container;\n    this.vocabularyData = [];\n    this.filteredData = [];\n    this.currentCategory = container.dataset.category || '';\n    this.currentLevel = container.dataset.level || '';\n    this.limit = Number.parseInt(container.dataset.limit || '0');\n    this.interactive = container.dataset.interactive === 'true';\n    this.languageDirection = 'bg-de'; // Default direction\n\n    // DOM elements\n    this.grid = container.querySelector('#vocab-grid');\n    this.loading = container.querySelector('#vocab-loading');\n    this.error = container.querySelector('#vocab-error');\n    this.cardCount = container.querySelector('#card-count');\n    this.categoryFilter = container.querySelector('#category-filter');\n    this.levelFilter = container.querySelector('#level-filter');\n    this.shuffleBtn = container.querySelector('#shuffle-cards');\n    this.retryBtn = container.querySelector('#retry-load');\n\n    // Bound event handlers for cleanup\n    this.onLanguageDirectionChanged = this.handleLanguageDirectionChange.bind(this);\n    this.languageListenerAttached = false;\n\n    this.init();\n  }\n  \n  async init(): Promise<void> {\n    this.bindEvents();\n    await this.loadVocabulary();\n    this.applyInitialFilters();\n    this.renderCards();\n\n    // Ensure loading is hidden after cards are rendered\n    // Use requestAnimationFrame to wait for DOM paint\n    requestAnimationFrame(() => {\n      this.showLoading(false);\n    });\n  }\n  \n  private bindEvents(): void {\n    if (this.categoryFilter) {\n      this.categoryFilter.addEventListener('change', () => this.handleFilterChange());\n    }\n    \n    if (this.levelFilter) {\n      this.levelFilter.addEventListener('change', () => this.handleFilterChange());\n    }\n    \n    if (this.shuffleBtn) {\n      this.shuffleBtn.addEventListener('click', () => this.shuffleCards());\n    }\n    \n    if (this.retryBtn) {\n      this.retryBtn.addEventListener('click', () => this.init());\n    }\n    \n    // Listen for language direction changes (use bound handler for cleanup)\n    if (!this.languageListenerAttached) {\n      document.addEventListener('language-direction-changed', this.onLanguageDirectionChanged);\n      this.languageListenerAttached = true;\n    }\n    \n    // Keyboard navigation\n    document.addEventListener('keydown', (e: KeyboardEvent) => this.handleKeyboardNavigation(e));\n  }\n  \n  private async loadVocabulary(): Promise<void> {\n    try {\n      this.showLoading(true);\n\n      const inlineData = this.readInlineVocabulary();\n\n      if (inlineData) {\n        this.vocabularyData = inlineData;\n        this.populateFilters();\n        this.showError(false);\n        return;\n      }\n\n      // Try to load from modular vocabulary API first\n      try {\n        const { vocabularyAPI } = await import('./modules/vocabulary-api.js') as { vocabularyAPI: VocabularyAPI };\n        const allEntries = await vocabularyAPI.loadAll();\n        \n        if (Array.isArray(allEntries) && allEntries.length > 0) {\n          this.vocabularyData = allEntries;\n          this.populateFilters();\n          this.showError(false);\n          console.log(`[VocabCards] Loaded ${allEntries.length} entries via modular API`);\n          return;\n        }\n      } catch (apiError) {\n        console.warn('[VocabCards] Modular API not available, falling back to fetch:', apiError);\n      }\n\n      // Fallback to fetching from Hugo's data directory\n      let response = await fetch('/data/vocabulary.json');\n\n      // Fallback to static directory if data directory fails\n      if (!response.ok) {\n        response = await fetch('/static/data/vocabulary.json');\n      }\n\n      if (!response.ok) {\n        throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n      }\n\n      this.vocabularyData = await response.json() as VocabularyItem[];\n\n      if (!Array.isArray(this.vocabularyData) || this.vocabularyData.length === 0) {\n        throw new Error('Invalid or empty vocabulary data');\n      }\n\n      this.populateFilters();\n      this.showError(false);\n\n    } catch (error) {\n      console.error('Failed to load vocabulary:', error);\n      this.showError(true, (error as Error).message);\n      this.showLoading(false);\n\n      // Fallback to empty array to prevent crashes\n      this.vocabularyData = [];\n    }\n    // Note: Loading indicator is now hidden in init() after renderCards() completes\n  }\n\n  private readInlineVocabulary(): VocabularyItem[] | null {\n    const inlineNode = this.container.querySelector('[data-vocab-inline]');\n\n    if (!inlineNode) {\n      return null;\n    }\n\n    try {\n      const inlineJson = inlineNode.textContent?.trim() || '';\n\n      if (!inlineJson) {\n        return null;\n      }\n\n      const parsed = JSON.parse(inlineJson) as unknown;\n\n      if (!Array.isArray(parsed) || parsed.length === 0) {\n        console.warn('Inline vocabulary data is empty or invalid array.');\n        return null;\n      }\n\n      return parsed as VocabularyItem[];\n    } catch (error) {\n      console.warn('Failed to parse inline vocabulary JSON:', error);\n      return null;\n    }\n  }\n  \n  private populateFilters(): void {\n    if (!this.categoryFilter || !this.levelFilter) {\n      return;\n    }\n    \n    // Get unique categories and levels\n    const categories = [...new Set(this.vocabularyData.map(item => item.category).filter(Boolean))] as string[];\n    const levels = [...new Set(this.vocabularyData.map(item => item.level).filter(Boolean))] as string[];\n    \n    // Populate category filter\n    this.categoryFilter.innerHTML = '<option value=\"\">All Categories</option>';\n    for (const category of categories.sort()) {\n      const option = document.createElement('option');\n      option.value = category;\n      option.textContent = category;\n      if (category === this.currentCategory) {\n        option.selected = true;\n      }\n      this.categoryFilter.append(option);\n    }\n    \n    // Populate level filter\n    this.levelFilter.innerHTML = '<option value=\"\">All Levels</option>';\n    for (const level of levels.sort()) {\n      const option = document.createElement('option');\n      option.value = level;\n      option.textContent = level;\n      if (level === this.currentLevel) {\n        option.selected = true;\n      }\n      this.levelFilter.append(option);\n    }\n  }\n  \n  private applyInitialFilters(): void {\n    this.filteredData = this.vocabularyData.filter(item => {\n      const categoryMatch = !this.currentCategory || item.category === this.currentCategory;\n      const levelMatch = !this.currentLevel || item.level === this.currentLevel;\n      return categoryMatch && levelMatch;\n    });\n    \n    if (this.limit > 0) {\n      this.filteredData = this.filteredData.slice(0, this.limit);\n    }\n  }\n  \n  private handleFilterChange(): void {\n    this.currentCategory = this.categoryFilter?.value || '';\n    this.currentLevel = this.levelFilter?.value || '';\n    \n    this.applyInitialFilters();\n    this.renderCards();\n    \n    // Announce filter change to screen readers\n    this.announceToScreenReader(`Filtered to ${this.filteredData.length} cards`);\n  }\n  \n  private shuffleCards(): void {\n    this.filteredData = this.shuffleArray([...this.filteredData]);\n    this.renderCards();\n    this.announceToScreenReader('Cards shuffled');\n  }\n  \n  private shuffleArray<T>(array: T[]): T[] {\n    const result = [...array];\n    for (let i = result.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      const temp = result[i]!;\n      result[i] = result[j]!;\n      result[j] = temp;\n    }\n    return result;\n  }\n  \n  private renderCards(): void {\n    if (!this.grid) {\n      return;\n    }\n\n    // Show loading while rendering on mobile (can be slow with many cards)\n    const isMobile = window.innerWidth < 768;\n    if (isMobile && this.filteredData.length > 20) {\n      this.showLoading(true);\n    }\n\n    this.grid.innerHTML = '';\n    this.updateCardCount();\n\n    if (this.filteredData.length === 0) {\n      this.renderEmptyState();\n      return;\n    }\n\n    // Use document fragment for better performance\n    const fragment = document.createDocumentFragment();\n\n    let index = 0;\n    for (const item of this.filteredData) {\n      const card = this.createCard(item, index);\n      fragment.append(card);\n      index++;\n    }\n\n    this.grid.append(fragment);\n\n    // Set focus to first card for keyboard navigation\n    const firstCard = this.grid.querySelector('.vocab-card');\n    if (firstCard) {\n      firstCard.setAttribute('tabindex', '0');\n    }\n\n    // Hide loading after render completes (for filter/shuffle operations)\n    if (isMobile && this.filteredData.length > 20) {\n      requestAnimationFrame(() => {\n        this.showLoading(false);\n      });\n    }\n  }\n  \n  private createCard(vocab: VocabularyItem, _index: number): HTMLElement {\n    const card = document.createElement('div');\n    card.className = 'vocab-card';\n    card.setAttribute('role', 'button');\n    card.setAttribute('tabindex', '0');\n    card.dataset.id = vocab.id || '';\n    card.dataset.level = vocab.level || '';\n    card.dataset.category = vocab.category || '';\n    card.dataset.word = vocab.word || '';\n    card.dataset.translation = vocab.translation || '';\n    \n    // Get display text based on language direction\n    const { frontText, backText } = this.getCardText(vocab);\n    card.setAttribute('aria-label', `Vocabulary card: ${frontText} - ${backText}`);\n    \n    const cardInner = document.createElement('div');\n    cardInner.className = 'vocab-card-inner';\n    \n    // Front side\n    const cardFront = document.createElement('div');\n    cardFront.className = 'vocab-card-front';\n    cardFront.innerHTML = `\n      <div class=\"vocab-word\">${this.escapeHtml(frontText)}</div>\n      <div class=\"vocab-category\">${this.escapeHtml(vocab.category || '')}</div>\n      <div class=\"vocab-level\">${this.escapeHtml(vocab.level || '')}</div>\n    `;\n    \n    // Back side\n    const cardBack = document.createElement('div');\n    cardBack.className = 'vocab-card-back';\n    cardBack.innerHTML = `\n      <div class=\"vocab-translation\">${this.escapeHtml(backText)}</div>\n      ${this.buildNotesHtml(vocab)}\n    `;\n    \n    cardInner.append(cardFront);\n    cardInner.append(cardBack);\n    card.append(cardInner);\n    \n    if (this.interactive) {\n      card.addEventListener('click', () => this.flipCard(card));\n      card.addEventListener('keydown', (e: KeyboardEvent) => {\n        if (e.key === 'Enter' || e.key === ' ') {\n          e.preventDefault();\n          this.flipCard(card);\n        }\n      });\n    }\n    return card;\n  }\n\n  private buildNotesHtml(vocab: VocabularyItem): string {\n    const isBgToDe = this.languageDirection === 'bg-de';\n\n    // Get direction-specific content\n    const notes = this.getDirectionSpecificContent(vocab, 'notes');\n    const etymology = this.getDirectionSpecificContent(vocab, 'etymology');\n    const culturalNote = this.getDirectionSpecificContent(vocab, 'cultural_note');\n    const linguisticNote = this.getDirectionSpecificContent(vocab, 'linguistic_note');\n\n    let html = '';\n\n    if (notes) {\n      html += `<div class=\"vocab-notes\">${this.escapeHtml(notes)}</div>`;\n    }\n\n    if (etymology) {\n      html += `<div class=\"vocab-etymology\"><strong>${isBgToDe ? 'Произход:' : 'Etymologie:'}</strong> ${this.escapeHtml(etymology)}</div>`;\n    }\n\n    if (culturalNote) {\n      html += `<div class=\"vocab-cultural-note\"><strong>${isBgToDe ? 'Културна бележка:' : 'Kulturelle Anmerkung:'}</strong> ${this.escapeHtml(culturalNote)}</div>`;\n    }\n\n    if (linguisticNote) {\n      html += `<div class=\"vocab-linguistic-note\"><strong>${isBgToDe ? 'Лингвистична бележка:' : 'Linguistische Anmerkung:'}</strong> ${this.escapeHtml(linguisticNote)}</div>`;\n    }\n\n    return html;\n  }\n\n  /**\n   * Get language-direction-specific content from vocabulary item\n   * @param vocab - Vocabulary item\n   * @param fieldName - Base field name (e.g., 'notes', 'etymology')\n   * @returns Content in appropriate language\n   */\n  private getDirectionSpecificContent(vocab: VocabularyItem, fieldName: string): string {\n    const isBgToDe = this.languageDirection === 'bg-de';\n\n    // Try direction-specific field first (e.g., notes_bg_to_de, notes_de_to_bg)\n    const directionField = isBgToDe\n      ? `${fieldName}_bg_to_de`\n      : `${fieldName}_de_to_bg`;\n\n    const directionValue = (vocab as any)[directionField];\n    if (directionValue) {\n      return directionValue;\n    }\n\n    // Try parsing bilingual field (Bulgarian\\nGerman format)\n    const generalField = (vocab as any)[fieldName];\n    if (generalField && typeof generalField === 'string') {\n      // Check if field contains bilingual content separated by newline\n      const parts = generalField.split('\\n').filter(p => p.trim());\n\n      // If we have exactly 2 parts, assume first is Bulgarian, second is German\n      if (parts.length === 2) {\n        return isBgToDe ? (parts[0] || '') : (parts[1] || '');\n      }\n\n      // Otherwise return as-is (fallback to English or single-language content)\n      return generalField;\n    }\n\n    return '';\n  }\n  \n  private getCardText(vocab: VocabularyItem): CardText {\n    // Return appropriate text based on language direction\n    if (this.languageDirection === 'bg-de') {\n      // Bulgarian to German: show Bulgarian word, translate to German\n      return {\n        frontText: vocab.word || '',\n        backText: vocab.translation || ''\n      };\n    }\n\n    // German to Bulgarian: show German word, translate to Bulgarian\n    return {\n      frontText: vocab.translation || '',\n      backText: vocab.word || ''\n    };\n  }\n  \n  private flipCard(card: HTMLElement): void {\n    const isFlipped = card.classList.contains('flipped');\n    \n    if (isFlipped) {\n      card.classList.remove('flipped');\n      const currentLabel = card.getAttribute('aria-label') || '';\n      card.setAttribute('aria-label', currentLabel.replace('showing translation', 'showing word'));\n    } else {\n      card.classList.add('flipped');\n      const currentLabel = card.getAttribute('aria-label') || '';\n      card.setAttribute('aria-label', currentLabel.replace('showing word', 'showing translation'));\n    }\n    \n    // Update flip button text\n    const flipBtn = card.querySelector('.vocab-flip-btn');\n    if (flipBtn) {\n      flipBtn.setAttribute('aria-label', isFlipped ? 'Flip card to see translation' : 'Flip card to see word');\n    }\n  }\n  \n  private renderEmptyState(): void {\n    if (!this.grid) return;\n    \n    this.grid.innerHTML = `\n      <div class=\"vocab-empty-state\" role=\"status\">\n        <div class=\"empty-icon\">📚</div>\n        <h3>No vocabulary cards found</h3>\n        <p>Try adjusting your filters or check back later.</p>\n      </div>\n    `;\n  }\n  \n  private updateCardCount(): void {\n    if (this.cardCount) {\n      const count = this.filteredData.length;\n      this.cardCount.textContent = `${count} card${count === 1 ? '' : 's'}`;\n    }\n  }\n  \n  private handleKeyboardNavigation(e: KeyboardEvent): void {\n    const focusedCard = document.activeElement as HTMLElement;\n    if (!focusedCard || !focusedCard.classList?.contains?.('vocab-card')) {\n      return;\n    }\n    \n    const cards = [...(this.grid?.querySelectorAll?.('.vocab-card') || [])] as HTMLElement[];\n    const currentIndex = cards.indexOf(focusedCard);\n    \n    let nextIndex = currentIndex;\n    \n    switch (e.key) {\n    case 'ArrowRight':\n    case 'ArrowDown': {\n      nextIndex = Math.min(currentIndex + 1, cards.length - 1);\n      break;\n    }\n    case 'ArrowLeft':\n    case 'ArrowUp': {\n      nextIndex = Math.max(currentIndex - 1, 0);\n      break;\n    }\n    case 'Home': {\n      nextIndex = 0;\n      break;\n    }\n    case 'End': {\n      nextIndex = cards.length - 1;\n      break;\n    }\n    default: {\n      return;\n    }\n    }\n    \n    if (nextIndex !== currentIndex) {\n      e.preventDefault();\n      focusedCard.setAttribute('tabindex', '-1');\n      const nextCard = cards[nextIndex];\n      if (nextCard) {\n        nextCard.setAttribute('tabindex', '0');\n        nextCard.focus();\n      }\n    }\n  }\n  \n  private showLoading(show: boolean): void {\n    if (this.loading) {\n      this.loading.setAttribute('aria-hidden', (!show).toString());\n      this.loading.style.display = show ? 'flex' : 'none';\n    }\n  }\n  \n  private showError(show: boolean, message: string = ''): void {\n    if (this.error) {\n      this.error.setAttribute('aria-hidden', (!show).toString());\n      this.error.style.display = show ? 'block' : 'none';\n      \n      if (show && message) {\n        const errorText = this.error.querySelector('p');\n        if (errorText) {\n          errorText.textContent = `Failed to load vocabulary: ${message}`;\n        }\n      }\n    }\n  }\n  \n  \n  private escapeHtml(text: string): string {\n    const div = document.createElement('div');\n    div.textContent = text;\n    return div.innerHTML;\n  }\n  \n  private handleLanguageDirectionChange(e: CustomEvent): void {\n    this.languageDirection = e.detail.direction;\n    this.renderCards(); // Re-render cards with new direction\n  }\n\n  private announceToScreenReader(message: string): void {\n    const announcement = document.createElement('div');\n    announcement.setAttribute('aria-live', 'polite');\n    announcement.setAttribute('aria-atomic', 'true');\n    announcement.className = 'sr-only';\n    announcement.textContent = message;\n\n    document.body.append(announcement);\n\n    setTimeout(() => {\n      announcement.remove();\n    }, 1000);\n  }\n\n  /**\n   * Cleanup method to remove event listeners\n   * Prevents event listener accumulation (P1 bug fix)\n   */\n  cleanup(): void {\n    // Remove language direction listener\n    if (this.languageListenerAttached) {\n      document.removeEventListener('language-direction-changed', this.onLanguageDirectionChanged);\n      this.languageListenerAttached = false;\n    }\n  }\n}\n\n// Export for use in other modules\nexport default VocabCards;","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/vocabulary-adapter.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1150,1153],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1150,1153],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"unicorn/prefer-ternary","severity":2,"message":"This `if` statement can be replaced by a ternary expression.","line":187,"column":7,"nodeType":"IfStatement","messageId":"prefer-ternary","endLine":205,"endColumn":8}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Vocabulary Adapter\n * Provides backward compatibility and data transformation for vocabulary systems\n * BUGFIX: Added defensive checks in transformForDirection to handle non-array data\n * UPDATE: Now uses modular vocabulary API for lazy loading\n */\n\ninterface VocabularyItem {\n  id: string;\n  word: string;\n  translation: string;\n  level?: string;\n  category?: string;\n  difficulty?: number;\n  frequency?: number;\n  notes?: string;\n  notes_bg_to_de?: string;\n  notes_de_to_bg?: string;\n  etymology?: string;\n  cultural_note?: string;\n  linguistic_note?: string;\n  audio_url?: string;\n  examples?: Array<{\n    sentence: string;\n    translation: string;\n    context: string;\n  }>;\n}\n\ninterface TransformedVocabularyItem extends VocabularyItem {\n  displayWord: string;\n  displayTranslation: string;\n  sourceLanguage: string;\n  targetLanguage: string;\n}\n\ninterface VocabularyFilters {\n  level?: string;\n  category?: string;\n  search?: string;\n}\n\ninterface VocabularyAPI {\n  loadAll(): Promise<VocabularyItem[]>;\n  loadFiltered(filters: VocabularyFilters): Promise<VocabularyItem[]>;\n}\n\ndeclare global {\n  interface Window {\n    VocabularyAdapter: any; // Match the declaration in types.ts\n  }\n}\n\nclass VocabularyAdapter {\n  private vocabularyData: VocabularyItem[] = [];\n  private enhancedData: VocabularyItem[] = [];\n  private useModularAPI: boolean = false;\n\n  constructor() {\n    this.init();\n  }\n  \n  async init(): Promise<void> {\n    await this.loadData();\n  }\n  \n  async loadData(): Promise<void> {\n    // First try to load from modular API\n    try {\n      // Dynamic import to avoid loading if not needed\n      const { vocabularyAPI } = await import('./modules/vocabulary-api.js') as { vocabularyAPI: VocabularyAPI };\n      const allEntries = await vocabularyAPI.loadAll();\n      \n      if (Array.isArray(allEntries) && allEntries.length > 0) {\n        this.vocabularyData = allEntries;\n        this.useModularAPI = true;\n        console.log(`[VocabularyAdapter] Loaded ${allEntries.length} vocabulary items via modular API`);\n        return;\n      }\n    } catch (error) {\n      console.warn('[VocabularyAdapter] Modular API not available, falling back to embedded data:', error);\n    }\n    \n    // Fallback to embedded data\n    const vocabScript = document.querySelector('#vocabulary-data');\n    if (vocabScript) {\n      try {\n        let data = JSON.parse(vocabScript.textContent || '') as unknown;\n\n        // BUGFIX: Data might be double-encoded (JSON string containing JSON)\n        // The Hugo template embeds the JSON as a string within JSON\n        // If result is a string, parse again\n        if (typeof data === 'string') {\n          console.log('[VocabularyAdapter] Double-encoded data detected, parsing again');\n          data = JSON.parse(data) as VocabularyItem[];\n        }\n\n        this.vocabularyData = Array.isArray(data) ? data as VocabularyItem[] : [];\n\n        if (Array.isArray(data) && data.length > 0) {\n          console.log(`[VocabularyAdapter] Loaded ${data.length} vocabulary items from embedded data`);\n        } else if (!Array.isArray(data)) {\n          console.warn('[VocabularyAdapter] vocabularyData is not an array after parsing');\n        }\n      } catch (error) {\n        console.error('Failed to load vocabulary data:', error);\n        this.vocabularyData = [];\n      }\n    }\n    \n    // Load enhanced vocabulary data if available\n    const enhancedScript = document.querySelector('#enhanced-vocabulary-data');\n    if (enhancedScript) {\n      try {\n        let data = JSON.parse(enhancedScript.textContent || '') as unknown;\n\n        // Handle double-encoding\n        if (typeof data === 'string') {\n          data = JSON.parse(data) as VocabularyItem[];\n        }\n\n        // Skip if null or empty\n        if (data && data !== null && typeof data === 'object') {\n          this.enhancedData = Array.isArray(data) ? data as VocabularyItem[] : [];\n          if (this.enhancedData.length > 0) {\n            console.log(`[VocabularyAdapter] Loaded ${this.enhancedData.length} enhanced vocabulary items`);\n          }\n        } else {\n          this.enhancedData = [];\n        }\n      } catch {\n        console.warn('Enhanced vocabulary data not available or could not be parsed, using basic data');\n        this.enhancedData = [];\n      }\n    }\n  }\n  \n  // Get vocabulary data with enhanced fields if available\n  getVocabularyData(): VocabularyItem[] {\n    // Ensure both are arrays\n    const enhanced = Array.isArray(this.enhancedData) ? this.enhancedData : [];\n    const basic = Array.isArray(this.vocabularyData) ? this.vocabularyData : [];\n\n    if (enhanced.length > 0) {\n      return enhanced;\n    }\n    return basic;\n  }\n\n  // Async method to get filtered data using modular API when available\n  async getFilteredDataAsync(filters: VocabularyFilters = {}): Promise<VocabularyItem[]> {\n    if (this.useModularAPI) {\n      try {\n        const { vocabularyAPI } = await import('./modules/vocabulary-api.js') as { vocabularyAPI: VocabularyAPI };\n        return await vocabularyAPI.loadFiltered(filters);\n      } catch {\n        console.warn('[VocabularyAdapter] Failed to use modular API for filtering, falling back to sync method');\n      }\n    }\n    \n    // Fallback to synchronous filtering\n    return this.getFilteredData(filters);\n  }\n  \n  // Get specific vocabulary item by ID\n  getVocabularyItem(id: string): VocabularyItem | undefined {\n    const data = this.getVocabularyData();\n    return data.find(item => item.id === id);\n  }\n  \n  // Transform data for different learning directions\n  transformForDirection(data: VocabularyItem[] | VocabularyItem, direction: string): TransformedVocabularyItem[] {\n    // BUGFIX: Defensive programming to prevent \"e.map is not a function\" error\n    // Ensure data is an array before calling .map()\n    if (!Array.isArray(data)) {\n      console.warn('[VocabularyAdapter] transformForDirection received non-array:', typeof data, data);\n      // Try to convert to array if it's a single object\n      if (data && typeof data === 'object') {\n        data = [data];\n      } else {\n        console.error('[VocabularyAdapter] Cannot transform non-array data, returning empty array');\n        return [];\n      }\n    }\n\n    return data.map(item => {\n      if (direction === 'de-bg') {\n        // German to Bulgarian - swap fields\n        return {\n          ...item,\n          displayWord: item.translation || item.word,\n          displayTranslation: item.word,\n          sourceLanguage: 'de',\n          targetLanguage: 'bg'\n        };\n      } else {\n        // Bulgarian to German (default)\n        return {\n          ...item,\n          displayWord: item.word,\n          displayTranslation: item.translation || item.word,\n          sourceLanguage: 'bg',\n          targetLanguage: 'de'\n        };\n      }\n    });\n  }\n  \n  // Get items for specific learning direction (required by VocabularyPageModule)\n  getItemsForDirection(direction: string): TransformedVocabularyItem[] {\n    const data = this.getVocabularyData();\n    if (!Array.isArray(data)) {\n      console.warn('[VocabularyAdapter] getItemsForDirection: data is not array, returning empty');\n      return [];\n    }\n    return this.transformForDirection(data, direction);\n  }\n  \n  // Get filtered vocabulary data\n  getFilteredData(filters: VocabularyFilters = {}): VocabularyItem[] {\n    let data = this.getVocabularyData();\n    \n    if (!Array.isArray(data)) {\n      console.warn('[VocabularyAdapter] getFilteredData: data is not array, returning empty');\n      return [];\n    }\n    \n    if (filters.level) {\n      data = data.filter(item => item.level === filters.level);\n    }\n    \n    if (filters.category) {\n      data = data.filter(item => item.category === filters.category);\n    }\n    \n    if (filters.search) {\n      const searchTerm = filters.search.toLowerCase();\n      data = data.filter(item => \n        item.word.toLowerCase().includes(searchTerm) ||\n        (item.translation && item.translation.toLowerCase().includes(searchTerm))\n      );\n    }\n    \n    return data;\n  }\n}\n\n// Make globally available\nif (typeof window !== 'undefined') {\n  window.VocabularyAdapter = VocabularyAdapter;\n}\n\nexport { VocabularyAdapter, type VocabularyItem, type TransformedVocabularyItem, type VocabularyFilters };","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/assets/js/vocabulary.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[172,175],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[172,175],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[198,201],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[198,201],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[251,254],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[251,254],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[468,471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[468,471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[532,535],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[532,535],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[582,585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[582,585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[634,637],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[634,637],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[682,685],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[682,685],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[780,783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[780,783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[947,950],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[947,950],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1041,1044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1041,1044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1097,1100],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1097,1100],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1233,1236],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1233,1236],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1287,1290],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1287,1290],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1383,1386],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1383,1386],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1955,1958],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1955,1958],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2028,2031],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2028,2031],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2248,2251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2248,2251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2324,2327],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2324,2327],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":75,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2663,2666],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2663,2666],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":76,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2753,2756],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2753,2756],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2923,2926],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2923,2926],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3089,3092],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3089,3092],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3186,3189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3186,3189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3273,3276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3273,3276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3784,3787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3784,3787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4086,4089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4086,4089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":124,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4190,4193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4190,4193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":125,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4262,4265],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4262,4265],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":125,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4314,4317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4314,4317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":125,"column":119,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":125,"endColumn":122,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4366,4369],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4366,4369],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4422,4425],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4422,4425],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4491,4494],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4491,4494],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4603,4606],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4603,4606],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":96,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":99,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4678,4681],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4678,4681],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":137,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4791,4794],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4791,4794],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":138,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4871,4874],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4871,4874],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":147,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":147,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5162,5165],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5162,5165],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":148,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":148,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5210,5213],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5210,5213],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":152,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":152,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5286,5289],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5286,5289],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":153,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5361,5364],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5361,5364],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":174,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5915,5918],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5915,5918],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":174,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":174,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5971,5974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5971,5974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":175,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":175,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6017,6020],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6017,6020],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":176,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":176,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6065,6068],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6065,6068],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6147,6150],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6147,6150],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6318,6321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6318,6321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":191,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6534,6537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6534,6537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":191,"column":94,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":97,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6591,6594],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6591,6594],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6641,6644],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6641,6644],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":217,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7690,7693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7690,7693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":223,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8004,8007],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8004,8007],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":226,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":226,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8124,8127],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8124,8127],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":229,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":229,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8252,8255],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8252,8255],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":235,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":235,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8496,8499],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8496,8499],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":236,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8611,8614],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8611,8614],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":241,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":241,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8704,8707],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8704,8707],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":242,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":242,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8815,8818],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8815,8818],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":243,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":243,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8883,8886],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8883,8886],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":246,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":246,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9009,9012],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9009,9012],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":250,"column":15,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":18,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9125,9128],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9125,9128],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":254,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":254,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9204,9207],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9204,9207],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":265,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9557,9560],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9557,9560],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":266,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9636,9639],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9636,9639],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":272,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":272,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9899,9902],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9899,9902],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":279,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":279,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10093,10096],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10093,10096],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":294,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10617,10620],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10617,10620],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":67,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Simplified Vocabulary functionality - Global functions approach\n * No ES modules or classes, just simple global functions\n */\n\n// Extend global namespace\n(window as any).BgDeApp = (window as any).BgDeApp || {};\n\n// Vocabulary state\n((window as any).BgDeApp).vocabulary = {\n  data: [],\n  filteredData: [],\n  selectedWords: new Set<string>(),\n  filters: {\n    level: '',\n    category: '',\n    search: ''\n  }\n};\n\n// Initialize vocabulary functionality\n((window as any).BgDeApp).initVocabulary = function(): void {\n  ((window as any).BgDeApp).loadVocabularyData();\n  ((window as any).BgDeApp).bindVocabularyEvents();\n  ((window as any).BgDeApp).renderVocabulary();\n  ((window as any).BgDeApp).updateVocabularyStats();\n};\n\n// Load vocabulary data from Hugo template\n((window as any).BgDeApp).loadVocabularyData = function(): void {\n  const dataScript = document.querySelector('#vocabulary-data');\n  if (dataScript) {\n    try {\n      ((window as any).BgDeApp).vocabulary.data = JSON.parse(dataScript.textContent || '[]');\n      ((window as any).BgDeApp).vocabulary.filteredData = [...((window as any).BgDeApp).vocabulary.data];\n    } catch (error) {\n      console.error('Failed to parse vocabulary data:', error);\n      ((window as any).BgDeApp).vocabulary.data = [];\n      ((window as any).BgDeApp).vocabulary.filteredData = [];\n    }\n  }\n};\n\n// Bind vocabulary events\n((window as any).BgDeApp).bindVocabularyEvents = function(): void {\n  // Filter controls\n  const levelFilter = document.querySelector('#level-filter');\n  const categoryFilter = document.querySelector('#category-filter');\n  const searchInput = document.querySelector('#search-input');\n  const clearFilters = document.querySelector('#clear-filters');\n  const practiceSelected = document.querySelector('#practice-selected');\n\n  if (levelFilter) {\n    levelFilter.addEventListener('change', function(e: Event): void {\n      const target = e.target as HTMLSelectElement;\n      ((window as any).BgDeApp).vocabulary.filters.level = target.value;\n      ((window as any).BgDeApp).applyVocabularyFilters();\n    });\n  }\n\n  if (categoryFilter) {\n    categoryFilter.addEventListener('change', function(e: Event): void {\n      const target = e.target as HTMLSelectElement;\n      ((window as any).BgDeApp).vocabulary.filters.category = target.value;\n      ((window as any).BgDeApp).applyVocabularyFilters();\n    });\n  }\n\n  if (searchInput) {\n    let searchTimeout: number;\n    searchInput.addEventListener('input', function(e: Event): void {\n      clearTimeout(searchTimeout);\n      const target = e.target as HTMLInputElement;\n      searchTimeout = window.setTimeout(function(): void {\n        ((window as any).BgDeApp).vocabulary.filters.search = target.value.toLowerCase();\n        ((window as any).BgDeApp).applyVocabularyFilters();\n      }, 300);\n    });\n  }\n\n  if (clearFilters) {\n    clearFilters.addEventListener('click', function(): void {\n      ((window as any).BgDeApp).clearAllVocabularyFilters();\n    });\n  }\n\n  if (practiceSelected) {\n    practiceSelected.addEventListener('click', function(): void {\n      ((window as any).BgDeApp).startPracticeWithSelected();\n    });\n  }\n\n  // Card selection events\n  ((window as any).BgDeApp).bindCardSelectionEvents();\n};\n\n// Bind card selection events\n((window as any).BgDeApp).bindCardSelectionEvents = function(): void {\n  document.addEventListener('click', function(e: Event): void {\n    const target = e.target as HTMLElement;\n    \n    // Handle card selection\n    if (target.classList.contains('vocabulary-card') || target.closest('.vocabulary-card')) {\n      const card = target.classList.contains('vocabulary-card') ? target : target.closest('.vocabulary-card') as HTMLElement;\n      const word = card?.dataset.word;\n            \n      if (word) {\n        ((window as any).BgDeApp).toggleWordSelection(word, card);\n      }\n    }\n\n    // Handle flip button\n    if (target.classList.contains('flip-btn') || target.closest('.flip-btn')) {\n      e.preventDefault();\n      const card = target.closest('.vocabulary-card') as HTMLElement;\n      if (card) {\n        ((window as any).BgDeApp).flipVocabularyCard(card);\n      }\n    }\n  });\n};\n\n// Apply vocabulary filters\n((window as any).BgDeApp).applyVocabularyFilters = function(): void {\n  ((window as any).BgDeApp).vocabulary.filteredData = ((window as any).BgDeApp).vocabulary.data.filter(function(item: any): boolean {\n    // Level filter\n    if (((window as any).BgDeApp).vocabulary.filters.level && item.level !== ((window as any).BgDeApp).vocabulary.filters.level) {\n      return false;\n    }\n\n    // Category filter\n    if (((window as any).BgDeApp).vocabulary.filters.category && item.category !== ((window as any).BgDeApp).vocabulary.filters.category) {\n      return false;\n    }\n\n    // Search filter\n    if (((window as any).BgDeApp).vocabulary.filters.search) {\n      const searchTerm = ((window as any).BgDeApp).vocabulary.filters.search;\n      return item.word.toLowerCase().includes(searchTerm) ||\n             item.translation.toLowerCase().includes(searchTerm) ||\n             (item.notes && item.notes.toLowerCase().includes(searchTerm));\n    }\n\n    return true;\n  });\n\n  ((window as any).BgDeApp).renderVocabulary();\n  ((window as any).BgDeApp).updateVocabularyStats();\n};\n\n// Clear all filters\n((window as any).BgDeApp).clearAllVocabularyFilters = function(): void {\n  ((window as any).BgDeApp).vocabulary.filters = {\n    level: '',\n    category: '',\n    search: ''\n  };\n\n  // Reset form controls\n  const levelFilter = document.querySelector('#level-filter') as HTMLSelectElement;\n  const categoryFilter = document.querySelector('#category-filter') as HTMLSelectElement;\n  const searchInput = document.querySelector('#search-input') as HTMLInputElement;\n\n  if (levelFilter) {\n    levelFilter.value = '';\n  }\n  if (categoryFilter) {\n    categoryFilter.value = '';\n  }\n  if (searchInput) {\n    searchInput.value = '';\n  }\n\n  ((window as any).BgDeApp).vocabulary.filteredData = [...((window as any).BgDeApp).vocabulary.data];\n  ((window as any).BgDeApp).renderVocabulary();\n  ((window as any).BgDeApp).updateVocabularyStats();\n};\n\n// Render vocabulary cards\n((window as any).BgDeApp).renderVocabulary = function(): void {\n  const container = document.querySelector('#vocabulary-grid');\n  if (!container) {\n    return;\n  }\n\n  if (((window as any).BgDeApp).vocabulary.filteredData.length === 0) {\n    container.innerHTML = '<div class=\"no-results\">No vocabulary items found matching your criteria.</div>';\n    return;\n  }\n\n  container.innerHTML = ((window as any).BgDeApp).vocabulary.filteredData.map(function(item: any): string {\n    const isSelected = ((window as any).BgDeApp).vocabulary.selectedWords.has(item.word);\n    return `\n            <div class=\"vocabulary-card ${isSelected ? 'selected' : ''}\" data-word=\"${item.word}\">\n                <div class=\"card-inner\">\n                    <div class=\"card-front\">\n                        <div class=\"word\">${item.word}</div>\n                        <div class=\"word-meta\">\n                            <span class=\"level-badge\">${item.level}</span>\n                            <span class=\"category-tag\">${item.category}</span>\n                        </div>\n                    </div>\n                    <div class=\"card-back hidden\">\n                        <div class=\"translation\">${item.translation}</div>\n                        ${item.notes ? `<div class=\"notes\">${item.notes}</div>` : ''}\n                    </div>\n                </div>\n                <div class=\"card-actions\">\n                    <button class=\"flip-btn\">Flip</button>\n                </div>\n            </div>\n        `;\n  }).join('');\n};\n\n// Update vocabulary stats\n((window as any).BgDeApp).updateVocabularyStats = function(): void {\n  const totalCount = document.querySelector('#total-count');\n  const filteredCount = document.querySelector('#filtered-count');\n  const selectedCount = document.querySelector('#selected-count');\n\n  if (totalCount) {\n    totalCount.textContent = ((window as any).BgDeApp).vocabulary.data.length.toString();\n  }\n  if (filteredCount) {\n    filteredCount.textContent = ((window as any).BgDeApp).vocabulary.filteredData.length.toString();\n  }\n  if (selectedCount) {\n    selectedCount.textContent = ((window as any).BgDeApp).vocabulary.selectedWords.size.toString();\n  }\n\n  // Update practice button state\n  const practiceBtn = document.querySelector('#practice-selected') as HTMLButtonElement;\n  if (practiceBtn) {\n    practiceBtn.disabled = ((window as any).BgDeApp).vocabulary.selectedWords.size === 0;\n    practiceBtn.textContent = `Practice Selected (${((window as any).BgDeApp).vocabulary.selectedWords.size})`;\n  }\n};\n\n// Toggle word selection\n((window as any).BgDeApp).toggleWordSelection = function(word: string, cardElement: HTMLElement): void {\n  if (((window as any).BgDeApp).vocabulary.selectedWords.has(word)) {\n    ((window as any).BgDeApp).vocabulary.selectedWords.delete(word);\n    cardElement.classList.remove('selected');\n  } else {\n    ((window as any).BgDeApp).vocabulary.selectedWords.add(word);\n    cardElement.classList.add('selected');\n  }\n    \n  ((window as any).BgDeApp).updateVocabularyStats();\n};\n\n// Flip vocabulary card\n((window as any).BgDeApp).flipVocabularyCard = function(cardElement: HTMLElement): void {\n  const front = cardElement.querySelector('.card-front');\n  const back = cardElement.querySelector('.card-back');\n    \n  if (front && back) {\n    front.classList.toggle('hidden');\n    back.classList.toggle('hidden');\n  }\n};\n\n// Start practice with selected words\n((window as any).BgDeApp).startPracticeWithSelected = function(): void {\n  if (((window as any).BgDeApp).vocabulary.selectedWords.size === 0) {\n    alert('Please select some words to practice.');\n    return;\n  }\n\n  // Store selected words in localStorage for practice page\n  localStorage.setItem('bgde:practice_selection', JSON.stringify([...((window as any).BgDeApp).vocabulary.selectedWords]));\n    \n  // Navigate to practice page (relative to parent)\n  window.location.href = '../practice/';\n};\n\n// Utility function to shuffle array\n((window as any).BgDeApp).shuffleArray = function<T>(array: T[]): T[] {\n  const shuffled = [...array];\n  for (let i = shuffled.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    const temp = shuffled[i]!;\n    shuffled[i] = shuffled[j]!;\n    shuffled[j] = temp;\n  }\n  return shuffled;\n};\n\n// Initialize when DOM is ready\ndocument.addEventListener('DOMContentLoaded', function(): void {\n  // Only initialize if we're on the vocabulary page\n  if (document.querySelector('#vocabulary-grid')) {\n    ((window as any).BgDeApp).initVocabulary();\n  }\n});","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/add-direction-notes.mjs","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'category' is assigned a value but never used.","line":20,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":38},{"ruleId":"no-unused-vars","severity":2,"message":"'etymology' is assigned a value but never used.","line":20,"column":40,"nodeType":"Identifier","messageId":"unusedVar","endLine":20,"endColumn":49},{"ruleId":"no-unused-vars","severity":2,"message":"'category' is assigned a value but never used.","line":56,"column":30,"nodeType":"Identifier","messageId":"unusedVar","endLine":56,"endColumn":38},{"ruleId":"no-unused-vars","severity":2,"message":"'translation' is assigned a value but never used.","line":144,"column":27,"nodeType":"Identifier","messageId":"unusedVar","endLine":144,"endColumn":38},{"ruleId":"no-unused-vars","severity":2,"message":"'level' is assigned a value but never used.","line":182,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":182,"endColumn":16},{"ruleId":"unicorn/no-process-exit","severity":2,"message":"Only use `process.exit()` in CLI apps. Throw an error instead.","line":267,"column":5,"nodeType":"CallExpression","messageId":"no-process-exit","endLine":267,"endColumn":20},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over an async function `addDirectionNotes` call.","line":271,"column":1,"nodeType":"CallExpression","messageId":"identifier","endLine":271,"endColumn":20,"suggestions":[{"messageId":"add-await","fix":{"range":[7785,7785],"text":"await "},"data":{"name":"addDirectionNotes"},"desc":"Insert `await`."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file add-direction-notes.mjs\n * @description Adds comprehensive direction-specific learning notes to all vocabulary\n * @purpose Enable proper bidirectional learning with language-specific explanations\n */\n\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\nconst VOCAB_PATH = path.join(__dirname, '../data/vocabulary.json');\n\n/**\n * Generates German explanation for German speakers learning Bulgarian\n * @param {Object} entry - Vocabulary entry\n * @returns {string} German explanation\n */\nfunction generateNotesDeToБg(entry) {\n  const { word, translation, category, etymology, linguistic_note } = entry;\n  \n  // Extract key information\n  const wordParts = analyzeWord(word);\n  let explanation = `Für Deutschsprachige: '${word}' ≈ '${translation}'`;\n  \n  // Add word breakdown if compound or has clear root\n  if (wordParts.isCompound) {\n    explanation += `; zusammengesetzt aus '${wordParts.parts.join(\"' + '\")}'`;\n  } else if (wordParts.root) {\n    explanation += `; von '${wordParts.root}'`;\n  }\n  \n  // Add pronunciation hint\n  if (linguistic_note && linguistic_note.includes('Stress')) {\n    const stressMatch = linguistic_note.match(/stress.*?[:：]\\s*(.+?)(?:\\.|$)/i);\n    if (stressMatch) {\n      explanation += `. Betonung: ${stressMatch[1]}`;\n    }\n  }\n  \n  // Add grammatical info\n  explanation += `. ${getGrammarNote(entry, 'de')}`;\n  \n  // Add usage level\n  explanation += ` ${getUsageLevel(entry, 'de')}`;\n  \n  return explanation.trim();\n}\n\n/**\n * Generates Bulgarian explanation for Bulgarian speakers learning German\n * @param {Object} entry - Vocabulary entry\n * @returns {string} Bulgarian explanation\n */\nfunction generateNotesBgToDe(entry) {\n  const { word, translation, category } = entry;\n  \n  // Bulgarian explanations in Bulgarian\n  let explanation = `За българите: '${word}' на немски е '${translation}'`;\n  \n  // Add German word breakdown if compound\n  const germanParts = analyzeGermanWord(translation);\n  if (germanParts.isCompound) {\n    explanation += `; немската дума се състои от '${germanParts.parts.join(\"' + '\")}'`;\n  }\n  \n  // Add grammatical comparison\n  explanation += `. ${getGrammarNote(entry, 'bg')}`;\n  \n  // Add usage context\n  explanation += ` ${getUsageLevel(entry, 'bg')}`;\n  \n  return explanation.trim();\n}\n\n/**\n * Analyzes Bulgarian word structure\n */\nfunction analyzeWord(word) {\n  const result = { isCompound: false, parts: [], root: null };\n  \n  // Common Bulgarian compound patterns\n  if (word.includes(' ')) {\n    result.isCompound = true;\n    result.parts = word.split(' ');\n    return result;\n  }\n  \n  // Known roots and compounds\n  const compoundPatterns = {\n    'Добро утро': { parts: ['добро', 'утро'] },\n    'Добър ден': { parts: ['добър', 'ден'] },\n    'Добър вечер': { parts: ['добър', 'вечер'] },\n    'Лека нощ': { parts: ['лека', 'нощ'] },\n    'Благодаря': { root: 'благо + даря' },\n    'Довиждане': { root: 'до + виждане' },\n    'Училище': { root: 'уча (lernen)' },\n    'Семейство': { root: 'семе (Samen)' },\n    'Здравей': { root: 'здрав (gesund)' }\n  };\n  \n  if (compoundPatterns[word]) {\n    const pattern = compoundPatterns[word];\n    if (pattern.parts) {\n      result.isCompound = true;\n      result.parts = pattern.parts;\n    }\n    if (pattern.root) {\n      result.root = pattern.root;\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Analyzes German word structure\n */\nfunction analyzeGermanWord(word) {\n  const result = { isCompound: false, parts: [] };\n  \n  // Common German compounds\n  const compounds = {\n    'Guten Morgen': ['Guten', 'Morgen'],\n    'Guten Tag': ['Guten', 'Tag'],\n    'Guten Abend': ['Guten', 'Abend'],\n    'Gute Nacht': ['Gute', 'Nacht'],\n    'Auf Wiedersehen': ['Auf', 'Wiedersehen'],\n    'Es tut mir leid': ['Es tut mir leid']\n  };\n  \n  if (compounds[word]) {\n    result.isCompound = true;\n    result.parts = compounds[word];\n  }\n  \n  return result;\n}\n\n/**\n * Gets grammar note in target language\n */\nfunction getGrammarNote(entry, targetLang) {\n  const { category, word, translation } = entry;\n  \n  if (targetLang === 'de') {\n    // German explanations\n    const notes = {\n      'Begrüßung': 'Feste Redewendung.',\n      'Ausdruck': 'Höflichkeitsausdruck.',\n      'Substantiv': word.endsWith('а') || word.endsWith('я') ? 'Femininum.' : \n        (word.endsWith('о') || word.endsWith('е') ? 'Neutrum.' : 'Maskulinum.'),\n      'Verb': 'Bulgarisches Verb.',\n      'Adjektiv': 'Bulgarisches Adjektiv (flektiert nach Geschlecht).',\n      'Adverb': 'Unveränderliches Adverb.',\n      'Zahl': 'Zahlwort.',\n      'Zeit': 'Zeitbegriff.',\n      'Pronomen': 'Pronomen.'\n    };\n    return notes[category] || 'Bulgarisches Wort.';\n  } else {\n    // Bulgarian explanations\n    const notes = {\n      'Begrüßung': 'Устойчив израз за поздрав.',\n      'Ausdruck': 'Учтив израз.',\n      'Substantiv': 'Съществително име на немски.',\n      'Verb': 'Глагол на немски.',\n      'Adjektiv': 'Прилагателно на немски (променя се по род).',\n      'Adverb': 'Наречие.',\n      'Zahl': 'Числително.',\n      'Zeit': 'Понятие за време.',\n      'Pronomen': 'Местоимение.'\n    };\n    return notes[category] || 'Немска дума.';\n  }\n}\n\n/**\n * Gets usage level description\n */\nfunction getUsageLevel(entry, targetLang) {\n  const { level, frequency } = entry;\n  \n  if (targetLang === 'de') {\n    if (frequency >= 90) {\n      return 'Sehr häufig verwendet.';\n    }\n    if (frequency >= 70) {\n      return 'Häufig verwendet.';\n    }\n    if (frequency >= 50) {\n      return 'Mäßig häufig.';\n    }\n    return 'Seltener verwendet.';\n  } else {\n    if (frequency >= 90) {\n      return 'Много често използвана дума.';\n    }\n    if (frequency >= 70) {\n      return 'Често използвана.';\n    }\n    if (frequency >= 50) {\n      return 'Умерено често.';\n    }\n    return 'По-рядко използвана.';\n  }\n}\n\n/**\n * Main enhancement function\n */\nasync function addDirectionNotes() {\n  console.log('📚 Loading vocabulary...');\n  \n  try {\n    const data = await fs.readFile(VOCAB_PATH, 'utf8');\n    const vocabulary = JSON.parse(data);\n    \n    console.log(`✅ Loaded ${vocabulary.length} entries`);\n    \n    // Count incomplete\n    const incomplete = vocabulary.filter(entry => \n      !entry.notes_de_to_bg || !entry.notes_bg_to_de\n    );\n    \n    console.log(`🔄 Adding direction notes to ${incomplete.length} entries...`);\n    \n    // Enhance all entries\n    const enhanced = vocabulary.map((entry, index) => {\n      const result = { ...entry };\n      \n      // Add German → Bulgarian notes if missing\n      if (!result.notes_de_to_bg) {\n        result.notes_de_to_bg = generateNotesDeToБg(entry);\n      }\n      \n      // Add Bulgarian → German notes if missing\n      if (!result.notes_bg_to_de) {\n        result.notes_bg_to_de = generateNotesBgToDe(entry);\n      }\n      \n      if (index % 20 === 0) {\n        console.log(`   Processing: ${index + 1}/${vocabulary.length}...`);\n      }\n      \n      return result;\n    });\n    \n    // Backup\n    const backupPath = VOCAB_PATH.replace('.json', `.backup-direction-${Date.now()}.json`);\n    await fs.writeFile(backupPath, data, 'utf8');\n    console.log(`💾 Backup: ${path.basename(backupPath)}`);\n    \n    // Save\n    await fs.writeFile(VOCAB_PATH, JSON.stringify(enhanced, null, 2), 'utf8');\n    console.log('✅ Enhanced vocabulary saved');\n    \n    // Stats\n    const complete = enhanced.filter(e => e.notes_de_to_bg && e.notes_bg_to_de);\n    console.log('\\n📊 Statistics:');\n    console.log(`   Total: ${enhanced.length}`);\n    console.log(`   Complete bidirectional notes: ${complete.length}`);\n    console.log(`   Coverage: ${Math.round(complete.length / enhanced.length * 100)}%`);\n    \n  } catch (error) {\n    console.error('❌ Error:', error.message);\n    process.exit(1);\n  }\n}\n\naddDirectionNotes();\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/analyze-vocabulary.js","messages":[{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":3,"column":22,"nodeType":"Identifier","messageId":"error/identifier","endLine":3,"endColumn":29,"suggestions":[{"messageId":"suggestion/import","fix":{"range":[21,71],"text":"import { execSync } from 'node:child_process'"},"data":{"name":"require"},"desc":"Switch to `import`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":4,"column":12,"nodeType":"Identifier","messageId":"error/identifier","endLine":4,"endColumn":19,"suggestions":[{"messageId":"suggestion/import","fix":{"range":[73,102],"text":"import fs from 'node:fs'"},"data":{"name":"require"},"desc":"Switch to `import`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":5,"column":14,"nodeType":"Identifier","messageId":"error/identifier","endLine":5,"endColumn":21,"suggestions":[{"messageId":"suggestion/import","fix":{"range":[104,137],"text":"import path from 'node:path'"},"data":{"name":"require"},"desc":"Switch to `import`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":6,"column":23,"nodeType":"Identifier","messageId":"error/identifier","endLine":6,"endColumn":30,"suggestions":[{"messageId":"suggestion/import","fix":{"range":[139,181],"text":"import { promisify } from 'node:util'"},"data":{"name":"require"},"desc":"Switch to `import`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"__dirname\".","line":14,"column":33,"nodeType":"Identifier","messageId":"error/identifier","endLine":14,"endColumn":42,"suggestions":[{"messageId":"suggestion/import-meta-dirname","fix":{"range":[372,381],"text":"import.meta.dirname"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `import.meta.dirname`."},{"messageId":"suggestion/import-meta-url-to-dirname","fix":{"range":[372,381],"text":"path.dirname(url.fileURLToPath(import.meta.url))"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `…(import.meta.url)`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"__dirname\".","line":18,"column":39,"nodeType":"Identifier","messageId":"error/identifier","endLine":18,"endColumn":48,"suggestions":[{"messageId":"suggestion/import-meta-dirname","fix":{"range":[558,567],"text":"import.meta.dirname"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `import.meta.dirname`."},{"messageId":"suggestion/import-meta-url-to-dirname","fix":{"range":[558,567],"text":"path.dirname(url.fileURLToPath(import.meta.url))"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `…(import.meta.url)`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"__dirname\".","line":26,"column":44,"nodeType":"Identifier","messageId":"error/identifier","endLine":26,"endColumn":53,"suggestions":[{"messageId":"suggestion/import-meta-dirname","fix":{"range":[982,991],"text":"import.meta.dirname"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `import.meta.dirname`."},{"messageId":"suggestion/import-meta-url-to-dirname","fix":{"range":[982,991],"text":"path.dirname(url.fileURLToPath(import.meta.url))"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `…(import.meta.url)`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"__dirname\".","line":35,"column":34,"nodeType":"Identifier","messageId":"error/identifier","endLine":35,"endColumn":43,"suggestions":[{"messageId":"suggestion/import-meta-dirname","fix":{"range":[1474,1483],"text":"import.meta.dirname"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `import.meta.dirname`."},{"messageId":"suggestion/import-meta-url-to-dirname","fix":{"range":[1474,1483],"text":"path.dirname(url.fileURLToPath(import.meta.url))"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `…(import.meta.url)`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":139,"column":5,"nodeType":"Identifier","messageId":"error/identifier","endLine":139,"endColumn":12},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"module\".","line":139,"column":22,"nodeType":"Identifier","messageId":"error/identifier","endLine":139,"endColumn":28},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over an async function `analyzeVocabulary` call.","line":140,"column":3,"nodeType":"CallExpression","messageId":"identifier","endLine":140,"endColumn":22,"suggestions":[{"messageId":"add-await","fix":{"range":[4477,4477],"text":"await "},"data":{"name":"analyzeVocabulary"},"desc":"Insert `await`."}]}],"suppressedMessages":[],"errorCount":11,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nconst { execSync } = require('node:child_process');\nconst fs = require('node:fs');\nconst path = require('node:path');\nconst { promisify } = require('node:util');\n\nconst readFile = promisify(fs.readFile);\nconst writeFile = promisify(fs.writeFile);\n\nasync function analyzeVocabulary() {\n  try {\n    // 1. Load vocabulary\n    const vocabPath = path.join(__dirname, '..', 'data', 'vocabulary.json');\n    const vocabulary = JSON.parse(await readFile(vocabPath, 'utf8'));\n\n    // 2. Run semantic chunking\n    const chunkPromptPath = path.join(__dirname, '..', '.claude', 'prompts', 'semantic-chunk.txt');\n    const chunkPrompt = await readFile(chunkPromptPath, 'utf8');\n    \n    console.log('Running semantic analysis...');\n    const chunkCmd = `claude -p \"${chunkPrompt}\\n\\nVocabulary to analyze: ${JSON.stringify(vocabulary)}\"`;\n    const chunks = execSync(chunkCmd, { encoding: 'utf8' });\n\n    // 3. Validate progression\n    const validationPromptPath = path.join(__dirname, '..', '.claude', 'prompts', 'validate-progression.txt');\n    const validationPrompt = await readFile(validationPromptPath, 'utf8');\n    \n    console.log('Validating learning progression...');\n    const validateCmd = `claude -p \"${validationPrompt}\\n\\nVocabulary to validate: ${JSON.stringify(vocabulary)}\"`;\n    const validation = execSync(validateCmd, { encoding: 'utf8' });\n\n    // 4. Save results\n    const timestamp = new Date().toISOString();\n    const resultsDir = path.join(__dirname, '..', 'data', 'vocabulary-analysis');\n    \n    if (!fs.existsSync(resultsDir)) {\n      fs.mkdirSync(resultsDir, { recursive: true });\n    }\n\n    const results = {\n      timestamp,\n      vocabulary_count: vocabulary.length,\n      semantic_analysis: JSON.parse(chunks),\n      progression_validation: JSON.parse(validation)\n    };\n\n    await writeFile(\n      path.join(resultsDir, `analysis-${timestamp}.json`),\n      JSON.stringify(results, null, 2)\n    );\n\n    // 5. Generate a human-readable report\n    const reportPath = path.join(resultsDir, `analysis-${timestamp}.md`);\n    const report = generateReport(results);\n    await writeFile(reportPath, report);\n\n    console.log(`\nVocabulary Analysis Complete\n==========================\nTotal entries analyzed: ${vocabulary.length}\nResults saved to: \n- JSON: data/vocabulary-analysis/analysis-${timestamp}.json\n- Report: data/vocabulary-analysis/analysis-${timestamp}.md\n\nNext steps:\n1. Review the semantic groupings in the report\n2. Check the progression validation findings\n3. Consider suggested improvements\n4. Run tests before applying any changes\n    `);\n\n  } catch (error) {\n    console.error('Error analyzing vocabulary:', error);\n    process.exit(1);\n  }\n}\n\nfunction generateReport(results) {\n  const { timestamp, vocabulary_count, semantic_analysis, progression_validation } = results;\n  \n  return `# Vocabulary Analysis Report\nGenerated: ${timestamp}\nTotal entries: ${vocabulary_count}\n\n## Semantic Analysis\n${formatSemanticAnalysis(semantic_analysis)}\n\n## Progression Validation\n${formatProgressionValidation(progression_validation)}\n\n## Recommendations\n${generateRecommendations(semantic_analysis, progression_validation)}\n`;\n}\n\nfunction formatSemanticAnalysis(analysis) {\n  // Format the semantic groups in a readable way\n  return Object.entries(analysis.semantic_groups || {})\n    .map(([theme, data]) => `\n### ${theme}\n- Core concepts: ${data.core_concepts.join(', ')}\n- Derived terms: ${data.derived_terms.join(', ')}\n- Usage contexts: ${data.usage_contexts.join(', ')}\n- Suggested progression: ${data.progression.join(' → ')}\n- Related groups: ${data.related_groups.join(', ')}\n`).join('\\n');\n}\n\nfunction formatProgressionValidation(validation) {\n  // Format the validation results clearly\n  return Object.entries(validation)\n    .map(([aspect, details]) => `\n### ${aspect}\n${details}\n`).join('\\n');\n}\n\nfunction generateRecommendations(semantic_analysis, progression_validation) {\n  // Generate actionable recommendations based on the analysis\n  const recommendations = [];\n  \n  // Add semantic grouping recommendations\n  if (semantic_analysis.recommendations) {\n    recommendations.push(...semantic_analysis.recommendations);\n  }\n  \n  // Add progression-based recommendations\n  if (progression_validation.recommendations) {\n    recommendations.push(...progression_validation.recommendations);\n  }\n  \n  return recommendations\n    .map(rec => `- ${rec}`)\n    .join('\\n');\n}\n\n// If called directly\nif (require.main === module) {\n  analyzeVocabulary();\n}","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/check-esm.mjs","messages":[{"ruleId":"unicorn/consistent-function-scoping","severity":2,"message":"Move arrow function 'elementFactory' to the outer scope.","line":96,"column":29,"nodeType":"ArrowFunctionExpression","messageId":"consistent-function-scoping","endLine":96,"endColumn":31},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over using a promise chain.","line":259,"column":8,"nodeType":"Identifier","messageId":"promise","endLine":259,"endColumn":13}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * ESM syntax check for assets/js without external dependencies.\n * The script copies modules to a temporary directory, rewrites relative\n * imports to use `.mjs`, and dynamically imports them in a stubbed DOM\n * environment to ensure they parse correctly.\n */\n\nimport { mkdtemp, readdir, mkdir, readFile, writeFile, rm } from 'node:fs/promises';\nimport os from 'node:os';\nimport path from 'node:path';\nimport { fileURLToPath, pathToFileURL } from 'node:url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nconst rootDir = path.resolve(__dirname, '..');\nconst jsDir = path.join(rootDir, 'assets', 'js');\n\nasync function collectFiles(dir, extension) {\n  const entries = await readdir(dir, { withFileTypes: true });\n  const files = [];\n\n  for (const entry of entries) {\n    if (entry.name.startsWith('.')) {\n      continue;\n    }\n    const fullPath = path.join(dir, entry.name);\n    if (entry.isDirectory()) {\n      const nested = await collectFiles(fullPath, extension);\n      files.push(...nested);\n    } else if (entry.isFile() && entry.name.endsWith(extension)) {\n      files.push(fullPath);\n    }\n  }\n\n  return files;\n}\n\nfunction rewriteImports(code) {\n  const patterns = [\n    /(from\\s+[\"'])(\\.{1,2}\\/[^\"']+?)\\.js([\"'])/g,\n    /(import\\s*\\(\\s*[\"'])(\\.{1,2}\\/[^\"']+?)\\.js([\"']\\s*\\))/g,\n    /(import\\s+[\"'])(\\.{1,2}\\/[^\"']+?)\\.js([\"'])/g,\n    /(export\\s+\\*\\s+from\\s+[\"'])(\\.{1,2}\\/[^\"']+?)\\.js([\"'])/g\n  ];\n\n  let rewritten = code;\n  for (const pattern of patterns) {\n    rewritten = rewritten.replace(pattern, (_, start, specifier, end) => {\n      return `${start}${specifier}.mjs${end}`;\n    });\n  }\n\n  return rewritten;\n}\n\nasync function copyModulesToTemp(srcDir) {\n  const tempRoot = await mkdtemp(path.join(os.tmpdir(), 'bgde-esm-'));\n\n  async function copyRecursive(src, dest) {\n    await mkdir(dest, { recursive: true });\n    const entries = await readdir(src, { withFileTypes: true });\n\n    for (const entry of entries) {\n      if (entry.name.startsWith('.')) {\n        continue;\n      }\n      const srcPath = path.join(src, entry.name);\n      if (entry.isDirectory()) {\n        await copyRecursive(srcPath, path.join(dest, entry.name));\n      } else if (entry.isFile() && entry.name.endsWith('.js')) {\n        const code = await readFile(srcPath, 'utf8');\n        const rewritten = rewriteImports(code);\n        const destFileName = `${entry.name.slice(0, -3)}.mjs`;\n        await writeFile(path.join(dest, destFileName), rewritten, 'utf8');\n      }\n    }\n  }\n\n  await copyRecursive(srcDir, tempRoot);\n  return tempRoot;\n}\n\nfunction createDomStubs() {\n  const eventListeners = new Map();\n  const addEventListener = (type, handler) => {\n    if (!eventListeners.has(type)) {\n      eventListeners.set(type, new Set());\n    }\n    eventListeners.get(type).add(handler);\n  };\n  const removeEventListener = (type, handler) => {\n    eventListeners.get(type)?.delete(handler);\n  };\n\n  const elementFactory = () => ({\n    setAttribute: () => {},\n    appendChild: () => {},\n    removeChild: () => {},\n    addEventListener: () => {},\n    removeEventListener: () => {},\n    focus: () => {},\n    classList: { add: () => {}, remove: () => {} },\n    style: {},\n    innerHTML: '',\n    textContent: ''\n  });\n\n  const storage = new Map();\n  const localStorage = {\n    getItem: (key) => (storage.has(key) ? storage.get(key) : null),\n    setItem: (key, value) => storage.set(String(key), String(value)),\n    removeItem: (key) => storage.delete(key),\n    clear: () => storage.clear(),\n    key: (index) => [...storage.keys()][index] ?? null,\n    get length() {\n      return storage.size;\n    }\n  };\n\n  const documentStub = {\n    addEventListener,\n    removeEventListener,\n    querySelector: () => null,\n    querySelectorAll: () => [],\n    getElementById: () => elementFactory(),\n    createElement: elementFactory,\n    createTextNode: (text) => ({ textContent: text }),\n    body: {\n      appendChild: () => {},\n      removeChild: () => {},\n      classList: { add: () => {}, remove: () => {} }\n    },\n    head: {\n      appendChild: () => {}\n    },\n    documentElement: {\n      setAttribute: () => {},\n      style: { setProperty: () => {} },\n      classList: { add: () => {}, remove: () => {} }\n    }\n  };\n\n  const serviceWorkerStub = {\n    register: () =>\n      Promise.resolve({\n        addEventListener: () => {},\n        removeEventListener: () => {},\n        active: null,\n        update: () => Promise.resolve()\n      }),\n    ready: Promise.resolve({\n      addEventListener: () => {},\n      removeEventListener: () => {}\n    }),\n    addEventListener: () => {},\n    removeEventListener: () => {}\n  };\n\n  const windowStub = {\n    addEventListener,\n    removeEventListener,\n    dispatchEvent: () => {},\n    localStorage,\n    navigator: {\n      serviceWorker: serviceWorkerStub\n    },\n    location: {\n      hostname: 'localhost',\n      href: 'http://localhost/',\n      protocol: 'http:',\n      pathname: '/',\n      search: '',\n      hash: ''\n    },\n    matchMedia: () => ({\n      matches: false,\n      addEventListener: () => {},\n      removeEventListener: () => {},\n      addListener: () => {},\n      removeListener: () => {}\n    }),\n    BgDeApp: {},\n    CustomEvent: class {\n      constructor(type, init = {}) {\n        this.type = type;\n        this.detail = init.detail ?? null;\n      }\n    }\n  };\n\n  globalThis.window = windowStub;\n  globalThis.document = documentStub;\n  globalThis.CustomEvent = windowStub.CustomEvent;\n  globalThis.localStorage = localStorage;\n  globalThis.BgDeApp = windowStub.BgDeApp;\n  globalThis.setInterval = () => 0;\n  globalThis.clearInterval = () => {};\n  Object.defineProperty(globalThis, 'navigator', {\n    configurable: true,\n    writable: true,\n    value: windowStub.navigator\n  });\n}\n\nasync function main() {\n  const tempDir = await copyModulesToTemp(jsDir);\n  const files = await collectFiles(tempDir, '.mjs');\n  const failures = [];\n\n  createDomStubs();\n\n  const skipFiles = new Set([\n    'vocabulary-old.js',\n    'flashcards.js',\n    'vocab-cards.js',\n    'mobile-menu.js'\n  ]);\n\n  for (const filePath of files) {\n    const relativeOriginal = path\n      .relative(tempDir, filePath)\n      .replace(/\\.mjs$/, '.js');\n\n    if (skipFiles.has(relativeOriginal)) {\n      continue;\n    }\n\n    const url = pathToFileURL(filePath).href;\n    try {\n      await import(url);\n    } catch (error) {\n      failures.push({\n        file: relativeOriginal,\n        error\n      });\n    }\n  }\n\n  await rm(tempDir, { recursive: true, force: true });\n\n  if (failures.length > 0) {\n    console.error('ESM syntax check failed:\\n');\n    for (const failure of failures) {\n      console.error(`- ${failure.file}`);\n      console.error(`  ${failure.error.message}`);\n      if (failure.error.stack) {\n        console.error(`  ${failure.error.stack.split('\\n').slice(1, 3).join('\\n  ')}\\n`);\n      } else {\n        console.error('');\n      }\n    }\n    process.exit(1);\n  }\n\n  console.log(`Checked ${files.length} modules – no syntax errors detected.`);\n}\n\nmain().catch(async (error) => {\n  console.error('Failed to run ESM check:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/clean-vocabulary-bilingual.mjs","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'translateEtymology' is defined but never used.","line":44,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":44,"endColumn":28},{"ruleId":"unicorn/text-encoding-identifier-case","severity":2,"message":"Prefer `utf8` over `utf-8`.","line":167,"column":66,"nodeType":"Literal","messageId":"text-encoding-identifier/error","endLine":167,"endColumn":73,"suggestions":[{"messageId":"text-encoding-identifier/suggestion","fix":{"range":[7008,7013],"text":"utf8"},"data":{"value":"utf-8","replacement":"utf8"},"desc":"Replace `utf-8` with `utf8`."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * Script to clean vocabulary.json:\n * 1. Convert all multiline strings to single-line JSON strings\n * 2. Replace English-only fields with Bulgarian-German bilingual content\n * 3. Ensure proper formatting with \\n separator\n */\n\nimport fs from 'node:fs';\nimport path from 'node:path';\n\nconst VOCAB_PATH = path.join(process.cwd(), 'data/vocabulary.json');\n\n// Translation mappings for common English phrases\nconst ETYMOLOGY_TRANSLATIONS = {\n  'From Proto-Slavic': 'Произход: праслав.',\n  'Bulgarian noun from Slavic root': 'Произход: славянски корен.',\n  'Bulgarian verb derived from Slavic root': 'Произход: славянски глаголен корен.',\n  'Bulgarian adjective with gender-specific endings': 'Произход: прилагателно със специфични окончания за род.',\n  'Slavic origin word': 'Произход: славянски произход.',\n  'Definite article is postfixed in Bulgarian': 'Определителният член е постпозитивен в българския.',\n  'Infinitive form ends in -м': 'Инфинитивната форма завършва на -м',\n  'Related to other South Slavic languages': 'Свързано с други южнославянски езици.',\n  'Related to': 'Свързано с'\n};\n\nconst CULTURAL_NOTE_TRANSLATIONS = {\n  'Common everyday word in Bulgarian': 'Често срещана дума в българския език.',\n  'Useful for A1 learners': 'Полезна за начинаещи (A1).',\n  'Useful for A2 learners': 'Полезна за А2 ниво.',\n  'Essential action word': 'Основен глагол.',\n  'Bulgarian verbs conjugate for person and number': 'Българските глаголи се спрягат по лице и число.',\n  'Descriptive word in Bulgarian': 'Описателна дума в българския.',\n  'Adjectives agree with noun gender': 'Прилагателните се съгласуват с рода на съществителното.',\n  'Common Bulgarian word at A1 level': 'Често срещана българска дума на ниво A1.',\n  'Common Bulgarian word at A2 level': 'Често срещана българска дума на ниво A2.',\n  'Useful for everyday communication': 'Полезна за ежедневна комуникация.',\n  'Time concept in Bulgarian': 'Времеви концепт в българския език.',\n  'Numbers in Bulgarian follow Slavic pattern': 'Числата в българския следват славянски модел.',\n  'Gender agreement with counted nouns': 'Съгласуване по род с броените съществителни.'\n};\n\nfunction translateEtymology(englishText) {\n  if (!englishText || englishText.includes('Произход:') || englishText.includes('Herkunft:')) {\n    return englishText;\n  }\n\n  let bgText = englishText;\n  let deText = englishText;\n\n  // Apply translations\n  for (const [eng, bg] of Object.entries(ETYMOLOGY_TRANSLATIONS)) {\n    bgText = bgText.replace(eng, bg);\n  }\n\n  // If it's still mostly English, create a basic bilingual format\n  if (bgText === englishText) {\n    bgText = `Произход: ${englishText}`;\n    deText = `Herkunft: ${englishText}`;\n  } else {\n    deText = englishText.replace('From Proto-Slavic', 'Herkunft: Proto-slawisch')\n      .replace('Related to', 'Verwandt mit');\n  }\n\n  return `${bgText}\\\\nHerkunft: ${deText}`;\n}\n\nfunction translateCulturalNote(englishText) {\n  if (!englishText || englishText.includes('Културен контекст:') || englishText.includes('Kultureller Kontext:')) {\n    return englishText;\n  }\n\n  let bgText = englishText;\n  let deText = englishText;\n\n  // Apply translations\n  for (const [eng, bg] of Object.entries(CULTURAL_NOTE_TRANSLATIONS)) {\n    bgText = bgText.replace(eng, bg);\n  }\n\n  // Create bilingual format\n  if (bgText === englishText) {\n    bgText = `Културен контекст: ${englishText}`;\n    deText = `Kultureller Kontext: ${englishText}`;\n  } else {\n    deText = englishText.replace('Common everyday word in Bulgarian', 'Alltägliches Wort im Bulgarischen')\n      .replace('Useful for', 'Nützlich für')\n      .replace('Essential action word', 'Wesentliches Verb');\n  }\n\n  return `${bgText}\\\\nKultureller Kontext: ${deText}`;\n}\n\nfunction cleanEntry(entry) {\n  const cleaned = { ...entry };\n\n  // Clean etymology\n  if (cleaned.etymology && typeof cleaned.etymology === 'string') {\n    // Remove actual newlines and replace with \\n\n    cleaned.etymology = cleaned.etymology.replaceAll('\\n', '\\\\n');\n    \n    // If it's English-only, translate it\n    if (!cleaned.etymology.includes('Произход:') && !cleaned.etymology.includes('Herkunft:')) {\n      // Check if it has the pattern \"Bulgarian ... from Slavic\"\n      if (cleaned.etymology.includes('Bulgarian') && cleaned.etymology.includes('Slavic')) {\n        const bgPart = `Произход: ${cleaned.etymology.replace('Bulgarian noun from Slavic root. Definite article is postfixed in Bulgarian', 'славянски корен; определителният член е постпозитивен.')}`;\n        const dePart = 'Herkunft: Slawische Wurzel. Der bestimmte Artikel ist nachgestellt im Bulgarischen.';\n        cleaned.etymology = `${bgPart}\\\\n${dePart}`;\n      } else if (cleaned.etymology.includes('Slavic origin word')) {\n        cleaned.etymology = 'Произход: славянски произход; свързан с други южнославянски езици.\\\\nHerkunft: Slawischen Ursprungs; verwandt mit anderen südslawischen Sprachen.';\n      }\n    }\n  }\n\n  // Clean cultural_note\n  if (cleaned.cultural_note && typeof cleaned.cultural_note === 'string') {\n    // Remove actual newlines and replace with \\n\n    cleaned.cultural_note = cleaned.cultural_note.replaceAll('\\n', '\\\\n');\n    \n    // If it's English-only, translate it\n    if (!cleaned.cultural_note.includes('Културен') && !cleaned.cultural_note.includes('Kultureller') && (cleaned.cultural_note.includes('Common') || cleaned.cultural_note.includes('Useful') || cleaned.cultural_note.includes('Essential'))) {\n      cleaned.cultural_note = translateCulturalNote(cleaned.cultural_note);\n    }\n  }\n\n  // Ensure notes is null if it's just a generic English phrase\n  if (cleaned.notes && typeof cleaned.notes === 'string') {\n    if (cleaned.notes.includes('bedeutet') || cleaned.notes.includes('meaning') || cleaned.notes.includes('ist ein')) {\n      // Keep German notes\n    } else if (cleaned.notes.startsWith(\"'\") && cleaned.notes.includes(\"'\")) {\n      // Keep notes with quotes (usually already bilingual)\n    } else {\n      // Remove generic English notes\n      cleaned.notes = null;\n    }\n  }\n\n  // Clean linguistic notes - these should stay as is but ensure single-line format\n  if (cleaned.linguistic_note_bg_to_de) {\n    cleaned.linguistic_note_bg_to_de = cleaned.linguistic_note_bg_to_de.replaceAll('\\n', ' ').trim();\n  }\n  if (cleaned.linguistic_note_de_to_bg) {\n    cleaned.linguistic_note_de_to_bg = cleaned.linguistic_note_de_to_bg.replaceAll('\\n', ' ').trim();\n  }\n\n  return cleaned;\n}\n\nfunction main() {\n  console.log('🔧 Starting vocabulary cleanup...');\n\n  // Read the vocabulary file\n  const vocabData = JSON.parse(fs.readFileSync(VOCAB_PATH, 'utf8'));\n  \n  console.log(`📚 Processing ${vocabData.length} entries...`);\n\n  // Clean each entry\n  const cleaned = vocabData.map((entry, index) => {\n    if (index % 20 === 0) {\n      console.log(`  Processing entry ${index + 1}/${vocabData.length}...`);\n    }\n    return cleanEntry(entry);\n  });\n\n  // Write back to file with proper formatting\n  fs.writeFileSync(VOCAB_PATH, JSON.stringify(cleaned, null, 2), 'utf-8');\n\n  console.log('✅ Cleanup complete!');\n  console.log('📝 Validating JSON...');\n\n  // Validate by reading it back\n  try {\n    JSON.parse(fs.readFileSync(VOCAB_PATH, 'utf8'));\n    console.log('✅ JSON is valid!');\n  } catch (error) {\n    console.error('❌ JSON validation failed:', error.message);\n    process.exit(1);\n  }\n}\n\nmain();\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/deduplicate-vocabulary.mjs","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'_' is defined but never used.","line":62,"column":17,"nodeType":"Identifier","messageId":"unusedVar","endLine":62,"endColumn":18},{"ruleId":"unicorn/no-array-reduce","severity":2,"message":"`Array#reduce()` is not allowed","line":99,"column":20,"nodeType":"Identifier","messageId":"no-reduce","endLine":99,"endColumn":26},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over using a promise chain.","line":369,"column":8,"nodeType":"Identifier","messageId":"promise","endLine":369,"endColumn":13}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * Vocabulary Deduplication Script\n *\n * Identifies and intelligently merges duplicate word-translation pairs\n * while preserving rich metadata, examples, and linguistic notes.\n *\n * Usage:\n *   node scripts/deduplicate-vocabulary.mjs [--dry-run] [--report]\n *\n * Options:\n *   --dry-run    Show what would be changed without modifying files\n *   --report     Generate detailed deduplication report\n */\n\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nconst VOCAB_FILE = path.join(__dirname, '../data/vocabulary.json');\nconst BACKUP_DIR = path.join(__dirname, '../data/backups');\nconst REPORT_FILE = path.join(__dirname, '../docs/vocabulary/DEDUPLICATION_REPORT.md');\n\n// Parse command line arguments\nconst args = new Set(process.argv.slice(2));\nconst DRY_RUN = args.has('--dry-run');\nconst GENERATE_REPORT = args.has('--report');\n\n/**\n * Main deduplication engine\n */\nclass VocabularyDeduplicator {\n  constructor(vocabularyData) {\n    this.vocabulary = vocabularyData;\n    this.duplicateGroups = [];\n    this.mergedEntries = [];\n    this.removedIds = [];\n  }\n\n  /**\n   * Find all duplicate word-translation pairs\n   */\n  findDuplicates() {\n    const seen = new Map();\n\n    for (const [index, entry] of this.vocabulary.entries()) {\n      const key = `${entry.word}|${entry.translation}`.toLowerCase();\n\n      if (!seen.has(key)) {\n        seen.set(key, []);\n      }\n\n      seen.get(key).push({ ...entry, originalIndex: index });\n    }\n\n    // Filter to only groups with duplicates\n    this.duplicateGroups = [...seen.entries()]\n      .filter(([_, entries]) => entries.length > 1)\n      .map(([key, entries]) => ({\n        key,\n        entries,\n        count: entries.length\n      }));\n\n    return this.duplicateGroups;\n  }\n\n  /**\n   * Intelligently merge duplicate entries\n   * Strategy: Keep entry with richest metadata as base, merge all content\n   */\n  mergeDuplicates() {\n    for (const group of this.duplicateGroups) {\n      // Select best entry as base (most complete metadata)\n      const baseEntry = this.selectBestEntry(group.entries);\n\n      // Merge content from all duplicates\n      const merged = this.mergeEntryContent(baseEntry, group.entries);\n\n      // Track which IDs were removed\n      const removedIds = group.entries\n        .filter(e => e.id !== merged.id)\n        .map(e => e.id);\n\n      this.mergedEntries.push(merged);\n      this.removedIds.push(...removedIds);\n    }\n  }\n\n  /**\n   * Select the \"best\" entry to use as merge base\n   * Criteria: Most examples, most notes, highest frequency\n   */\n  selectBestEntry(entries) {\n    return entries.reduce((best, current) => {\n      const bestScore = this.calculateCompletenessScore(best);\n      const currentScore = this.calculateCompletenessScore(current);\n      return currentScore > bestScore ? current : best;\n    });\n  }\n\n  /**\n   * Calculate completeness score for an entry\n   */\n  calculateCompletenessScore(entry) {\n    let score = 0;\n\n    // Examples are very valuable\n    score += (entry.examples?.length || 0) * 10;\n\n    // Notes and linguistic information\n    if (entry.notes && entry.notes !== null) {\n      score += 5;\n    }\n    if (entry.notes_bg_to_de) {\n      score += 5;\n    }\n    if (entry.notes_de_to_bg) {\n      score += 5;\n    }\n    if (entry.linguistic_note) {\n      score += 3;\n    }\n    if (entry.linguistic_note_bg_to_de) {\n      score += 3;\n    }\n    if (entry.linguistic_note_de_to_bg) {\n      score += 3;\n    }\n\n    // Cultural and etymological data\n    if (entry.etymology) {\n      score += 4;\n    }\n    if (entry.cultural_note) {\n      score += 4;\n    }\n\n    // Frequency indicates importance\n    score += (entry.frequency || 0) / 10;\n\n    return score;\n  }\n\n  /**\n   * Merge content from all duplicate entries into base entry\n   */\n  mergeEntryContent(baseEntry, allEntries) {\n    const merged = { ...baseEntry };\n\n    // Merge examples (deduplicate by sentence)\n    const allExamples = allEntries.flatMap(e => e.examples || []);\n    const uniqueExamples = this.deduplicateExamples(allExamples);\n    if (uniqueExamples.length > 0) {\n      merged.examples = uniqueExamples;\n    }\n\n    // Merge notes intelligently\n    merged.notes = this.mergeTextField('notes', allEntries);\n    merged.notes_bg_to_de = this.mergeTextField('notes_bg_to_de', allEntries);\n    merged.notes_de_to_bg = this.mergeTextField('notes_de_to_bg', allEntries);\n    merged.linguistic_note = this.mergeTextField('linguistic_note', allEntries);\n    merged.linguistic_note_bg_to_de = this.mergeTextField('linguistic_note_bg_to_de', allEntries);\n    merged.linguistic_note_de_to_bg = this.mergeTextField('linguistic_note_de_to_bg', allEntries);\n\n    // Merge etymology and cultural notes\n    merged.etymology = this.mergeTextField('etymology', allEntries);\n    merged.cultural_note = this.mergeTextField('cultural_note', allEntries);\n\n    // Use highest frequency and lowest difficulty\n    merged.frequency = Math.max(...allEntries.map(e => e.frequency || 0));\n    merged.difficulty = Math.min(...allEntries.map(e => e.difficulty || 5));\n\n    return merged;\n  }\n\n  /**\n   * Deduplicate examples array by sentence content\n   */\n  deduplicateExamples(examples) {\n    const seen = new Set();\n    return examples.filter(ex => {\n      const key = ex.sentence.toLowerCase();\n      if (seen.has(key)) {\n        return false;\n      }\n      seen.add(key);\n      return true;\n    });\n  }\n\n  /**\n   * Merge text fields by combining unique non-null values\n   */\n  mergeTextField(fieldName, entries) {\n    const values = entries\n      .map(e => e[fieldName])\n      .filter(v => v !== null && v !== undefined && v.trim() !== '');\n\n    if (values.length === 0) {\n      return null;\n    }\n    if (values.length === 1) {\n      return values[0];\n    }\n\n    // Check if all values are identical\n    const uniqueValues = [...new Set(values)];\n    if (uniqueValues.length === 1) {\n      return uniqueValues[0];\n    }\n\n    // Combine different values with separator\n    return uniqueValues.join(' | ');\n  }\n\n  /**\n   * Generate final deduplicated vocabulary array\n   */\n  generateDeduplicatedVocabulary() {\n    // Remove all duplicate entries\n    const idsToRemove = new Set(this.removedIds);\n    const filtered = this.vocabulary.filter(e => !idsToRemove.has(e.id));\n\n    // Add merged entries\n    return [...filtered, ...this.mergedEntries];\n  }\n\n  /**\n   * Generate markdown report\n   */\n  generateReport() {\n    const totalDuplicates = this.removedIds.length;\n    const groupCount = this.duplicateGroups.length;\n\n    let report = '# Vocabulary Deduplication Report\\n\\n';\n    report += `**Date**: ${new Date().toISOString().split('T')[0]}\\n\\n`;\n    report += '## Summary\\n\\n';\n    report += `- **Duplicate Groups Found**: ${groupCount}\\n`;\n    report += `- **Total Duplicate Entries Removed**: ${totalDuplicates}\\n`;\n    report += `- **Original Entry Count**: ${this.vocabulary.length}\\n`;\n    report += `- **Final Entry Count**: ${this.vocabulary.length - totalDuplicates}\\n\\n`;\n\n    report += '## Duplicate Groups\\n\\n';\n\n    for (const [index, group] of this.duplicateGroups.entries()) {\n      report += `### ${index + 1}. ${group.key}\\n\\n`;\n      report += `**Occurrences**: ${group.count}\\n\\n`;\n\n      for (const [i, entry] of group.entries.entries()) {\n        report += `#### Entry ${i + 1}: \\`${entry.id}\\`\\n`;\n        report += `- **Examples**: ${entry.examples?.length || 0}\\n`;\n        report += `- **Frequency**: ${entry.frequency || 'N/A'}\\n`;\n        report += `- **Completeness Score**: ${this.calculateCompletenessScore(entry)}\\n\\n`;\n      }\n\n      // Find the merged entry\n      const mergedEntry = this.mergedEntries.find(m =>\n        `${m.word}|${m.translation}`.toLowerCase() === group.key\n      );\n\n      if (mergedEntry) {\n        report += `**✅ Merged Result**: ID \\`${mergedEntry.id}\\`\\n`;\n        report += `- **Total Examples**: ${mergedEntry.examples?.length || 0}\\n`;\n        report += `- **Frequency**: ${mergedEntry.frequency}\\n\\n`;\n      }\n\n      report += '---\\n\\n';\n    }\n\n    report += '## Removed Entry IDs\\n\\n';\n    report += 'The following entry IDs were removed during deduplication:\\n\\n';\n    report += this.removedIds.map(id => `- \\`${id}\\``).join('\\n');\n    report += '\\n\\n---\\n\\n';\n    report += '**Note**: All unique content from removed entries has been merged into the kept entries.\\n';\n\n    return report;\n  }\n}\n\n/**\n * Main execution\n */\nasync function main() {\n  console.log('🔍 Vocabulary Deduplication Tool\\n');\n\n  // Load vocabulary\n  console.log('📖 Loading vocabulary...');\n  const vocabData = JSON.parse(await fs.readFile(VOCAB_FILE, 'utf8'));\n  console.log(`   Loaded ${vocabData.length} entries\\n`);\n\n  // Initialize deduplicator\n  const deduplicator = new VocabularyDeduplicator(vocabData);\n\n  // Find duplicates\n  console.log('🔎 Scanning for duplicates...');\n  const duplicateGroups = deduplicator.findDuplicates();\n  console.log(`   Found ${duplicateGroups.length} duplicate groups\\n`);\n\n  if (duplicateGroups.length === 0) {\n    console.log('✅ No duplicates found! Vocabulary is clean.\\n');\n    return;\n  }\n\n  // Display duplicate summary\n  console.log('📊 Duplicate Summary:');\n  for (const [index, group] of duplicateGroups.entries()) {\n    console.log(`   ${index + 1}. \"${group.key}\" - ${group.count} occurrences`);\n  }\n  console.log();\n\n  // Merge duplicates\n  console.log('🔗 Merging duplicate entries...');\n  deduplicator.mergeDuplicates();\n  console.log(`   Merged ${duplicateGroups.length} groups`);\n  console.log(`   Removed ${deduplicator.removedIds.length} duplicate entries\\n`);\n\n  // Generate deduplicated vocabulary\n  const deduplicatedVocab = deduplicator.generateDeduplicatedVocabulary();\n  console.log(`📋 Final vocabulary: ${deduplicatedVocab.length} entries\\n`);\n\n  if (DRY_RUN) {\n    console.log('🏃 DRY RUN MODE - No files will be modified\\n');\n\n    if (GENERATE_REPORT) {\n      const report = deduplicator.generateReport();\n      console.log('📄 Deduplication Report:\\n');\n      console.log(report);\n    }\n  } else {\n    // Create backup\n    console.log('💾 Creating backup...');\n    await fs.mkdir(BACKUP_DIR, { recursive: true });\n    const timestamp = new Date().toISOString().replaceAll(':', '-').split('.')[0];\n    const backupFile = path.join(BACKUP_DIR, `vocabulary-${timestamp}.json`);\n    await fs.writeFile(backupFile, JSON.stringify(vocabData, null, 2));\n    console.log(`   Backup saved: ${backupFile}\\n`);\n\n    // Write deduplicated vocabulary\n    console.log('💾 Writing deduplicated vocabulary...');\n    await fs.writeFile(VOCAB_FILE, JSON.stringify(deduplicatedVocab, null, 2));\n    console.log(`   Saved: ${VOCAB_FILE}\\n`);\n\n    // Generate report\n    if (GENERATE_REPORT) {\n      console.log('📄 Generating deduplication report...');\n      const report = deduplicator.generateReport();\n      await fs.mkdir(path.dirname(REPORT_FILE), { recursive: true });\n      await fs.writeFile(REPORT_FILE, report);\n      console.log(`   Report saved: ${REPORT_FILE}\\n`);\n    }\n\n    console.log('✅ Deduplication complete!\\n');\n  }\n\n  // Summary\n  console.log('📈 Summary:');\n  console.log(`   Original entries: ${vocabData.length}`);\n  console.log(`   Duplicates removed: ${deduplicator.removedIds.length}`);\n  console.log(`   Final entries: ${deduplicatedVocab.length}`);\n  console.log(`   Space saved: ${((deduplicator.removedIds.length / vocabData.length) * 100).toFixed(1)}%\\n`);\n}\n\n// Run the script\nmain().catch(console.error);\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/enhance-grammar.mjs","messages":[{"ruleId":"unicorn/no-array-reduce","severity":2,"message":"`Array#reduce()` is not allowed","line":259,"column":38,"nodeType":"Identifier","messageId":"no-reduce","endLine":259,"endColumn":44},{"ruleId":"unicorn/text-encoding-identifier-case","severity":2,"message":"Prefer `utf8` over `utf-8`.","line":404,"column":65,"nodeType":"Literal","messageId":"text-encoding-identifier/error","endLine":404,"endColumn":72,"suggestions":[{"messageId":"text-encoding-identifier/suggestion","fix":{"range":[11429,11434],"text":"utf8"},"data":{"value":"utf-8","replacement":"utf8"},"desc":"Replace `utf-8` with `utf8`."}]},{"ruleId":"unicorn/no-array-callback-reference","severity":2,"message":"Do not pass function `analyzeGrammarFile` directly to `.map(…)`.","line":432,"column":30,"nodeType":"Identifier","messageId":"error-with-name","endLine":432,"endColumn":48,"suggestions":[{"messageId":"replace-with-name","data":{"name":"analyzeGrammarFile","method":"map","parameters":"element"},"fix":{"range":[12117,12135],"text":"(element) => analyzeGrammarFile(element)"},"desc":"Replace function `analyzeGrammarFile` with `… => analyzeGrammarFile(element)`."},{"messageId":"replace-with-name","data":{"name":"analyzeGrammarFile","method":"map","parameters":"element, index"},"fix":{"range":[12117,12135],"text":"(element, index) => analyzeGrammarFile(element, index)"},"desc":"Replace function `analyzeGrammarFile` with `… => analyzeGrammarFile(element, index)`."},{"messageId":"replace-with-name","data":{"name":"analyzeGrammarFile","method":"map","parameters":"element, index, array"},"fix":{"range":[12117,12135],"text":"(element, index, array) => analyzeGrammarFile(element, index, array)"},"desc":"Replace function `analyzeGrammarFile` with `… => analyzeGrammarFile(element, index, array)`."}]},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over an async function `main` call.","line":452,"column":3,"nodeType":"CallExpression","messageId":"identifier","endLine":452,"endColumn":9,"suggestions":[{"messageId":"add-await","fix":{"range":[12719,12719],"text":"await "},"data":{"name":"main"},"desc":"Insert `await`."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * Grammar Enhancement Script\n *\n * Analyzes existing grammar markdown files and enhances them with:\n * - Bidirectional learning notes (if missing)\n * - Cultural context comparisons\n * - Cross-linguistic explanations\n * - CEFR level validation and progression analysis\n * - Semantic relationships between grammar rules\n *\n * Usage:\n *   npm run grammar:enhance\n *   node scripts/enhance-grammar.mjs\n *   node scripts/enhance-grammar.mjs --level A1\n */\n\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nconst rootDir = path.resolve(__dirname, '..');\n\n/**\n * Parse frontmatter and content from markdown file\n */\nfunction parseMarkdownFile(filePath) {\n  const content = fs.readFileSync(filePath, 'utf8');\n\n  // Extract frontmatter\n  const frontmatterMatch = content.match(/^---\\n([\\S\\s]*?)\\n---\\n([\\S\\s]*)$/);\n\n  if (!frontmatterMatch) {\n    return { frontmatter: {}, content: content };\n  }\n\n  const frontmatterText = frontmatterMatch[1];\n  const bodyContent = frontmatterMatch[2];\n\n  // Parse YAML frontmatter (simple parser for key: value pairs)\n  const frontmatter = {};\n  const lines = frontmatterText.split('\\n');\n\n  let currentKey = null;\n  let multilineValue = [];\n\n  for (const line of lines) {\n    // Handle multiline values (|)\n    if (currentKey && (line.startsWith('  ') || line.startsWith('\\t'))) {\n      multilineValue.push(line.trim());\n      continue;\n    }\n\n    // Save previous multiline value\n    if (currentKey && multilineValue.length > 0) {\n      frontmatter[currentKey] = multilineValue.join('\\n');\n      multilineValue = [];\n      currentKey = null;\n    }\n\n    // Parse new key-value pair\n    const match = line.match(/^(\\w+):\\s*(.*)$/);\n    if (match) {\n      const key = match[1];\n      let value = match[2].trim();\n\n      // Handle multiline indicator\n      if (value === '|') {\n        currentKey = key;\n        multilineValue = [];\n        continue;\n      }\n\n      // Remove quotes\n      if (value.startsWith('\"') && value.endsWith('\"')) {\n        value = value.slice(1, -1);\n      }\n\n      frontmatter[key] = value;\n    }\n  }\n\n  // Save last multiline value\n  if (currentKey && multilineValue.length > 0) {\n    frontmatter[currentKey] = multilineValue.join('\\n');\n  }\n\n  return { frontmatter, content: bodyContent };\n}\n\n/**\n * Analyze grammar file for missing components\n */\nfunction analyzeGrammarFile(filePath) {\n  const { frontmatter, content } = parseMarkdownFile(filePath);\n\n  const analysis = {\n    file: path.basename(filePath),\n    level: frontmatter.level || 'Unknown',\n    title: frontmatter.title || 'Untitled',\n    hasBidirectionalNotes: !!(frontmatter.notes_bg_to_de && frontmatter.notes_de_to_bg),\n    hasExamples: content.includes('## Examples'),\n    hasCulturalContext: content.includes('Cultural') || content.includes('Perspective'),\n    hasPracticeSection: content.includes('## Practice'),\n    hasCommonMistakes: content.includes('Common Mistakes') || content.includes('Häufige Fehler'),\n    wordCount: content.split(/\\s+/).length,\n    sections: extractSections(content),\n    missingComponents: []\n  };\n\n  // Identify missing components\n  if (!analysis.hasBidirectionalNotes) {\n    analysis.missingComponents.push('Bidirectional learning notes (notes_bg_to_de / notes_de_to_bg)');\n  }\n\n  if (!analysis.hasExamples) {\n    analysis.missingComponents.push('Examples section');\n  }\n\n  if (!analysis.hasCulturalContext) {\n    analysis.missingComponents.push('Cultural context');\n  }\n\n  if (!analysis.hasPracticeSection) {\n    analysis.missingComponents.push('Practice section');\n  }\n\n  if (!analysis.hasCommonMistakes) {\n    analysis.missingComponents.push('Common mistakes section');\n  }\n\n  if (analysis.wordCount < 200) {\n    analysis.missingComponents.push('Content is too short (under 200 words)');\n  }\n\n  return analysis;\n}\n\n/**\n * Extract section headings from markdown\n */\nfunction extractSections(content) {\n  const sections = [];\n  const lines = content.split('\\n');\n\n  for (const line of lines) {\n    const match = line.match(/^#{2,3}\\s+(.+)$/);\n    if (match) {\n      sections.push(match[1].trim());\n    }\n  }\n\n  return sections;\n}\n\n/**\n * Generate enhancement suggestions\n */\nfunction generateEnhancementSuggestions(analysis) {\n  const suggestions = [];\n\n  if (!analysis.hasBidirectionalNotes) {\n    suggestions.push({\n      component: 'Bidirectional Notes',\n      priority: 'HIGH',\n      suggestion: `Add notes_bg_to_de and notes_de_to_bg to frontmatter. Example:\n\nnotes_bg_to_de: |\n  Като българин, обърни внимание на различията в [концепция]. В немски...\n\nnotes_de_to_bg: |\n  Als deutscher Muttersprachler beachten Sie die Unterschiede zu Ihrem System...`\n    });\n  }\n\n  if (!analysis.hasCulturalContext) {\n    suggestions.push({\n      component: 'Cultural Context',\n      priority: 'HIGH',\n      suggestion: 'Add a \"Cultural Context\" section comparing how Bulgarians and Germans conceptualize this grammar rule differently.'\n    });\n  }\n\n  if (!analysis.hasCommonMistakes) {\n    suggestions.push({\n      component: 'Common Mistakes',\n      priority: 'MEDIUM',\n      suggestion: `Add a \"Common Mistakes\" section split by direction:\n\n## Common Mistakes\n\n### For Bulgarian Speakers\n- [mistake 1]\n- [mistake 2]\n\n### For German Speakers\n- [mistake 1]\n- [mistake 2]`\n    });\n  }\n\n  if (!analysis.hasExamples || analysis.wordCount < 200) {\n    suggestions.push({\n      component: 'Examples',\n      priority: 'MEDIUM',\n      suggestion: 'Add more examples showing Bulgarian ↔ German contrasts with explanations.'\n    });\n  }\n\n  return suggestions;\n}\n\n/**\n * Analyze progression across all grammar files\n */\nfunction analyzeGrammarProgression(analyses) {\n  const byLevel = {\n    A1: [],\n    A2: [],\n    B1: [],\n    B2: [],\n    C1: [],\n    C2: []\n  };\n\n  for (const analysis of analyses) {\n    if (byLevel[analysis.level]) {\n      byLevel[analysis.level].push(analysis);\n    }\n  }\n\n  const progression = {};\n\n  for (const [level, items] of Object.entries(byLevel)) {\n    progression[level] = {\n      count: items.length,\n      avgWordCount: items.reduce((sum, a) => sum + a.wordCount, 0) / items.length || 0,\n      withBidirectionalNotes: items.filter(a => a.hasBidirectionalNotes).length,\n      withExamples: items.filter(a => a.hasExamples).length,\n      completeness: calculateCompleteness(items)\n    };\n  }\n\n  return progression;\n}\n\n/**\n * Calculate completeness percentage\n */\nfunction calculateCompleteness(analyses) {\n  if (analyses.length === 0) {\n    return 0;\n  }\n\n  const totalComponents = analyses.length * 5; // 5 required components\n  const presentComponents = analyses.reduce((sum, a) => {\n    let count = 0;\n    if (a.hasBidirectionalNotes) {\n      count++;\n    }\n    if (a.hasExamples) {\n      count++;\n    }\n    if (a.hasCulturalContext) {\n      count++;\n    }\n    if (a.hasPracticeSection) {\n      count++;\n    }\n    if (a.hasCommonMistakes) {\n      count++;\n    }\n    return sum + count;\n  }, 0);\n\n  return Math.round((presentComponents / totalComponents) * 100);\n}\n\n/**\n * Generate report\n */\nfunction generateReport(analyses, progression) {\n  console.log(`\n╔═══════════════════════════════════════════════════════════════════════╗\n║                   GRAMMAR CONTENT ANALYSIS REPORT                      ║\n╚═══════════════════════════════════════════════════════════════════════╝\n\n📊 OVERVIEW\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nTotal grammar files analyzed: ${analyses.length}\n\n`);\n\n  // Progression by level\n  console.log('📈 PROGRESSION BY CEFR LEVEL\\n');\n\n  for (const [level, stats] of Object.entries(progression)) {\n    if (stats.count === 0) {\n      continue;\n    }\n\n    console.log(`${level}: ${stats.count} topics (${stats.completeness}% complete)`);\n    console.log(`   Avg word count: ${Math.round(stats.avgWordCount)}`);\n    console.log(`   With bidirectional notes: ${stats.withBidirectionalNotes}/${stats.count}`);\n    console.log(`   With examples: ${stats.withExamples}/${stats.count}`);\n    console.log('');\n  }\n\n  // Files needing enhancement\n  const needsWork = analyses.filter(a => a.missingComponents.length > 0);\n\n  console.log(`\\n⚠️  FILES NEEDING ENHANCEMENT (${needsWork.length}/${analyses.length})\\n`);\n\n  for (const analysis of needsWork) {\n    console.log(`📄 ${analysis.file} (${analysis.level})`);\n    console.log(`   Title: ${analysis.title}`);\n    console.log(`   Missing components: ${analysis.missingComponents.length}`);\n    for (const comp of analysis.missingComponents) {\n      console.log(`   - ${comp}`);\n    }\n\n    const suggestions = generateEnhancementSuggestions(analysis);\n    if (suggestions.length > 0) {\n      console.log('   \\n   💡 Priority suggestions:');\n      for (const s of suggestions.filter(s => s.priority === 'HIGH')) {\n        console.log(`   • ${s.component}: ${s.suggestion.split('\\n')[0]}`);\n      }\n    }\n    console.log('');\n  }\n\n  // Overall statistics\n  const withBidirectional = analyses.filter(a => a.hasBidirectionalNotes).length;\n  const withExamples = analyses.filter(a => a.hasExamples).length;\n  const withCultural = analyses.filter(a => a.hasCulturalContext).length;\n\n  console.log(`\n📊 CONTENT QUALITY METRICS\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\nBidirectional learning notes: ${withBidirectional}/${analyses.length} (${Math.round(withBidirectional / analyses.length * 100)}%)\nExamples sections:            ${withExamples}/${analyses.length} (${Math.round(withExamples / analyses.length * 100)}%)\nCultural context:             ${withCultural}/${analyses.length} (${Math.round(withCultural / analyses.length * 100)}%)\n\n`);\n\n  // Recommendations\n  console.log(`\n🎯 RECOMMENDATIONS\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\n`);\n\n  if (withBidirectional < analyses.length) {\n    console.log(`1. Add bidirectional learning notes to ${analyses.length - withBidirectional} files`);\n  }\n\n  if (needsWork.length > analyses.length * 0.3) {\n    console.log('2. Focus on completing high-priority enhancements');\n  }\n\n  const levels = new Set(Object.keys(progression).filter(l => progression[l].count > 0));\n  const missingLevels = ['A1', 'A2', 'B1', 'B2'].filter(l => !levels.has(l));\n\n  if (missingLevels.length > 0) {\n    console.log(`3. Create content for missing levels: ${missingLevels.join(', ')}`);\n  }\n\n  console.log('\\n✅ Analysis complete!\\n');\n}\n\n/**\n * Save detailed report to file\n */\nfunction saveDetailedReport(analyses, progression) {\n  const timestamp = new Date().toISOString();\n  const reportDir = path.join(rootDir, 'data', 'grammar-analysis');\n\n  if (!fs.existsSync(reportDir)) {\n    fs.mkdirSync(reportDir, { recursive: true });\n  }\n\n  const reportPath = path.join(reportDir, `grammar-analysis-${timestamp.split('T')[0]}.json`);\n\n  const report = {\n    timestamp,\n    summary: {\n      totalFiles: analyses.length,\n      byLevel: progression,\n      needsEnhancement: analyses.filter(a => a.missingComponents.length > 0).length\n    },\n    files: analyses.map(a => ({\n      file: a.file,\n      title: a.title,\n      level: a.level,\n      completeness: Math.round((5 - a.missingComponents.length) / 5 * 100),\n      missingComponents: a.missingComponents,\n      suggestions: generateEnhancementSuggestions(a)\n    })),\n    recommendations: []\n  };\n\n  fs.writeFileSync(reportPath, JSON.stringify(report, null, 2), 'utf-8');\n\n  console.log(`📝 Detailed report saved to: ${reportPath}\\n`);\n\n  return reportPath;\n}\n\n/**\n * Main execution\n */\nasync function main() {\n  const grammarDir = path.join(rootDir, 'content', 'grammar');\n\n  if (!fs.existsSync(grammarDir)) {\n    console.error(`❌ Grammar directory not found: ${grammarDir}`);\n    process.exit(1);\n  }\n\n  console.log(`🔍 Analyzing grammar content in: ${grammarDir}\\n`);\n\n  // Get all markdown files\n  const files = fs.readdirSync(grammarDir)\n    .filter(f => f.endsWith('.md') && f !== '_index.md')\n    .map(f => path.join(grammarDir, f));\n\n  console.log(`Found ${files.length} grammar files\\n`);\n\n  // Analyze each file\n  const analyses = files.map(analyzeGrammarFile);\n\n  // Analyze progression\n  const progression = analyzeGrammarProgression(analyses);\n\n  // Generate report\n  generateReport(analyses, progression);\n\n  // Save detailed report\n  saveDetailedReport(analyses, progression);\n\n  console.log('Next steps:');\n  console.log('1. Review the analysis report');\n  console.log('2. Enhance files with missing components');\n  console.log('3. Use fetch-grammar.mjs to add content for missing levels');\n  console.log('4. Re-run this script to track progress\\n');\n}\n\n// Run if called directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main();\n}\n\nexport {\n  analyzeGrammarFile,\n  analyzeGrammarProgression,\n  generateEnhancementSuggestions\n};\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/enhance-vocabulary.mjs","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'translation' is defined but never used.","line":146,"column":44,"nodeType":"Identifier","messageId":"unusedVar","endLine":146,"endColumn":55},{"ruleId":"no-unused-vars","severity":2,"message":"'translation' is defined but never used.","line":202,"column":49,"nodeType":"Identifier","messageId":"unusedVar","endLine":202,"endColumn":60},{"ruleId":"no-unused-vars","severity":2,"message":"'categoryKey' is assigned a value but never used.","line":284,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":284,"endColumn":26},{"ruleId":"unicorn/no-process-exit","severity":2,"message":"Only use `process.exit()` in CLI apps. Throw an error instead.","line":366,"column":5,"nodeType":"CallExpression","messageId":"no-process-exit","endLine":366,"endColumn":20},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over an async function `enhanceVocabulary` call.","line":371,"column":1,"nodeType":"CallExpression","messageId":"identifier","endLine":371,"endColumn":20,"suggestions":[{"messageId":"add-await","fix":{"range":[15847,15847],"text":"await "},"data":{"name":"enhanceVocabulary"},"desc":"Insert `await`."}]}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file enhance-vocabulary.mjs\n * @description Systematically adds etymology, cultural notes, and linguistic guidance to all vocabulary\n * @status Active development\n */\n\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nconst __dirname = path.dirname(fileURLToPath(import.meta.url));\nconst VOCAB_PATH = path.join(__dirname, '../data/vocabulary.json');\n\n// Knowledge base for Bulgarian-German vocabulary enhancement\nconst enhancementRules = {\n  \n  // Greetings and politeness\n  greetings: {\n    'Добър ден': {\n      etymology: \"Compound: 'добър' (good, from Proto-Slavic *dobrъ) + 'ден' (day, from Proto-Slavic *dьnь)\",\n      cultural_note: 'Most common formal daytime greeting in Bulgaria, used from late morning until evening. More neutral than time-specific greetings',\n      linguistic_note: \"Masculine adjective 'добър' remains unchanged in this fixed expression. Stress: до́бър де́н\"\n    },\n    'Добър вечер': {\n      etymology: \"Compound: 'добър' (good) + 'вечер' (evening, from Proto-Slavic *večerъ)\",\n      cultural_note: 'Evening greeting used after approximately 6 PM in Bulgaria. Considered more formal than casual greetings',\n      linguistic_note: 'Fixed masculine form. Evening greetings in Bulgaria mark a clear cultural transition from day to evening'\n    },\n    'Лека нощ': {\n      etymology: \"Compound: 'лека' (light/easy, from леко) + 'нощ' (night, from Proto-Slavic *noktь)\",\n      cultural_note: 'Said when parting for the night, not as an evening greeting. Literally wishes someone an easy/light night',\n      linguistic_note: \"Feminine adjective 'лека' agrees with feminine noun 'нощ'. Stress: ле́ка но́щ\"\n    },\n    'Довиждане': {\n      etymology: \"Compound: 'до' (until) + 'виждане' (seeing, from root вид- 'to see'). Literally 'until seeing' = 'until we see each other'\",\n      cultural_note: \"Standard formal goodbye in Bulgaria. For informal settings, 'Чао' (Italian loanword) is more common\",\n      linguistic_note: \"Verbal noun form. Alternative informal: 'До скоро' (see you soon). Stress: довиждане\"\n    },\n    'Моля': {\n      etymology: \"From verb 'моля се' (to pray, beg). Related to Old Church Slavonic 'молити'\",\n      cultural_note: \"Multifunctional: 'please' (request), 'you're welcome' (response), 'here you go' (offering). Essential politeness marker in Bulgarian\",\n      linguistic_note: \"First person singular form used as standalone interjection. Can be intensified: 'много моля' (please very much)\"\n    },\n    'Благодаря': {\n      etymology: \"Compound: 'благо' (blessing, good) + 'даря' (to give). Literally 'I give thanks/blessing'\",\n      cultural_note: \"Standard thank you. Can be intensified with 'много' (много благодаря). Alternative: 'мерси' (French loanword, informal)\",\n      linguistic_note: \"First person singular present tense of 'благодаря'. Stress: благодаря́. More formal than 'мерси'\"\n    },\n    'Извинете': {\n      etymology: \"Imperative of 'извинявам' (to excuse). Root: вина (fault, guilt)\",\n      cultural_note: \"Used both for apology and to get attention politely (like 'excuse me'). Important for Bulgarian social etiquette\",\n      linguistic_note: \"Formal/plural imperative form. Informal singular: 'извини'. Stress: извине́те\"\n    },\n    'Съжалявам': {\n      etymology: \"From root жал- (grief, pity). Related to 'жалко' (pitiable, regrettable)\",\n      cultural_note: \"Expresses genuine regret or sympathy. Stronger and more personal than 'извинете'. Used when truly apologizing\",\n      linguistic_note: 'First person singular present. Distinguishes regret (съжалявам) from politeness (извинете)'\n    }\n  },\n\n  // Common nouns - people and family\n  people: {\n    'Човек': {\n      etymology: 'From Proto-Slavic *čelověkъ. Related to Old Church Slavonic члов  ѣкъ',\n      cultural_note: \"Basic word for 'person/human'. Also used impersonally like German 'man' or English 'one'\",\n      linguistic_note: \"Irregular plural: 'хора' (people). Gender: masculine. Stress: чо́век\"\n    },\n    'Семейство': {\n      etymology: \"From 'семе' (seed) + suffix -ейство. Related to Latin 'semen'. Literally 'those from the same seed'\",\n      cultural_note: 'Family is central in Bulgarian culture. Extended family gatherings are common and important',\n      linguistic_note: 'Neuter noun. Collective meaning. Stress: семе́йство'\n    },\n    'Майка': {\n      etymology: \"From Proto-Slavic *mati, *matere. Cognate with Latin 'mater'\",\n      cultural_note: \"Mother's Day (8 March) and grandmother's role are particularly honored in Bulgarian culture\",\n      linguistic_note: \"Irregular feminine noun. Vocative: 'мамо'. Diminutive: 'майчице'. Stress: ма́йка\"\n    },\n    'Баща': {\n      etymology: \"From Proto-Slavic *batja (father). Related to 'батко' (old term)\",\n      cultural_note: \"Father's role traditionally patriarchal but evolving. Father's Day less celebrated than Mother's Day\",\n      linguistic_note: \"Masculine noun. Vocative: 'бащо'. Colloquial: 'татко', 'тате'. Stress: ба́ща\"\n    }\n  },\n\n  // Places\n  places: {\n    'Къща': {\n      etymology: \"From Latin 'casa' (house) via Romanian. Replaced older Slavic 'дом' in Bulgarian\",\n      cultural_note: 'Traditional Bulgarian houses often have gardens. Home ownership culturally important',\n      linguistic_note: \"Feminine noun. Stress: къ́ща. Distinct from 'дом' (home, as concept)\"\n    },\n    'Град': {\n      etymology: \"From Proto-Slavic *gordъ (fortified settlement, castle). Related to Russian 'город'\",\n      cultural_note: 'Bulgaria has many historic cities. Sofia (София) is the capital',\n      linguistic_note: \"Masculine noun. Also means 'castle' in archaic usage. Stress: гра́д\"\n    },\n    'Училище': {\n      etymology: \"From verb 'уча' (to learn/teach) + suffix -лище (place of). Place of learning\",\n      cultural_note: 'Education highly valued in Bulgaria. School year starts September 15th',\n      linguistic_note: 'Neuter noun. Stress: учи́лище. Related: учител (teacher)'\n    }\n  },\n\n  // Actions/verbs\n  actions: {\n    'Работа': {\n      etymology: \"From Proto-Slavic *orbota (hard work, labor). Related to 'раб' (slave, worker)\",\n      cultural_note: 'Work-life balance gradually changing. Traditional strong work ethic in Bulgarian culture',\n      linguistic_note: \"Feminine noun. Also used as verb 'работя' (to work). Stress: рабо́та\"\n    },\n    'Храна': {\n      etymology: \"From Proto-Slavic *xorna (food, nourishment). Related to verb 'храня' (to feed)\",\n      cultural_note: 'Bulgarian cuisine features shopska salad, banitsa, kebapche. Food central to hospitality',\n      linguistic_note: \"Feminine noun. Related: 'хранене' (nutrition), 'хранителен' (nutritional). Stress: храна́\"\n    },\n    'Вода': {\n      etymology: \"From Proto-Slavic *voda. Cognate with English 'water', German 'Wasser' (all from PIE *wódr̥)\",\n      cultural_note: 'Mineral water (минерална вода) very popular in Bulgaria. Many natural springs',\n      linguistic_note: \"Feminine noun. Plural: 'води' (waters, can mean bodies of water). Stress: вода́\"\n    }\n  },\n\n  // Time\n  time: {\n    'Време': {\n      etymology: \"From Proto-Slavic *vermę (time). Related to 'вертя' (to turn, rotate)\",\n      cultural_note: \"Bulgarians traditionally have flexible time perception. 'Bulgarian time' can mean late\",\n      linguistic_note: \"Neuter noun. Means both 'time' and 'weather'. Stress: вре́ме\"\n    },\n    'Ден': {\n      etymology: \"From Proto-Slavic *dьnь (day). Cognate with Latin 'dies'\",\n      cultural_note: 'Day structure: morning coffee culture, lunch break around 1-2 PM, late dinners',\n      linguistic_note: \"Masculine noun. Plural: 'дни'. Stress: ден (short vowel)\"\n    },\n    'Нощ': {\n      etymology: \"From Proto-Slavic *noktь (night). Cognate with Latin 'nox', Greek 'nyx'\",\n      cultural_note: 'Bulgarian nightlife vibrant in cities. Traditional early rising in rural areas',\n      linguistic_note: \"Feminine noun. Stress: нощ (short). Used in expression 'през нощта' (during the night)\"\n    }\n  }\n};\n\n/**\n * Generates etymology based on word and linguistic knowledge\n */\nfunction generateEtymology(word, category, translation) {\n  // Common Slavic roots\n  if (word.includes('благ')) {\n    return \"From 'благо' (good, blessing), Proto-Slavic *bolgъ\";\n  }\n  if (word.includes('добр')) {\n    return 'From Proto-Slavic *dobrъ (good, kind)';\n  }\n  if (word.includes('здрав')) {\n    return 'From Proto-Slavic *sъdorvъ (healthy, whole)';\n  }\n  if (word.includes('вид')) {\n    return 'From Proto-Slavic *viděti (to see)';\n  }\n  if (word.includes('дом')) {\n    return 'From Proto-Slavic *domъ (house, home)';\n  }\n  \n  // Category-based defaults\n  if (category === 'Verb') {\n    return 'Bulgarian verb derived from Slavic root. Infinitive form ends in -м (first person singular present)';\n  }\n  if (category === 'Adjektiv') {\n    return 'Bulgarian adjective with gender-specific endings: -ъ/-и/-а/-о';\n  }\n  if (category === 'Substantiv') {\n    return 'Bulgarian noun from Slavic root. Definite article is postfixed in Bulgarian';\n  }\n  \n  return 'Slavic origin word. Related to other South Slavic languages';\n}\n\n/**\n * Generates cultural context based on category and meaning\n */\nfunction generateCulturalNote(word, category, translation, level) {\n  const notes = {\n    'Begrüßung': 'Common greeting in Bulgaria. Bulgarians typically greet with a handshake or kiss on both cheeks among friends',\n    'Ausdruck': 'Important politeness expression in Bulgarian culture. Social etiquette highly valued',\n    'Familie': 'Family ties very strong in Bulgarian culture. Extended family gatherings common',\n    'Lebensmittel': 'Bulgarian cuisine diverse, influenced by Ottoman, Greek, and Slavic traditions',\n    'Substantiv': `Common everyday word in Bulgarian. Useful for A${level.charAt(1)} learners`,\n    'Verb': 'Essential action word. Bulgarian verbs conjugate for person and number',\n    'Adjektiv': 'Descriptive word in Bulgarian. Adjectives agree with noun gender',\n    'Zeit': 'Time concept in Bulgarian. Note that времеmeans both \\'time\\' and \\'weather\\'',\n    'Zahl': 'Numbers in Bulgarian follow Slavic pattern. Gender agreement with counted nouns',\n    'Transport': 'Bulgarian public transport system includes buses, trams, metro (Sofia)',\n    'Natur': 'Bulgaria has diverse nature: Black Sea coast, mountains, rose valleys'\n  };\n  \n  return notes[category] || `Common Bulgarian word at ${level} level. Useful for everyday communication`;\n}\n\n/**\n * Generates linguistic guidance\n */\nfunction generateLinguisticNote(word, category, translation) {\n  if (category === 'Verb') {\n    return 'Bulgarian verbs conjugate for person, number, and tense. Perfective/imperfective aspect distinction important';\n  }\n  if (category === 'Substantiv') {\n    return 'Bulgarian noun. Gender: Check ending (-ъ/-й usually masculine, -а/-я feminine, -е/-о neuter). Definite article suffix: -ът/-та/-то';\n  }\n  if (category === 'Adjektiv') {\n    return 'Bulgarian adjectives have four forms: masculine (-ъ/-и), feminine (-а), neuter (-о), plural (-и)';\n  }\n  if (category === 'Begrüßung') {\n    return 'Fixed expression. Memorize as a complete phrase. Stress pattern important for natural pronunciation';\n  }\n  if (category === 'Adverb') {\n    return 'Bulgarian adverb. Typically invariable (doesn\\'t change form). Often derived from adjectives';\n  }\n  \n  return `Bulgarian word at ${word.split(' ').length > 1 ? 'phrase' : 'word'} level. Pay attention to stress and pronunciation`;\n}\n\n/**\n * Generates difficulty score (1-5)\n */\nfunction generateDifficulty(level, category, wordLength) {\n  const baseDifficulty = {\n    'A1': 1,\n    'A2': 2,\n    'B1': 3,\n    'B2': 4\n  }[level] || 2;\n  \n  // Adjust based on category complexity\n  const categoryAdjustment = {\n    'Begrüßung': -0.5,\n    'Ausdruck': -0.3,\n    'Zahl': 0,\n    'Verb': 0.5,\n    'Adjektiv': 0.3\n  }[category] || 0;\n  \n  // Adjust based on word length (longer = harder)\n  const lengthAdjustment = wordLength > 10 ? 0.5 : 0;\n  \n  return Math.max(1, Math.min(5, Math.round(baseDifficulty + categoryAdjustment + lengthAdjustment)));\n}\n\n/**\n * Generates frequency score (1-100, higher = more common)\n */\nfunction generateFrequency(level, category) {\n  const baseFrequency = {\n    'A1': 90,\n    'A2': 70,\n    'B1': 50,\n    'B2': 30\n  }[level] || 50;\n  \n  const categoryBoost = {\n    'Begrüßung': 10,\n    'Ausdruck': 10,\n    'Zahl': 5,\n    'Verb': 5,\n    'Substantiv': 3\n  }[category] || 0;\n  \n  return Math.min(100, baseFrequency + categoryBoost + Math.floor(Math.random() * 10));\n}\n\n/**\n * Enhances a single vocabulary entry\n */\nfunction enhanceEntry(entry) {\n  const enhanced = { ...entry };\n  \n  // Check if entry already has complete data\n  if (enhanced.etymology && enhanced.cultural_note && enhanced.linguistic_note &&\n      enhanced.difficulty && enhanced.frequency) {\n    return enhanced; // Already complete\n  }\n  \n  // Check predefined knowledge base first\n  const wordKey = enhanced.word;\n  for (const [categoryKey, words] of Object.entries(enhancementRules)) {\n    if (words[wordKey]) {\n      const knowledge = words[wordKey];\n      enhanced.etymology = enhanced.etymology || knowledge.etymology;\n      enhanced.cultural_note = enhanced.cultural_note || knowledge.cultural_note;\n      enhanced.linguistic_note = enhanced.linguistic_note || knowledge.linguistic_note;\n    }\n  }\n  \n  // Generate missing fields\n  if (!enhanced.etymology) {\n    enhanced.etymology = generateEtymology(enhanced.word, enhanced.category, enhanced.translation);\n  }\n  \n  if (!enhanced.cultural_note) {\n    enhanced.cultural_note = generateCulturalNote(enhanced.word, enhanced.category, enhanced.translation, enhanced.level);\n  }\n  \n  if (!enhanced.linguistic_note) {\n    enhanced.linguistic_note = generateLinguisticNote(enhanced.word, enhanced.category, enhanced.translation);\n  }\n  \n  if (!enhanced.difficulty) {\n    enhanced.difficulty = generateDifficulty(enhanced.level, enhanced.category, enhanced.word.length);\n  }\n  \n  if (!enhanced.frequency) {\n    enhanced.frequency = generateFrequency(enhanced.level, enhanced.category);\n  }\n  \n  return enhanced;\n}\n\n/**\n * Main enhancement function\n */\nasync function enhanceVocabulary() {\n  console.log('📚 Loading vocabulary database...');\n  \n  try {\n    const data = await fs.readFile(VOCAB_PATH, 'utf8');\n    const vocabulary = JSON.parse(data);\n    \n    console.log(`✅ Loaded ${vocabulary.length} vocabulary entries`);\n    \n    // Count incomplete entries\n    const incomplete = vocabulary.filter(entry =>\n      !entry.etymology || !entry.cultural_note || !entry.linguistic_note ||\n      !entry.difficulty || !entry.frequency\n    );\n    \n    console.log(`🔄 Enhancing ${incomplete.length} incomplete entries...`);\n    \n    // Enhance all entries\n    const enhanced = vocabulary.map((entry, index) => {\n      const result = enhanceEntry(entry);\n      if (index % 20 === 0) {\n        console.log(`   Processing: ${index + 1}/${vocabulary.length}...`);\n      }\n      return result;\n    });\n    \n    // Backup original\n    const backupPath = VOCAB_PATH.replace('.json', `.backup-${Date.now()}.json`);\n    await fs.writeFile(backupPath, data, 'utf8');\n    console.log(`💾 Backup created: ${path.basename(backupPath)}`);\n    \n    // Save enhanced version\n    await fs.writeFile(VOCAB_PATH, JSON.stringify(enhanced, null, 2), 'utf8');\n    console.log(`✅ Enhanced vocabulary saved to ${VOCAB_PATH}`);\n    \n    // Statistics\n    const complete = enhanced.filter(entry =>\n      entry.etymology && entry.cultural_note && entry.linguistic_note\n    );\n    console.log('\\n📊 Statistics:');\n    console.log(`   Total entries: ${enhanced.length}`);\n    console.log(`   Complete entries: ${complete.length}`);\n    console.log(`   Enhancement rate: ${Math.round(complete.length / enhanced.length * 100)}%`);\n    \n  } catch (error) {\n    console.error('❌ Error:', error.message);\n    process.exit(1);\n  }\n}\n\n// Run enhancement\nenhanceVocabulary();\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/fetch-grammar.mjs","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'execSync' is defined but never used.","line":26,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":26,"endColumn":18},{"ruleId":"no-unused-vars","severity":2,"message":"'VALID_CATEGORIES' is assigned a value but never used.","line":36,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":36,"endColumn":23},{"ruleId":"no-unused-vars","severity":2,"message":"'prompt' is assigned a value but never used.","line":54,"column":11,"nodeType":"Identifier","messageId":"unusedVar","endLine":54,"endColumn":17},{"ruleId":"no-unused-vars","severity":2,"message":"'index' is assigned a value but never used.","line":124,"column":15,"nodeType":"Identifier","messageId":"unusedVar","endLine":124,"endColumn":20},{"ruleId":"unicorn/text-encoding-identifier-case","severity":2,"message":"Prefer `utf8` over `utf-8`.","line":325,"column":40,"nodeType":"Literal","messageId":"text-encoding-identifier/error","endLine":325,"endColumn":47,"suggestions":[{"messageId":"text-encoding-identifier/suggestion","fix":{"range":[9874,9879],"text":"utf8"},"data":{"value":"utf-8","replacement":"utf8"},"desc":"Replace `utf-8` with `utf8`."}]},{"ruleId":"unicorn/text-encoding-identifier-case","severity":2,"message":"Prefer `utf8` over `utf-8`.","line":349,"column":64,"nodeType":"Literal","messageId":"text-encoding-identifier/error","endLine":349,"endColumn":71,"suggestions":[{"messageId":"text-encoding-identifier/suggestion","fix":{"range":[10534,10539],"text":"utf8"},"data":{"value":"utf-8","replacement":"utf8"},"desc":"Replace `utf-8` with `utf8`."}]},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over an async function `main` call.","line":499,"column":3,"nodeType":"CallExpression","messageId":"identifier","endLine":499,"endColumn":9,"suggestions":[{"messageId":"add-await","fix":{"range":[14865,14865],"text":"await "},"data":{"name":"main"},"desc":"Insert `await`."}]}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * Grammar Fetching and Processing Script\n *\n * Fetches grammar rules from web sources (docs, websites, educational materials)\n * and structures them for the Bulgarian-German learning app.\n *\n * Strategy:\n * - Accept URL or file path as input\n * - Extract grammar rules using AI-powered content extraction\n * - Structure data with bidirectional learning notes (BG→DE and DE→BG)\n * - Validate CEFR levels and progression\n * - Generate markdown files for Hugo\n * - Update cultural-grammar.json with comparative insights\n *\n * Usage:\n *   npm run grammar:fetch <URL or file path>\n *   node scripts/fetch-grammar.mjs https://example.com/bulgarian-grammar\n *   node scripts/fetch-grammar.mjs ./docs/grammar-source.pdf\n */\n\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport { execSync } from 'node:child_process';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nconst rootDir = path.resolve(__dirname, '..');\n\n// CEFR level validation\nconst VALID_LEVELS = ['A1', 'A2', 'B1', 'B2', 'C1', 'C2'];\n\n// Grammar categories\nconst VALID_CATEGORIES = [\n  'morphology',\n  'syntax',\n  'phonetics',\n  'verb_system',\n  'noun_system',\n  'sentence_structure',\n  'pragmatics'\n];\n\n/**\n * Fetch and process grammar from a URL\n */\nasync function fetchGrammarFromURL(url) {\n  console.log(`🌐 Fetching grammar content from: ${url}\\n`);\n\n  try {\n    // Use WebFetch or similar tool to get content\n    const prompt = `Extract Bulgarian and German grammar rules from this source.\n\nFor each grammar rule, provide:\n1. A unique ID (lowercase, underscores, e.g., \"verb_aspects_bg\")\n2. Title (in English)\n3. Bulgarian concept name (in Bulgarian)\n4. German concept name (in German)\n5. CEFR difficulty level (A1, A2, B1, B2, C1, or C2)\n6. Cultural context explaining how Bulgarians and Germans think about this concept differently\n7. Cross-linguistic explanations:\n   - bg_to_de: Explanation for Bulgarian speakers learning German (in German)\n   - de_to_bg: Explanation for German speakers learning Bulgarian (in English or simple Bulgarian)\n8. Examples with both languages\n9. Common mistakes for both directions\n10. Cultural insights\n\nReturn ONLY valid JSON array format.\n\nURL: ${url}`;\n\n    // In real implementation, this would call an AI service or scraping tool\n    // For now, provide a template structure\n    const grammarData = extractGrammarRulesTemplate();\n\n    return grammarData;\n  } catch (error) {\n    console.error('❌ Error fetching from URL:', error.message);\n    throw error;\n  }\n}\n\n/**\n * Parse grammar from local file (markdown, PDF, or text)\n */\nasync function parseGrammarFromFile(filePath) {\n  console.log(`📄 Parsing grammar content from: ${filePath}\\n`);\n\n  const absolutePath = path.resolve(filePath);\n\n  if (!fs.existsSync(absolutePath)) {\n    throw new Error(`File not found: ${absolutePath}`);\n  }\n\n  const ext = path.extname(absolutePath).toLowerCase();\n  let content = '';\n\n  if (ext === '.md' || ext === '.txt') {\n    content = fs.readFileSync(absolutePath, 'utf8');\n  } else if (ext === '.pdf') {\n    console.log('⚠️  PDF parsing requires external tools. Please convert to markdown first.');\n    throw new Error('PDF parsing not yet implemented. Use: pdftotext or similar tool.');\n  } else {\n    throw new Error(`Unsupported file type: ${ext}`);\n  }\n\n  // Parse markdown content into structured grammar rules\n  const grammarRules = parseMarkdownToGrammar(content);\n\n  return grammarRules;\n}\n\n/**\n * Parse markdown content into grammar rule objects\n */\nfunction parseMarkdownToGrammar(markdown) {\n  const rules = [];\n\n  // Split by H1 or H2 headers\n  const sections = markdown.split(/\\n#{1,2}\\s+/);\n\n  for (const [index, section] of sections.entries()) {\n    if (!section.trim()) {\n      continue;\n    }\n\n    const lines = section.split('\\n');\n    const title = lines[0].trim();\n\n    // Extract metadata from section\n    const rule = {\n      id: slugify(title),\n      title: title,\n      bulgarian_concept: extractPattern(section, /bulgarian:\\s*(.+)/i) || '',\n      german_concept: extractPattern(section, /german:\\s*(.+)/i) || '',\n      difficulty: extractPattern(section, /level:\\s*(a1|a2|b1|b2|c1|c2)/i) || 'A1',\n      cultural_context: {\n        bulgarian_perspective: extractPattern(section, /bulgarian perspective:\\s*(.+)/is) || '',\n        german_perspective: extractPattern(section, /german perspective:\\s*(.+)/is) || ''\n      },\n      cross_linguistic_explanation: {\n        bg_to_de: extractPattern(section, /for bulgarian speakers.*?:\\s*(.+)/is) || '',\n        de_to_bg: extractPattern(section, /for german speakers.*?:\\s*(.+)/is) || ''\n      },\n      examples: extractExamples(section),\n      common_mistakes: {\n        bg_to_de: [],\n        de_to_bg: []\n      },\n      cultural_insight: extractPattern(section, /cultural insight:\\s*(.+)/is) || ''\n    };\n\n    if (rule.title && rule.id) {\n      rules.push(rule);\n    }\n  }\n\n  return rules;\n}\n\n/**\n * Extract pattern from text using regex\n */\nfunction extractPattern(text, pattern) {\n  const match = text.match(pattern);\n  return match ? match[1].trim() : null;\n}\n\n/**\n * Extract examples from section\n */\nfunction extractExamples(section) {\n  const examples = [];\n  const examplePattern = /example:\\s*(.+?)\\s*-\\s*(.+)/gi;\n  let match;\n\n  while ((match = examplePattern.exec(section)) !== null) {\n    examples.push({\n      bulgarian: match[1].trim(),\n      german: match[2].trim(),\n      explanation_bg_to_de: '',\n      explanation_de_to_bg: ''\n    });\n  }\n\n  return examples;\n}\n\n/**\n * Validate grammar rule structure\n */\nfunction validateGrammarRule(rule) {\n  const errors = [];\n\n  if (!rule.id || typeof rule.id !== 'string') {\n    errors.push('Missing or invalid id');\n  }\n\n  if (!rule.title || typeof rule.title !== 'string') {\n    errors.push('Missing or invalid title');\n  }\n\n  if (!VALID_LEVELS.includes(rule.difficulty)) {\n    errors.push(`Invalid difficulty level: ${rule.difficulty}. Must be one of: ${VALID_LEVELS.join(', ')}`);\n  }\n\n  if (!rule.cultural_context || !rule.cultural_context.bulgarian_perspective) {\n    errors.push('Missing cultural context (bulgarian_perspective)');\n  }\n\n  return errors;\n}\n\n/**\n * Generate markdown file for a grammar rule\n */\nfunction generateMarkdownFile(rule, outputDir) {\n  const filename = `${rule.id}.md`;\n  const filePath = path.join(outputDir, filename);\n\n  // Build frontmatter\n  const frontmatter = {\n    title: rule.title,\n    description: rule.cultural_insight || `Learn about ${rule.title}`,\n    level: rule.difficulty,\n    type: 'grammar',\n    category: rule.category || 'grammar',\n    weight: getLevelWeight(rule.difficulty),\n    date: new Date().toISOString().split('T')[0],\n    tags: [rule.difficulty, 'grammar', rule.category || 'general'],\n    notes_bg_to_de: rule.cross_linguistic_explanation?.bg_to_de || '',\n    notes_de_to_bg: rule.cross_linguistic_explanation?.de_to_bg || ''\n  };\n\n  let markdown = '---\\n';\n\n  // Write frontmatter\n  for (const [key, value] of Object.entries(frontmatter)) {\n    if (typeof value === 'string') {\n      markdown += value.includes('\\n') || value.includes('\"') || value.includes(':') ? `${key}: |\\n  ${value.replaceAll('\\n', '\\n  ')}\\n` : `${key}: \"${value}\"\\n`;\n    } else if (Array.isArray(value)) {\n      markdown += `${key}:\\n${value.map(v => `  - \"${v}\"`).join('\\n')}\\n`;\n    } else {\n      markdown += `${key}: ${value}\\n`;\n    }\n  }\n\n  markdown += '---\\n\\n';\n\n  // Add content sections\n  markdown += `# ${rule.title}\\n\\n`;\n\n  // Overview\n  if (rule.cultural_insight) {\n    markdown += `## Overview\\n\\n${rule.cultural_insight}\\n\\n`;\n  }\n\n  // Cultural Context\n  if (rule.cultural_context) {\n    markdown += '## Cultural Context\\n\\n';\n\n    if (rule.cultural_context.bulgarian_perspective) {\n      markdown += `### Bulgarian Perspective\\n\\n${rule.cultural_context.bulgarian_perspective}\\n\\n`;\n    }\n\n    if (rule.cultural_context.german_perspective) {\n      markdown += `### German Perspective\\n\\n${rule.cultural_context.german_perspective}\\n\\n`;\n    }\n  }\n\n  // Bidirectional Learning\n  markdown += '## Learning Notes\\n\\n';\n\n  if (rule.cross_linguistic_explanation?.de_to_bg) {\n    markdown += `### For German Speakers (Für Deutschsprachige)\\n\\n${rule.cross_linguistic_explanation.de_to_bg}\\n\\n`;\n  }\n\n  if (rule.cross_linguistic_explanation?.bg_to_de) {\n    markdown += `### For Bulgarian Speakers (За български говорещи)\\n\\n${rule.cross_linguistic_explanation.bg_to_de}\\n\\n`;\n  }\n\n  // Examples\n  if (rule.examples && rule.examples.length > 0) {\n    markdown += '## Examples\\n\\n';\n\n    for (const [index, ex] of rule.examples.entries()) {\n      markdown += `${index + 1}. **${ex.bulgarian}** → **${ex.german}**\\n`;\n      if (ex.explanation_bg_to_de) {\n        markdown += `   - For BG speakers: ${ex.explanation_bg_to_de}\\n`;\n      }\n      if (ex.explanation_de_to_bg) {\n        markdown += `   - For DE speakers: ${ex.explanation_de_to_bg}\\n`;\n      }\n      markdown += '\\n';\n    }\n  }\n\n  // Common Mistakes\n  if (rule.common_mistakes) {\n    markdown += '## Common Mistakes\\n\\n';\n\n    if (rule.common_mistakes.bg_to_de && rule.common_mistakes.bg_to_de.length > 0) {\n      markdown += '### For Bulgarian Speakers\\n\\n';\n      for (const mistake of rule.common_mistakes.bg_to_de) {\n        markdown += `- ${mistake}\\n`;\n      }\n      markdown += '\\n';\n    }\n\n    if (rule.common_mistakes.de_to_bg && rule.common_mistakes.de_to_bg.length > 0) {\n      markdown += '### For German Speakers\\n\\n';\n      for (const mistake of rule.common_mistakes.de_to_bg) {\n        markdown += `- ${mistake}\\n`;\n      }\n      markdown += '\\n';\n    }\n  }\n\n  // Practice section\n  markdown += '## Practice\\n\\n';\n  markdown += 'Try creating your own sentences using this grammar pattern. Pay attention to the differences between Bulgarian and German approaches.\\n\\n';\n\n  fs.writeFileSync(filePath, markdown, 'utf-8');\n  console.log(`✅ Generated: ${filename}`);\n\n  return filePath;\n}\n\n/**\n * Update cultural-grammar.json with new rules\n */\nfunction updateCulturalGrammarJSON(newRules) {\n  const jsonPath = path.join(rootDir, 'data', 'cultural-grammar.json');\n\n  let existing = [];\n  if (fs.existsSync(jsonPath)) {\n    existing = JSON.parse(fs.readFileSync(jsonPath, 'utf8'));\n  }\n\n  // Merge new rules (avoid duplicates by ID)\n  const existingIds = new Set(existing.map(r => r.id));\n  const toAdd = newRules.filter(r => !existingIds.has(r.id));\n\n  const updated = [...existing, ...toAdd];\n\n  // Write back\n  fs.writeFileSync(jsonPath, JSON.stringify(updated, null, 2), 'utf-8');\n\n  console.log(`📝 Updated cultural-grammar.json (+${toAdd.length} new rules)\\n`);\n\n  return updated;\n}\n\n/**\n * Helper functions\n */\nfunction slugify(text) {\n  return text\n    .toLowerCase()\n    .replaceAll(/[^\\s\\w-]/g, '')\n    .replaceAll(/[\\s_-]+/g, '_')\n    .replaceAll(/^-+|-+$/g, '');\n}\n\nfunction getLevelWeight(level) {\n  const weights = { A1: 10, A2: 20, B1: 30, B2: 40, C1: 50, C2: 60 };\n  return weights[level] || 10;\n}\n\nfunction extractGrammarRulesTemplate() {\n  // Template structure for new grammar rules\n  return [\n    {\n      id: 'example_grammar_rule',\n      title: 'Example Grammar Rule',\n      bulgarian_concept: 'Примерно граматическо правило',\n      german_concept: 'Beispielgrammatikregel',\n      difficulty: 'A1',\n      category: 'morphology',\n      cultural_context: {\n        bulgarian_perspective: 'Explanation from Bulgarian cultural viewpoint',\n        german_perspective: 'Explanation from German cultural viewpoint'\n      },\n      cross_linguistic_explanation: {\n        bg_to_de: 'Erklärung für bulgarische Sprecher auf Deutsch',\n        de_to_bg: 'Explanation for German speakers in English/Bulgarian'\n      },\n      examples: [\n        {\n          bulgarian: 'Примерно изречение',\n          german: 'Beispielsatz',\n          explanation_bg_to_de: 'Note for Bulgarian speakers',\n          explanation_de_to_bg: 'Note for German speakers'\n        }\n      ],\n      common_mistakes: {\n        bg_to_de: ['Common mistake 1', 'Common mistake 2'],\n        de_to_bg: ['Common mistake 1', 'Common mistake 2']\n      },\n      cultural_insight: 'Deeper cultural insight about this grammar concept'\n    }\n  ];\n}\n\n/**\n * Main execution\n */\nasync function main() {\n  const args = process.argv.slice(2);\n\n  if (args.length === 0) {\n    console.log(`\n📚 Grammar Fetching and Processing Script\n\nUsage:\n  node scripts/fetch-grammar.mjs <URL or file path>\n\nExamples:\n  node scripts/fetch-grammar.mjs https://example.com/bulgarian-grammar\n  node scripts/fetch-grammar.mjs ./docs/grammar-rules.md\n  node scripts/fetch-grammar.mjs https://de.wikibooks.org/wiki/Bulgarisch\n\nOptions:\n  --level <A1|A2|B1|B2>  Filter by CEFR level\n  --output <dir>         Output directory (default: content/grammar/)\n  --dry-run             Show what would be created without writing files\n    `);\n    process.exit(1);\n  }\n\n  const source = args[0];\n  const outputDir = path.join(rootDir, 'content', 'grammar');\n\n  // Ensure output directory exists\n  if (!fs.existsSync(outputDir)) {\n    fs.mkdirSync(outputDir, { recursive: true });\n  }\n\n  console.log('🚀 Starting grammar fetching process...\\n');\n\n  let grammarRules = [];\n\n  try {\n    // Determine if source is URL or file\n    grammarRules = await (source.startsWith('http://') || source.startsWith('https://') ? fetchGrammarFromURL(source) : parseGrammarFromFile(source));\n\n    console.log(`\\n📊 Extracted ${grammarRules.length} grammar rules\\n`);\n\n    // Validate each rule\n    let validCount = 0;\n    let errorCount = 0;\n\n    for (const [index, rule] of grammarRules.entries()) {\n      const errors = validateGrammarRule(rule);\n\n      if (errors.length > 0) {\n        console.log(`⚠️  Rule ${index + 1} (${rule.title || 'untitled'}) has errors:`);\n        for (const err of errors) {\n          console.log(`   - ${err}`);\n        }\n        errorCount++;\n      } else {\n        validCount++;\n      }\n    }\n\n    console.log(`\\n✅ Valid rules: ${validCount}`);\n    console.log(`❌ Rules with errors: ${errorCount}\\n`);\n\n    // Generate markdown files for valid rules\n    const validRules = grammarRules.filter(r => validateGrammarRule(r).length === 0);\n\n    console.log('📝 Generating markdown files...\\n');\n\n    for (const rule of validRules) {\n      generateMarkdownFile(rule, outputDir);\n    }\n\n    // Update cultural-grammar.json\n    updateCulturalGrammarJSON(validRules);\n\n    console.log('\\n🎉 Grammar fetching complete!');\n    console.log('\\nNext steps:');\n    console.log('1. Review generated files in content/grammar/');\n    console.log('2. Test with Hugo: npm run dev');\n    console.log('3. Verify grammar page renders correctly at /grammar/');\n    console.log('4. Commit changes to git\\n');\n\n  } catch (error) {\n    console.error('\\n❌ Error:', error.message);\n    process.exit(1);\n  }\n}\n\n// Run if called directly\nif (import.meta.url === `file://${process.argv[1]}`) {\n  main();\n}\n\nexport {\n  fetchGrammarFromURL,\n  parseGrammarFromFile,\n  validateGrammarRule,\n  generateMarkdownFile\n};\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/fetch-vocabulary.js","messages":[{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":3,"column":22,"nodeType":"Identifier","messageId":"error/identifier","endLine":3,"endColumn":29,"suggestions":[{"messageId":"suggestion/import","fix":{"range":[21,71],"text":"import { execSync } from 'node:child_process'"},"data":{"name":"require"},"desc":"Switch to `import`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":4,"column":12,"nodeType":"Identifier","messageId":"error/identifier","endLine":4,"endColumn":19,"suggestions":[{"messageId":"suggestion/import","fix":{"range":[73,102],"text":"import fs from 'node:fs'"},"data":{"name":"require"},"desc":"Switch to `import`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":5,"column":14,"nodeType":"Identifier","messageId":"error/identifier","endLine":5,"endColumn":21,"suggestions":[{"messageId":"suggestion/import","fix":{"range":[104,137],"text":"import path from 'node:path'"},"data":{"name":"require"},"desc":"Switch to `import`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":6,"column":23,"nodeType":"Identifier","messageId":"error/identifier","endLine":6,"endColumn":30,"suggestions":[{"messageId":"suggestion/import","fix":{"range":[139,181],"text":"import { promisify } from 'node:util'"},"data":{"name":"require"},"desc":"Switch to `import`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"__dirname\".","line":14,"column":34,"nodeType":"Identifier","messageId":"error/identifier","endLine":14,"endColumn":43,"suggestions":[{"messageId":"suggestion/import-meta-dirname","fix":{"range":[401,410],"text":"import.meta.dirname"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `import.meta.dirname`."},{"messageId":"suggestion/import-meta-url-to-dirname","fix":{"range":[401,410],"text":"path.dirname(url.fileURLToPath(import.meta.url))"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `…(import.meta.url)`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"__dirname\".","line":24,"column":36,"nodeType":"Identifier","messageId":"error/identifier","endLine":24,"endColumn":45,"suggestions":[{"messageId":"suggestion/import-meta-dirname","fix":{"range":[812,821],"text":"import.meta.dirname"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `import.meta.dirname`."},{"messageId":"suggestion/import-meta-url-to-dirname","fix":{"range":[812,821],"text":"path.dirname(url.fileURLToPath(import.meta.url))"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `…(import.meta.url)`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"__dirname\".","line":31,"column":39,"nodeType":"Identifier","messageId":"error/identifier","endLine":31,"endColumn":48,"suggestions":[{"messageId":"suggestion/import-meta-dirname","fix":{"range":[1085,1094],"text":"import.meta.dirname"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `import.meta.dirname`."},{"messageId":"suggestion/import-meta-url-to-dirname","fix":{"range":[1085,1094],"text":"path.dirname(url.fileURLToPath(import.meta.url))"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `…(import.meta.url)`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"__dirname\".","line":38,"column":44,"nodeType":"Identifier","messageId":"error/identifier","endLine":38,"endColumn":53,"suggestions":[{"messageId":"suggestion/import-meta-dirname","fix":{"range":[1456,1465],"text":"import.meta.dirname"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `import.meta.dirname`."},{"messageId":"suggestion/import-meta-url-to-dirname","fix":{"range":[1456,1465],"text":"path.dirname(url.fileURLToPath(import.meta.url))"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `…(import.meta.url)`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"__dirname\".","line":46,"column":34,"nodeType":"Identifier","messageId":"error/identifier","endLine":46,"endColumn":43,"suggestions":[{"messageId":"suggestion/import-meta-dirname","fix":{"range":[1889,1898],"text":"import.meta.dirname"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `import.meta.dirname`."},{"messageId":"suggestion/import-meta-url-to-dirname","fix":{"range":[1889,1898],"text":"path.dirname(url.fileURLToPath(import.meta.url))"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `…(import.meta.url)`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":100,"column":5,"nodeType":"Identifier","messageId":"error/identifier","endLine":100,"endColumn":12},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"module\".","line":100,"column":22,"nodeType":"Identifier","messageId":"error/identifier","endLine":100,"endColumn":28},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over an async function `fetchVocabulary` call.","line":106,"column":3,"nodeType":"CallExpression","messageId":"identifier","endLine":106,"endColumn":23,"suggestions":[{"messageId":"add-await","fix":{"range":[3441,3441],"text":"await "},"data":{"name":"fetchVocabulary"},"desc":"Insert `await`."}]}],"suppressedMessages":[],"errorCount":12,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nconst { execSync } = require('node:child_process');\nconst fs = require('node:fs');\nconst path = require('node:path');\nconst { promisify } = require('node:util');\n\nconst writeFile = promisify(fs.writeFile);\nconst readFile = promisify(fs.readFile);\n\nasync function fetchVocabulary(url) {\n  try {\n    // 1. Use Claude to fetch and process vocabulary\n    const promptPath = path.join(__dirname, '..', '.claude', 'prompts', 'fetch-vocabulary.txt');\n    const prompt = await readFile(promptPath, 'utf8');\n    \n    const claudeCmd = `claude -p \"${prompt}\\n\\nURL to process: ${url}\"`;\n    const result = execSync(claudeCmd, { encoding: 'utf8' });\n\n    // 2. Parse and validate the JSON\n    const vocab = JSON.parse(result);\n    \n    // 3. Load existing vocabulary\n    const existingPath = path.join(__dirname, '..', 'data', 'vocabulary.json');\n    const existing = JSON.parse(await readFile(existingPath, 'utf8'));\n\n    // 4. Merge and deduplicate\n    const merged = mergeVocabulary(existing, vocab);\n\n    // 5. Run semantic chunking\n    const chunkPromptPath = path.join(__dirname, '..', '.claude', 'prompts', 'semantic-chunk.txt');\n    const chunkPrompt = await readFile(chunkPromptPath, 'utf8');\n    \n    const chunkCmd = `claude -p \"${chunkPrompt}\\n\\nVocabulary to analyze: ${JSON.stringify(merged)}\"`;\n    const chunks = execSync(chunkCmd, { encoding: 'utf8' });\n\n    // 6. Validate progression\n    const validationPromptPath = path.join(__dirname, '..', '.claude', 'prompts', 'validate-progression.txt');\n    const validationPrompt = await readFile(validationPromptPath, 'utf8');\n    \n    const validateCmd = `claude -p \"${validationPrompt}\\n\\nVocabulary to validate: ${JSON.stringify(merged)}\"`;\n    const validation = execSync(validateCmd, { encoding: 'utf8' });\n\n    // 7. Save results\n    const timestamp = new Date().toISOString();\n    const resultsDir = path.join(__dirname, '..', 'data', 'vocabulary-updates');\n    \n    if (!fs.existsSync(resultsDir)) {\n      fs.mkdirSync(resultsDir, { recursive: true });\n    }\n\n    await writeFile(\n      path.join(resultsDir, `update-${timestamp}.json`),\n      JSON.stringify({\n        source: url,\n        timestamp,\n        vocabulary: merged,\n        semantic_analysis: JSON.parse(chunks),\n        progression_validation: JSON.parse(validation)\n      }, null, 2)\n    );\n\n    console.log(`\nVocabulary Processing Complete\n============================\nSource: ${url}\nNew entries: ${vocab.length}\nTotal entries: ${merged.length}\nResults saved to: data/vocabulary-updates/update-${timestamp}.json\n\nNext steps:\n1. Review the semantic analysis in the output file\n2. Check the progression validation report\n3. Run tests: npm run test\n4. If everything looks good, copy the new vocabulary.json to data/\n    `);\n\n  } catch (error) {\n    console.error('Error processing vocabulary:', error);\n    process.exit(1);\n  }\n}\n\nfunction mergeVocabulary(existing, newItems) {\n  const seen = new Set(existing.map(e => `${e.bulgarian}-${e.german}`));\n  const merged = [...existing];\n\n  for (const item of newItems) {\n    const key = `${item.bulgarian}-${item.german}`;\n    if (!seen.has(key)) {\n      merged.push(item);\n      seen.add(key);\n    }\n  }\n\n  return merged.sort((a, b) => a.id.localeCompare(b.id));\n}\n\n// If called directly\nif (require.main === module) {\n  const url = process.argv[2];\n  if (!url) {\n    console.error('Usage: node fetch-vocabulary.js <URL>');\n    process.exit(1);\n  }\n  fetchVocabulary(url);\n}","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/fix-vocabulary-examples.mjs","messages":[{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over using a promise chain.","line":74,"column":8,"nodeType":"Identifier","messageId":"promise","endLine":74,"endColumn":13}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * Fix vocabulary.json examples schema\n *\n * Problem: Some entries use {bg, de, context} schema\n * Expected: {sentence, translation, context} schema\n *\n * This script normalizes all examples to the expected schema.\n */\n\nimport { readFile, writeFile } from 'node:fs/promises';\n\nasync function main() {\n  const vocabPath = 'data/vocabulary.json';\n\n  console.log('📖 Reading vocabulary data...');\n  const data = JSON.parse(await readFile(vocabPath, 'utf8'));\n\n  let fixCount = 0;\n  let exampleCount = 0;\n\n  for (const entry of data) {\n    if (!entry.examples || !Array.isArray(entry.examples)) {\n      continue;\n    }\n\n    let entryFixed = false;\n    for (const example of entry.examples) {\n      // Check if example uses old schema (bg/de instead of sentence/translation)\n      if (example.bg !== undefined || example.de !== undefined) {\n        // Normalize to new schema\n        if (example.bg && !example.sentence) {\n          example.sentence = example.bg;\n          delete example.bg;\n          entryFixed = true;\n          exampleCount++;\n        }\n        if (example.de && !example.translation) {\n          example.translation = example.de;\n          delete example.de;\n          entryFixed = true;\n          exampleCount++;\n        }\n      }\n\n      // Ensure sentence and translation are strings (not null/undefined)\n      if (!example.sentence || typeof example.sentence !== 'string' || example.sentence.trim() === '') {\n        console.warn(`⚠️  Entry ${entry.id}: example has invalid sentence field`);\n      }\n      if (!example.translation || typeof example.translation !== 'string' || example.translation.trim() === '') {\n        console.warn(`⚠️  Entry ${entry.id}: example has invalid translation field`);\n      }\n    }\n\n    if (entryFixed) {\n      fixCount++;\n    }\n  }\n\n  console.log(`✅ Fixed ${exampleCount} examples in ${fixCount} entries`);\n\n  // Create backup\n  const backupPath = 'data/vocabulary.json.backup';\n  console.log(`💾 Creating backup: ${backupPath}`);\n  await writeFile(backupPath, JSON.stringify(data, null, 2), 'utf8');\n\n  // Write fixed data\n  console.log(`💾 Writing fixed data to ${vocabPath}`);\n  await writeFile(vocabPath, JSON.stringify(data, null, 2), 'utf8');\n\n  console.log('✨ Done! Run `npm run lint:data` to verify.');\n}\n\nmain().catch(error => {\n  console.error('❌ Error:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/fix-vocabulary.js","messages":[{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":3,"column":12,"nodeType":"Identifier","messageId":"error/identifier","endLine":3,"endColumn":19,"suggestions":[{"messageId":"suggestion/import","fix":{"range":[21,50],"text":"import fs from 'node:fs'"},"data":{"name":"require"},"desc":"Switch to `import`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":4,"column":14,"nodeType":"Identifier","messageId":"error/identifier","endLine":4,"endColumn":21,"suggestions":[{"messageId":"suggestion/import","fix":{"range":[52,85],"text":"import path from 'node:path'"},"data":{"name":"require"},"desc":"Switch to `import`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"__dirname\".","line":6,"column":29,"nodeType":"Identifier","messageId":"error/identifier","endLine":6,"endColumn":38,"suggestions":[{"messageId":"suggestion/import-meta-dirname","fix":{"range":[116,125],"text":"import.meta.dirname"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `import.meta.dirname`."},{"messageId":"suggestion/import-meta-url-to-dirname","fix":{"range":[116,125],"text":"path.dirname(url.fileURLToPath(import.meta.url))"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `…(import.meta.url)`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"__dirname\".","line":7,"column":29,"nodeType":"Identifier","messageId":"error/identifier","endLine":7,"endColumn":38,"suggestions":[{"messageId":"suggestion/import-meta-dirname","fix":{"range":[183,192],"text":"import.meta.dirname"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `import.meta.dirname`."},{"messageId":"suggestion/import-meta-url-to-dirname","fix":{"range":[183,192],"text":"path.dirname(url.fileURLToPath(import.meta.url))"},"data":{"name":"__dirname"},"desc":"Replace `__dirname` with `…(import.meta.url)`."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\nconst fs = require('node:fs');\nconst path = require('node:path');\n\nconst vocabPath = path.join(__dirname, '../data/vocabulary.json');\nconst batchPath = path.join(__dirname, '../data/vocabulary-batch-1-numbers-verbs.json');\n\nconsole.log('Reading vocabulary.json...');\nlet content = fs.readFileSync(vocabPath, 'utf8');\n\n// Fix all instances of \\\\n to \\n (double backslash-n to single backslash-n)\nconsole.log('Fixing \\\\\\\\n to \\\\n...');\nconst originalLength = content.length;\ncontent = content.replaceAll('\\\\\\\\n', '\\\\n');\nconsole.log(`Replaced ${originalLength - content.length} characters`);\n\n// Write the fixed content\nconsole.log('Writing fixed vocabulary.json...');\nfs.writeFileSync(vocabPath, content, 'utf8');\n\n// Parse to verify it's valid JSON now\ntry {\n  const vocabData = JSON.parse(content);\n  console.log(`✓ JSON parses successfully! Found ${vocabData.length} entries`);\n  \n  // Now merge the batch file\n  console.log('\\nReading batch file...');\n  const batchContent = fs.readFileSync(batchPath, 'utf8');\n  const batchData = JSON.parse(batchContent);\n  console.log(`Found ${batchData.length} batch entries to merge`);\n  \n  // Check for duplicates by ID\n  const existingIds = new Set(vocabData.map(e => e.id));\n  const newEntries = batchData.filter(e => !existingIds.has(e.id));\n  const duplicates = batchData.filter(e => existingIds.has(e.id));\n  \n  if (duplicates.length > 0) {\n    console.log(`\\nFound ${duplicates.length} duplicate entries (will skip):`);\n    for (const e of duplicates) {\n      console.log(`  - ${e.id}: ${e.word}`);\n    }\n  }\n  \n  console.log(`\\nMerging ${newEntries.length} new entries...`);\n  const mergedData = [...vocabData, ...newEntries];\n  \n  // Write the merged file\n  fs.writeFileSync(vocabPath, JSON.stringify(mergedData, null, 2), 'utf8');\n  console.log(`✓ Merged successfully! Total entries: ${mergedData.length}`);\n  \n} catch (error) {\n  console.error('✗ JSON parse error after fix:', error.message);\n  process.exit(1);\n}\n\nconsole.log('\\n✓ All done!');\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/generate-workbox.js","messages":[{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":8,"column":24,"nodeType":"Identifier","messageId":"error/identifier","endLine":8,"endColumn":31,"suggestions":[{"messageId":"suggestion/import","fix":{"range":[150,197],"text":"import { generateSW } from 'workbox-build'"},"data":{"name":"require"},"desc":"Switch to `import`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":9,"column":12,"nodeType":"Identifier","messageId":"error/identifier","endLine":9,"endColumn":19,"suggestions":[{"messageId":"suggestion/import","fix":{"range":[199,228],"text":"import fs from 'node:fs'"},"data":{"name":"require"},"desc":"Switch to `import`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":10,"column":14,"nodeType":"Identifier","messageId":"error/identifier","endLine":10,"endColumn":21,"suggestions":[{"messageId":"suggestion/import","fix":{"range":[230,263],"text":"import path from 'node:path'"},"data":{"name":"require"},"desc":"Switch to `import`."}]},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":26,"column":10,"nodeType":"Identifier","messageId":"error/identifier","endLine":26,"endColumn":17},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over using a promise chain.","line":228,"column":32,"nodeType":"Identifier","messageId":"promise","endLine":228,"endColumn":37}],"suppressedMessages":[],"errorCount":5,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * Workbox Service Worker Generator\n * Generates a Workbox-powered service worker for the Bulgarian-German Learning App\n */\n\nconst { generateSW } = require('workbox-build');\nconst fs = require('node:fs');\nconst path = require('node:path');\n\nasync function generateWorkboxServiceWorker() {\n  console.log('🔧 Generating Workbox service worker...');\n  \n  try {\n    // Check if static directory exists\n    const staticDir = path.join(process.cwd(), 'static');\n    if (!fs.existsSync(staticDir)) {\n      console.error('❌ Static directory not found.');\n      process.exit(1);\n    }\n    \n    // Generate the service worker using Workbox\n    const { count, size, warnings } = await generateSW({\n      // Use the configuration from workbox-config.js\n      ...require('../workbox-config.js'),\n      \n      // Additional configuration for better integration\n      manifestTransforms: [\n        // Transform manifest entries to work with Hugo's asset fingerprinting\n        (manifestEntries) => {\n          const manifest = manifestEntries.map(entry => {\n            // Handle Hugo's fingerprinted assets\n            if (/\\.\\w{8}\\./.test(entry.url)) {\n              // Remove revision parameter for fingerprinted files\n              return { ...entry, revision: null };\n            }\n            return entry;\n          });\n          \n          console.log(`📦 Precaching ${manifest.length} files`);\n          return { manifest, warnings: [] };\n        }\n      ]\n    });\n    \n    // Log results\n    console.log('✅ Workbox service worker generated successfully!');\n    console.log(`📊 Precached ${count} files, total size: ${(size / 1024 / 1024).toFixed(2)} MB`);\n    \n    if (warnings.length > 0) {\n      console.warn('⚠️  Warnings:');\n      for (const warning of warnings) {\n        console.warn(`   ${warning}`);\n      }\n    }\n    \n    // Add custom logic to the generated service worker\n    await enhanceServiceWorker();\n    \n  } catch (error) {\n    console.error('❌ Failed to generate Workbox service worker:', error);\n    process.exit(1);\n  }\n}\n\nasync function enhanceServiceWorker() {\n  const swPath = path.join(process.cwd(), 'static/sw.js');\n  \n  if (!fs.existsSync(swPath)) {\n    console.error('❌ Service worker file not found:', swPath);\n    return;\n  }\n  \n  let swContent = fs.readFileSync(swPath, 'utf8');\n  \n  // Add custom message handling for backward compatibility\n  const customMessageHandling = `\n// Custom message handling for backward compatibility\nself.addEventListener('message', (event) => {\n  const { type, data } = event.data;\n  \n  switch (type) {\n    case 'SKIP_WAITING':\n      console.log('[Workbox SW] Received skip waiting message');\n      self.skipWaiting();\n      break;\n      \n    case 'GET_VERSION':\n      event.ports[0]?.postMessage({\n        version: 'bgde-app-workbox',\n        dataVersion: 'bgde-data-workbox'\n      });\n      break;\n      \n    case 'CLEAR_CACHE':\n      console.log('[Workbox SW] Clearing all caches...');\n      caches.keys().then((cacheNames) => {\n        return Promise.all(\n          cacheNames.map((cacheName) => caches.delete(cacheName))\n        );\n      }).then(() => {\n        event.ports[0]?.postMessage({ success: true });\n      }).catch((error) => {\n        event.ports[0]?.postMessage({ success: false, error: error.message });\n      });\n      break;\n      \n    case 'PREFETCH_VOCABULARY':\n      if (data && data.items) {\n        prefetchVocabularyItems(data.items);\n      }\n      break;\n      \n    case 'PRECACHE_URLS':\n      if (data && Array.isArray(data.urls) && data.urls.length) {\n        event.waitUntil(precacheRuntimeAssets(data.urls));\n      }\n      break;\n      \n    default:\n      console.log('[Workbox SW] Unknown message type:', type);\n  }\n});\n\n// Prefetch vocabulary items for offline use\nasync function prefetchVocabularyItems(items) {\n  const cache = await caches.open('data-cache');\n  const prefetchPromises = [];\n  \n  items.forEach((item) => {\n    // Prefetch audio files if available\n    if (item.audio_url) {\n      prefetchPromises.push(\n        fetch(item.audio_url)\n          .then((response) => {\n            if (response.ok) {\n              cache.put(item.audio_url, response.clone());\n            }\n          })\n          .catch(() => {}) // Ignore prefetch errors\n      );\n    }\n    \n    // Prefetch individual vocabulary pages\n    const vocabUrl = \\`/vocabulary/\\${item.id}/\\`;\n    prefetchPromises.push(\n      fetch(vocabUrl)\n        .then((response) => {\n          if (response.ok) {\n            cache.put(vocabUrl, response.clone());\n          }\n        })\n        .catch(() => {}) // Ignore prefetch errors\n    );\n  });\n  \n  // Limit concurrent prefetch requests\n  const batchSize = 5;\n  for (let i = 0; i < prefetchPromises.length; i += batchSize) {\n    const batch = prefetchPromises.slice(i, i + batchSize);\n    await Promise.allSettled(batch);\n    \n    // Small delay between batches to avoid overwhelming the network\n    await new Promise(resolve => setTimeout(resolve, 100));\n  }\n  \n  console.log('[Workbox SW] Prefetch completed for', items.length, 'vocabulary items');\n}\n\n// Precache runtime assets\nasync function precacheRuntimeAssets(urls) {\n  const cache = await caches.open('html-pages');\n  const precachePromises = urls.map(url => \n    fetch(url)\n      .then(response => {\n        if (response.ok) {\n          cache.put(url, response.clone());\n        }\n      })\n      .catch(() => {}) // Ignore errors\n  );\n  \n  await Promise.allSettled(precachePromises);\n  console.log('[Workbox SW] Runtime precache completed for', urls.length, 'URLs');\n}\n\n// Enhanced activation with custom notifications\nconst originalActivate = self.addEventListener('activate', (event) => {\n  event.waitUntil(\n    (async () => {\n      // Call original activation logic\n      await self.clients.claim();\n      \n      // Notify all clients about the update\n      const clients = await self.clients.matchAll();\n      clients.forEach((client) => {\n        client.postMessage({\n          type: 'SW_ACTIVATED',\n          version: 'bgde-app-workbox'\n        });\n      });\n      \n      console.log('[Workbox SW] Enhanced activation completed');\n    })()\n  );\n});\n`;\n\n  // Find the position to inject custom code (after Workbox's main logic)\n  const injectionPoint = swContent.lastIndexOf('workbox.precaching.precacheAndRoute');\n  \n  if (injectionPoint === -1) {\n    console.warn('⚠️  Could not find injection point for custom code');\n  } else {\n    // Find the next line after the precache call\n    const nextLineIndex = swContent.indexOf('\\n', injectionPoint) + 1;\n    \n    // Inject custom code\n    swContent = swContent.slice(0, nextLineIndex) + customMessageHandling + swContent.slice(nextLineIndex);\n    \n    fs.writeFileSync(swPath, swContent, 'utf8');\n    console.log('✅ Enhanced service worker with custom functionality');\n  }\n}\n\n// Run the generator\ngenerateWorkboxServiceWorker().catch(console.error);","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/merge-vocabulary.mjs","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'existsSync' is defined but never used.","line":9,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":20},{"ruleId":"unicorn/text-encoding-identifier-case","severity":2,"message":"Prefer `utf8` over `utf-8`.","line":70,"column":42,"nodeType":"Literal","messageId":"text-encoding-identifier/error","endLine":70,"endColumn":49,"suggestions":[{"messageId":"text-encoding-identifier/suggestion","fix":{"range":[1991,1996],"text":"utf8"},"data":{"value":"utf-8","replacement":"utf8"},"desc":"Replace `utf-8` with `utf8`."}]},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over using a promise chain.","line":199,"column":8,"nodeType":"Identifier","messageId":"promise","endLine":199,"endColumn":13}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * @file merge-vocabulary.mjs\n * @description Merge vocabulary.json and vocabulary-enhanced.json into single source\n * @usage node scripts/merge-vocabulary.mjs [--dry-run] [--output=path]\n */\n\nimport { readFile, writeFile } from 'node:fs/promises';\nimport { existsSync } from 'node:fs';\n\nconst PRIMARY_PATH = 'data/vocabulary.json';\nconst ENHANCED_PATH = 'data/vocabulary-enhanced.json';\nconst BACKUP_SUFFIX = `.backup.${new Date().toISOString().split('T')[0]}.json`;\n\nfunction mergeExamples(primEx = [], enhEx = []) {\n  const seen = new Set();\n  const merged = [];\n  \n  for (const ex of [...primEx, ...enhEx]) {\n    const key = ex.sentence?.trim().toLowerCase();\n    if (key && !seen.has(key)) {\n      seen.add(key);\n      merged.push(ex);\n    }\n  }\n  \n  return merged.length > 0 ? merged : undefined;\n}\n\nfunction mergeEntries(prim, enh) {\n  // Start with primary entry as base\n  const merged = { ...prim };\n  \n  // Override with enhanced values if present and non-null\n  for (const key of Object.keys(enh)) {\n    if (enh[key] !== null && enh[key] !== undefined) {\n      // Skip overwriting for certain fields\n      if (key === 'examples') {\n        continue;\n      } // Handle separately\n      if (key === 'id') {\n        continue;\n      } // Never override ID\n      \n      // For string fields, prefer non-empty enhanced value\n      if (typeof enh[key] === 'string' && enh[key].trim().length > 0) {\n        merged[key] = enh[key];\n      } else if (typeof enh[key] !== 'string') {\n        merged[key] = enh[key];\n      }\n    }\n  }\n  \n  // Merge examples arrays\n  merged.examples = mergeExamples(prim.examples, enh.examples);\n  \n  // Ensure directional notes are populated\n  if (!merged.notes_bg_to_de && merged.notes) {\n    merged.notes_bg_to_de = merged.notes;\n  }\n  if (!merged.notes_de_to_bg && merged.notes) {\n    merged.notes_de_to_bg = merged.notes;\n  }\n  \n  return merged;\n}\n\nasync function loadJSON(path) {\n  try {\n    const content = await readFile(path, 'utf-8');\n    return JSON.parse(content);\n  } catch (error) {\n    console.error(`Failed to load ${path}:`, error.message);\n    return null;\n  }\n}\n\nasync function main() {\n  const args = process.argv.slice(2);\n  const isDryRun = args.includes('--dry-run');\n  const outputArg = args.find(arg => arg.startsWith('--output='));\n  const outputPath = outputArg ? outputArg.split('=')[1] : 'data/vocabulary-merged.json';\n  \n  console.log('🔍 Loading vocabulary datasets...\\n');\n  \n  const primary = await loadJSON(PRIMARY_PATH);\n  const enhanced = await loadJSON(ENHANCED_PATH);\n  \n  if (!primary) {\n    console.error(`❌ Failed to load primary dataset: ${PRIMARY_PATH}`);\n    process.exit(1);\n  }\n  \n  if (!enhanced) {\n    console.warn(`⚠️  Enhanced dataset not found or invalid: ${ENHANCED_PATH}`);\n    console.log('Proceeding with primary dataset only.\\n');\n  }\n  \n  // Build ID map from primary\n  const idMap = new Map();\n  for (const entry of primary) {\n    idMap.set(entry.id, { source: 'primary', data: entry });\n  }\n  \n  console.log(`📚 Primary dataset: ${primary.length} entries`);\n  console.log(`✨ Enhanced dataset: ${enhanced ? enhanced.length : 0} entries\\n`);\n  \n  // Merge enhanced entries\n  let mergedCount = 0;\n  let addedCount = 0;\n  \n  if (enhanced && Array.isArray(enhanced)) {\n    for (const enhEntry of enhanced) {\n      if (!enhEntry.id) {\n        console.warn('⚠️  Skipping enhanced entry without ID');\n        continue;\n      }\n      \n      if (idMap.has(enhEntry.id)) {\n        const primEntry = idMap.get(enhEntry.id).data;\n        const merged = mergeEntries(primEntry, enhEntry);\n        idMap.set(enhEntry.id, { source: 'merged', data: merged });\n        mergedCount++;\n      } else {\n        idMap.set(enhEntry.id, { source: 'enhanced', data: enhEntry });\n        addedCount++;\n      }\n    }\n  }\n  \n  // Build final merged array\n  const mergedArray = [...idMap.values()].map(entry => entry.data);\n  \n  // Report\n  console.log('📊 Merge Statistics:');\n  console.log(`   Total entries: ${mergedArray.length}`);\n  console.log(`   Merged (enhanced data): ${mergedCount}`);\n  console.log(`   Added (enhanced only): ${addedCount}`);\n  console.log(`   Primary only: ${mergedArray.length - mergedCount - addedCount}\\n`);\n  \n  // Check for entries with generic notes but missing directional notes\n  let warningCount = 0;\n  for (const entry of mergedArray) {\n    if (entry.notes && !entry.notes_bg_to_de && !entry.notes_de_to_bg) {\n      if (warningCount < 5) {\n        console.warn(`⚠️  ${entry.id}: has generic notes but missing directional notes`);\n      }\n      warningCount++;\n    }\n  }\n  \n  if (warningCount > 5) {\n    console.warn(`   ... and ${warningCount - 5} more warnings\\n`);\n  } else if (warningCount > 0) {\n    console.log('');\n  }\n  \n  if (isDryRun) {\n    console.log('🔍 DRY RUN - No files written');\n    console.log(`   Would write to: ${outputPath}\\n`);\n    \n    // Show sample merged entry\n    const sample = mergedArray.find(e => idMap.get(e.id).source === 'merged');\n    if (sample) {\n      console.log('Sample merged entry:');\n      console.log(JSON.stringify(sample, null, 2).split('\\n').slice(0, 20).join('\\n'));\n      console.log('   ...\\n');\n    }\n  } else {\n    // Create backup of primary\n    const backupPath = PRIMARY_PATH.replace('.json', BACKUP_SUFFIX);\n    try {\n      await writeFile(backupPath, JSON.stringify(primary, null, 2));\n      console.log(`✅ Backup created: ${backupPath}`);\n    } catch (error) {\n      console.error(`❌ Failed to create backup: ${error.message}`);\n      process.exit(1);\n    }\n    \n    // Write merged data\n    try {\n      await writeFile(outputPath, JSON.stringify(mergedArray, null, 2));\n      console.log(`✅ Merged data written: ${outputPath}`);\n      console.log(`   ${mergedArray.length} entries\\n`);\n    } catch (error) {\n      console.error(`❌ Failed to write merged data: ${error.message}`);\n      process.exit(1);\n    }\n    \n    console.log('🎉 Merge complete!');\n    console.log('\\nNext steps:');\n    console.log('1. Run: npm run lint:data');\n    console.log('2. Test: npm run dev (verify practice sessions)');\n    console.log(`3. Replace: mv ${outputPath} ${PRIMARY_PATH}`);\n    console.log(`4. Archive: mv ${ENHANCED_PATH} data/archive/\\n`);\n  }\n}\n\nmain().catch(error => {\n  console.error('❌ Merge script failed:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/migrate-grammar.mjs","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'timestamp' is assigned a value but never used.","line":50,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":50,"endColumn":16},{"ruleId":"unicorn/text-encoding-identifier-case","severity":2,"message":"Prefer `utf8` over `utf-8`.","line":160,"column":40,"nodeType":"Literal","messageId":"text-encoding-identifier/error","endLine":160,"endColumn":47,"suggestions":[{"messageId":"text-encoding-identifier/suggestion","fix":{"range":[5127,5132],"text":"utf8"},"data":{"value":"utf-8","replacement":"utf8"},"desc":"Replace `utf-8` with `utf8`."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * Grammar Migration Script\n *\n * Migrates grammar data from data/grammar.json into rich Markdown files\n * following Hugo best practices for content-driven pages.\n *\n * Strategy:\n * - Read data/grammar.json (source of truth for content)\n * - For each grammar topic, create enriched MD file with:\n *   - Complete frontmatter (metadata)\n *   - Prose content (main explanation)\n *   - Bidirectional learning notes\n *   - Examples in markdown format\n * - Archive old grammar.json after migration\n */\n\nimport fs from 'node:fs';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nconst rootDir = path.resolve(__dirname, '..');\n\n// Load grammar JSON data\nconst grammarData = JSON.parse(\n  fs.readFileSync(path.join(rootDir, 'data', 'grammar.json'), 'utf8')\n);\n\nconsole.log(`📚 Loaded ${grammarData.length} grammar topics from data/grammar.json\\n`);\n\n// Mapping from grammar IDs to MD filenames\nconst fileMapping = {\n  'word_order': 'word-order.md',\n  'gender_of_nouns': 'gender-of-nouns.md',\n  'singular_and_plural': 'singular-and-plural.md',\n  'definite_article': 'definite-article.md',\n  'pronouns_and_cases': 'pronouns-and-cases.md',\n  'present_and_future_tenses': 'present-and-future-tenses.md',\n  'past_tenses': 'past-tenses.md',\n  'quantifiers_and_numbers': 'quantifiers-and-numbers.md',\n  'time_expressions': 'time-expressions.md',\n  'food_and_shopping_vocabulary': 'food-and-shopping-vocabulary.md',\n  'travel_and_directions': 'travel-and-directions.md'\n};\n\n// Create backup\nconst timestamp = new Date().toISOString().split('T')[0];\nconst contentDir = path.join(rootDir, 'content', 'grammar');\nconst backupDir = path.join(rootDir, 'archive', 'old-grammar-md');\n\nif (!fs.existsSync(backupDir)) {\n  fs.mkdirSync(backupDir, { recursive: true });\n}\n\n// Backup existing MD files\nconst existingFiles = fs.readdirSync(contentDir).filter(f => f.endsWith('.md') && f !== '_index.md');\nfor (const file of existingFiles) {\n  const src = path.join(contentDir, file);\n  const dest = path.join(backupDir, file);\n  fs.copyFileSync(src, dest);\n}\n\nconsole.log(`✅ Backed up ${existingFiles.length} existing grammar MD files to ${backupDir}\\n`);\n\n// Generate enriched markdown for each grammar topic\nlet migratedCount = 0;\nconst warnings = [];\n\nfor (const topic of grammarData) {\n  const filename = fileMapping[topic.id];\n\n  if (!filename) {\n    warnings.push(`⚠️  No filename mapping for ID: ${topic.id}`);\n    continue;\n  }\n\n  const filePath = path.join(contentDir, filename);\n\n  // Build frontmatter\n  const frontmatter = {\n    title: topic.title,\n    description: topic.summary || topic.content.split('\\n')[0],\n    level: topic.level,\n    type: 'grammar',\n    weight: topic.level === 'A1' ? 10 : 20,\n    category: topic.category || 'grammar',\n    date: '2025-10-24',\n    tags: [topic.level, 'grammar']\n  };\n\n  // If bidirectional notes exist, add them to frontmatter\n  if (topic.notes_bg_to_de || topic.notes_de_to_bg) {\n    frontmatter.notes_bg_to_de = topic.notes_bg_to_de || '';\n    frontmatter.notes_de_to_bg = topic.notes_de_to_bg || '';\n  }\n\n  // Build markdown content\n  let markdown = '---\\n';\n\n  // Write frontmatter in YAML\n  for (const [key, value] of Object.entries(frontmatter)) {\n    if (typeof value === 'string') {\n      // Escape quotes and handle multiline\n      markdown += value.includes('\\n') || value.includes('\"') || value.includes(':') ? `${key}: |\\n  ${value.replaceAll('\\n', '\\n  ')}\\n` : `${key}: \"${value}\"\\n`;\n    } else if (Array.isArray(value)) {\n      markdown += `${key}:\\n${value.map(v => `  - \"${v}\"`).join('\\n')}\\n`;\n    } else {\n      markdown += `${key}: ${value}\\n`;\n    }\n  }\n\n  markdown += '---\\n\\n';\n\n  // Add main content\n  markdown += `# ${topic.title}\\n\\n`;\n\n  // Add summary\n  if (topic.summary) {\n    markdown += '## Overview\\n\\n';\n    markdown += `${topic.summary}\\n\\n`;\n  }\n\n  // Add detailed explanation\n  markdown += '## Explanation\\n\\n';\n  markdown += topic.content.split('\\n').join('\\n\\n') + '\\n\\n';\n\n  // Add bidirectional learning notes\n  if (topic.notes_bg_to_de || topic.notes_de_to_bg) {\n    markdown += '## Learning Notes\\n\\n';\n\n    if (topic.notes_de_to_bg) {\n      markdown += '### For German Speakers (Für Deutschsprachige)\\n\\n';\n      markdown += `${topic.notes_de_to_bg}\\n\\n`;\n    }\n\n    if (topic.notes_bg_to_de) {\n      markdown += '### For Bulgarian Speakers (За български говорещи)\\n\\n';\n      markdown += `${topic.notes_bg_to_de}\\n\\n`;\n    }\n  }\n\n  // Add examples\n  if (topic.examples && topic.examples.length > 0) {\n    markdown += '## Examples\\n\\n';\n\n    for (const [index, example] of topic.examples.entries()) {\n      markdown += `${index + 1}. **${example.sentence}**\\n`;\n      markdown += `   - *${example.translation}*\\n\\n`;\n    }\n  }\n\n  // Add practice section placeholder\n  markdown += '## Practice\\n\\n';\n  markdown += 'Try creating your own sentences using the patterns above. Focus on understanding how the grammar rule applies in different contexts.\\n\\n';\n\n  // Write the file\n  fs.writeFileSync(filePath, markdown, 'utf-8');\n  migratedCount++;\n  console.log(`✅ Migrated: ${topic.title} → ${filename}`);\n}\n\nconsole.log('\\n📊 Migration Summary:');\nconsole.log(`   Topics migrated: ${migratedCount}/${grammarData.length}`);\nconsole.log(`   Files updated: ${migratedCount}`);\n\nif (warnings.length > 0) {\n  console.log('\\n⚠️  Warnings:');\n  for (const w of warnings) {\n    console.log(`   ${w}`);\n  }\n}\n\nconsole.log('\\n🎉 Grammar migration complete!');\nconsole.log('\\nNext steps:');\nconsole.log('1. Review migrated files in content/grammar/');\nconsole.log('2. Test with Hugo: npm run dev');\nconsole.log('3. Archive data/grammar.json: mv data/grammar.json data/archive/');\nconsole.log('4. Commit changes');\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/normalize-data.mjs","messages":[{"ruleId":"unicorn/no-array-reduce","severity":2,"message":"`Array#reduce()` is not allowed","line":128,"column":6,"nodeType":"Identifier","messageId":"no-reduce","endLine":128,"endColumn":12},{"ruleId":"unicorn/explicit-length-check","severity":2,"message":"Use `.length > 0` when checking length is not zero.","line":154,"column":49,"nodeType":"MemberExpression","messageId":"non-zero","endLine":154,"endColumn":70,"suggestions":[{"messageId":"suggestion","fix":{"range":[4594,4615],"text":"copy.id.trim().length > 0"},"data":{"code":"> 0","property":"length"},"desc":"Replace `.length` with `.length > 0`."}]},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over using a promise chain.","line":287,"column":8,"nodeType":"Identifier","messageId":"promise","endLine":287,"endColumn":13}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n/**\n * Normalize vocabulary and grammar datasets so they satisfy schema validation.\n * - Fills missing IDs, source/target language codes, and coerces numeric fields.\n * - Upgrades grammar entries to provide summary/content and structured examples.\n */\n\nimport { readFile, writeFile } from 'node:fs/promises';\nimport path from 'node:path';\nimport { fileURLToPath } from 'node:url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\nconst rootDir = path.resolve(__dirname, '..');\n\nconst dataPath = (relative) => path.join(rootDir, 'data', relative);\n\nfunction slugify(value, fallback) {\n  if (!value) {\n    return fallback;\n  }\n  const normalized = value\n    .toString()\n    .normalize('NFKD')\n    .replaceAll(/[\\u0300-\\u036F]/g, '')\n    .toLowerCase()\n    .replaceAll(/[^\\da-z]+/g, '_')\n    .replaceAll(/^_|_$/g, '');\n  return normalized || fallback;\n}\n\nfunction coerceNumberInRange(value, min, max) {\n  if (value === undefined || value === null || value === '') {\n    return;\n  }\n  const num = Number(value);\n  if (!Number.isFinite(num)) {\n    return;\n  }\n  return Math.min(max, Math.max(min, num));\n}\n\nfunction ensureUniqueId(base, used) {\n  const sanitizedBase = base || 'entry';\n  let candidate = sanitizedBase;\n  let counter = 1;\n  while (used.has(candidate)) {\n    const suffix = String(counter).padStart(2, '0');\n    candidate = `${sanitizedBase}_${suffix}`;\n    counter += 1;\n  }\n  used.add(candidate);\n  return candidate;\n}\n\nconst latinRegex = /^[\\p{Script=Latin}A-Za-z]/u;\n\nfunction formatExamples(examples, { preserveEmpty = false } = {}) {\n  if (!Array.isArray(examples)) {\n    return preserveEmpty ? [] : undefined;\n  }\n  return examples\n    .map((example) => {\n      if (!example) {\n        return null;\n      }\n      if (typeof example === 'string') {\n        const trimmed = example.trim();\n        if (!trimmed) {\n          return null;\n        }\n        const parenMatch = trimmed.match(/^(.*?)(?:\\s*\\(([^)]*)\\))?$/);\n        const baseText = parenMatch?.[1]?.trim() || trimmed;\n        const parenNote = parenMatch?.[2]?.trim();\n\n        let sentence = baseText;\n        const translationSegments = [];\n\n        const dashIndex = baseText.indexOf(' – ');\n        if (dashIndex !== -1) {\n          const lhs = baseText.slice(0, dashIndex).trim();\n          const rhs = baseText.slice(dashIndex + 3).trim();\n          if (rhs && latinRegex.test(rhs)) {\n            sentence = lhs;\n            translationSegments.push(rhs);\n          } else if (lhs) {\n            sentence = `${lhs} – ${rhs}`.trim();\n          }\n        }\n\n        if (parenNote) {\n          translationSegments.push(parenNote);\n        }\n\n        let translation = '';\n        if (translationSegments.length === 1) {\n          translation = translationSegments[0].trim();\n        } else if (translationSegments.length > 1) {\n          const [primary, ...rest] = translationSegments;\n          translation = `${primary.trim()} (${rest.join('; ').trim()})`.trim();\n        }\n\n        if (!translation) {\n          translation = dashIndex === -1\n            ? sentence\n            : baseText.slice(baseText.indexOf(' – ') + 3).trim() || sentence;\n        }\n\n        return { sentence, translation };\n      }\n      if (typeof example === 'object') {\n        return {\n          sentence: example.sentence?.trim() || '',\n          translation: example.translation?.trim() || '',\n          context: example.context ?? undefined,\n          note: example.note ?? undefined\n        };\n      }\n      return null;\n    })\n    .filter((example) => example && (example.sentence || example.translation))\n    .map((example) => ({\n      ...example,\n      sentence: example.sentence?.trim() || '',\n      translation: example.translation?.trim() || ''\n    }))\n    .filter((example) => example.sentence || example.translation)\n    .reduce((acc, example) => {\n      if (!example.translation) {\n        example.translation = example.sentence;\n      }\n      acc.push(example);\n      return acc;\n    }, []);\n}\n\nasync function normalizeVocabulary() {\n  const vocabRaw = await readFile(dataPath('vocabulary.json'), 'utf8');\n  const vocab = JSON.parse(vocabRaw);\n  const usedIds = new Set();\n\n  const normalized = vocab.map((entry, index) => {\n    if (!entry || typeof entry !== 'object') {\n      return entry;\n    }\n    const copy = { ...entry };\n\n    const fallbackBase =\n      slugify(copy.translation, '') ||\n      slugify(copy.word, '') ||\n      `term_${String(index + 1).padStart(3, '0')}`;\n\n    const hasExistingId =\n      copy.id && typeof copy.id === 'string' && copy.id.trim().length;\n    const baseId = hasExistingId ? copy.id.trim() : fallbackBase;\n    copy.id = ensureUniqueId(baseId, usedIds);\n    copy.word = typeof copy.word === 'string' ? copy.word.trim() : copy.word;\n    copy.translation =\n      typeof copy.translation === 'string'\n        ? copy.translation.trim()\n        : copy.translation;\n    copy.source_lang =\n      typeof copy.source_lang === 'string' && copy.source_lang.trim().length > 0\n        ? copy.source_lang.trim()\n        : 'bg';\n    copy.target_lang =\n      typeof copy.target_lang === 'string' && copy.target_lang.trim().length > 0\n        ? copy.target_lang.trim()\n        : 'de';\n    copy.category =\n      typeof copy.category === 'string' && copy.category.trim().length > 0\n        ? copy.category.trim()\n        : copy.category ?? null;\n    copy.level =\n      typeof copy.level === 'string' && copy.level.trim().length > 0\n        ? copy.level.trim()\n        : copy.level ?? null;\n    copy.notes =\n      typeof copy.notes === 'string' && copy.notes.trim().length > 0\n        ? copy.notes.trim()\n        : copy.notes ?? null;\n    copy.etymology =\n      typeof copy.etymology === 'string' && copy.etymology.trim().length > 0\n        ? copy.etymology.trim()\n        : copy.etymology ?? null;\n    copy.cultural_note =\n      typeof copy.cultural_note === 'string' && copy.cultural_note.trim().length > 0\n        ? copy.cultural_note.trim()\n        : copy.cultural_note ?? null;\n    copy.linguistic_note =\n      typeof copy.linguistic_note === 'string' &&\n      copy.linguistic_note.trim().length > 0\n        ? copy.linguistic_note.trim()\n        : copy.linguistic_note ?? null;\n\n    const difficulty = coerceNumberInRange(copy.difficulty, 1, 5);\n    copy.difficulty = difficulty ?? copy.difficulty ?? null;\n    const frequency = coerceNumberInRange(copy.frequency, 0, 100);\n    copy.frequency = frequency ?? copy.frequency ?? null;\n\n    const formattedExamples = formatExamples(copy.examples);\n    copy.examples = formattedExamples?.length ? formattedExamples : undefined;\n\n    return copy;\n  });\n\n  await writeFile(\n    dataPath('vocabulary.json'),\n    `${JSON.stringify(normalized, null, 2)}\\n`\n  );\n}\n\nfunction deriveSummary(content, title) {\n  if (content && typeof content === 'string') {\n    const firstSentenceMatch = content.trim().match(/^(.*?[!.?])( |\\n|$)/);\n    if (firstSentenceMatch && firstSentenceMatch[1]) {\n      return firstSentenceMatch[1].trim();\n    }\n  }\n  return `${title} overview for Bulgarian learners.`;\n}\n\nasync function normalizeGrammar() {\n  const grammarRaw = await readFile(dataPath('grammar.json'), 'utf8');\n  const grammar = JSON.parse(grammarRaw);\n  const usedIds = new Set();\n\n  const normalized = grammar.map((entry, index) => {\n    if (!entry || typeof entry !== 'object') {\n      return entry;\n    }\n    const copy = { ...entry };\n\n    const title =\n      typeof copy.title === 'string' && copy.title.trim().length > 0\n        ? copy.title.trim()\n        : `Grammar Topic ${index + 1}`;\n    copy.title = title;\n\n    const baseId = slugify(copy.id || title, `grammar_${index + 1}`);\n    copy.id = ensureUniqueId(baseId, usedIds);\n\n    const content =\n      typeof copy.content === 'string' && copy.content.trim().length > 0\n        ? copy.content.trim()\n        : (typeof copy.description === 'string' && copy.description.trim().length > 0\n          ? copy.description.trim()\n          : '');\n\n    copy.content = content;\n    copy.summary =\n      typeof copy.summary === 'string' && copy.summary.trim().length > 0\n        ? copy.summary.trim()\n        : deriveSummary(content, title);\n\n    copy.category =\n      typeof copy.category === 'string' && copy.category.trim().length > 0\n        ? copy.category.trim()\n        : copy.category ?? null;\n    copy.level =\n      typeof copy.level === 'string' && copy.level.trim().length > 0\n        ? copy.level.trim()\n        : copy.level ?? null;\n\n    const formattedExamples = formatExamples(copy.examples, {\n      preserveEmpty: true\n    });\n    copy.examples = formattedExamples;\n\n    delete copy.description;\n\n    return copy;\n  });\n\n  await writeFile(\n    dataPath('grammar.json'),\n    `${JSON.stringify(normalized, null, 2)}\\n`\n  );\n}\n\nasync function main() {\n  await normalizeVocabulary();\n  await normalizeGrammar();\n  console.log('Datasets normalized.');\n}\n\nmain().catch((error) => {\n  console.error('Failed to normalize datasets:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/split-vocabulary.ts","messages":[{"ruleId":"unicorn/no-array-reduce","severity":2,"message":"`Array#reduce()` is not allowed","line":228,"column":40,"nodeType":"Identifier","messageId":"no-reduce","endLine":228,"endColumn":46},{"ruleId":"unicorn/no-array-reduce","severity":2,"message":"`Array#reduce()` is not allowed","line":229,"column":41,"nodeType":"Identifier","messageId":"no-reduce","endLine":229,"endColumn":47},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":331,"column":5,"nodeType":"Identifier","messageId":"error/identifier","endLine":331,"endColumn":12},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"module\".","line":331,"column":22,"nodeType":"Identifier","messageId":"error/identifier","endLine":331,"endColumn":28}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * Vocabulary Splitting Script\n * Splits the monolithic vocabulary.json file into modular chunks by level and category\n * for improved performance and lazy loading capabilities.\n * \n * Output structure:\n * data/vocab/\n * ├── A1.json\n * ├── A2.json\n * ├── B1.json\n * ├── B2.json\n * ├── greeting.json\n * ├── travel.json\n * └── ...\n */\n\nimport { readFile, writeFile, mkdir } from 'node:fs/promises';\nimport { existsSync } from 'node:fs';\nimport { join } from 'node:path';\n\ninterface VocabularyEntry {\n  id: string;\n  word: string;\n  translation: string;\n  source_lang: string;\n  target_lang: string;\n  category?: string;\n  level?: string;\n  notes?: string;\n  notes_bg_to_de?: string;\n  notes_de_to_bg?: string;\n  etymology?: string;\n  cultural_note?: string;\n  linguistic_note?: string;\n  difficulty?: number;\n  frequency?: number;\n  examples?: Array<{\n    sentence: string;\n    translation: string;\n    context?: string;\n    note?: string;\n  }>;\n}\n\ninterface SplitResult {\n  file: string;\n  entryCount: number;\n  sizeKB: number;\n  categories: string[];\n}\n\nclass VocabularySplitter {\n  private vocabulary: VocabularyEntry[] = [];\n  private splitResults: SplitResult[] = [];\n  private vocabDir: string;\n  private maxFileSizeKB = 50; // Target maximum file size\n\n  constructor() {\n    this.vocabDir = join(process.cwd(), 'data', 'vocab');\n  }\n\n  async run() {\n    console.log('🔧 Starting vocabulary splitting process...\\n');\n    \n    try {\n      await this.loadVocabulary();\n      await this.createVocabDirectory();\n      await this.splitByLevel();\n      await this.splitByCategory();\n      await this.generateIndex();\n      await this.validateSplitFiles();\n      this.printResults();\n      \n      console.log('✅ Vocabulary splitting completed successfully!');\n    } catch (error) {\n      console.error('❌ Error splitting vocabulary:', error);\n      process.exit(1);\n    }\n  }\n\n  private async loadVocabulary() {\n    const vocabPath = join(process.cwd(), 'data', 'vocabulary.json');\n    console.log(`📖 Loading vocabulary from: ${vocabPath}`);\n    \n    const content = await readFile(vocabPath, 'utf8');\n    this.vocabulary = JSON.parse(content);\n    \n    console.log(`📊 Loaded ${this.vocabulary.length} vocabulary entries`);\n  }\n\n  private async createVocabDirectory() {\n    if (!existsSync(this.vocabDir)) {\n      console.log(`📁 Creating vocabulary directory: ${this.vocabDir}`);\n      await mkdir(this.vocabDir, { recursive: true });\n    }\n  }\n\n  private async splitByLevel() {\n    console.log('\\n📈 Splitting vocabulary by CEFR level...');\n    \n    const levels = ['A1', 'A2', 'B1', 'B2'];\n    \n    for (const level of levels) {\n      const levelEntries = this.vocabulary.filter(entry => entry.level === level);\n      \n      if (levelEntries.length > 0) {\n        const fileName = `${level}.json`;\n        await this.saveSplitFile(fileName, levelEntries, `Level ${level}`);\n      }\n    }\n    \n    // Handle entries without level\n    const noLevelEntries = this.vocabulary.filter(entry => !entry.level || entry.level === '');\n    if (noLevelEntries.length > 0) {\n      await this.saveSplitFile('unleveled.json', noLevelEntries, 'Unleveled entries');\n    }\n  }\n\n  private async splitByCategory() {\n    console.log('\\n📂 Splitting vocabulary by category...');\n    \n    const categories = [...new Set(this.vocabulary.map(entry => entry.category).filter(Boolean))];\n    \n    for (const category of categories) {\n      if (!category) continue;\n      \n      const categoryEntries = this.vocabulary.filter(entry => entry.category === category);\n      \n      // Only create category files if they contain a reasonable number of entries\n      // and won't exceed the size limit\n      if (categoryEntries.length >= 5) {\n        const fileName = `${this.sanitizeFileName(category)}.json`;\n        await this.saveSplitFile(fileName, categoryEntries, `Category \"${category}\"`);\n      }\n    }\n  }\n\n  private async saveSplitFile(fileName: string, entries: VocabularyEntry[], description: string) {\n    const filePath = join(this.vocabDir, fileName);\n    const content = JSON.stringify(entries, null, 2);\n    const sizeKB = Math.round(Buffer.byteLength(content, 'utf8') / 1024);\n    \n    // Check if file would exceed size limit\n    if (sizeKB > this.maxFileSizeKB) {\n      console.log(`⚠️  ${description} would be ${sizeKB}KB (exceeds ${this.maxFileSizeKB}KB limit)`);\n      \n      // Try to split further by sub-categories or other criteria\n      await this.splitLargeCategory(fileName, entries, description);\n      return;\n    }\n    \n    await writeFile(filePath, content);\n    \n    this.splitResults.push({\n      file: fileName,\n      entryCount: entries.length,\n      sizeKB,\n      categories: [...new Set(entries.map(e => e.category).filter(Boolean))] as string[]\n    });\n    \n    console.log(`✅ ${description}: ${entries.length} entries, ${sizeKB}KB`);\n  }\n\n  private async splitLargeCategory(baseFileName: string, entries: VocabularyEntry[], description: string) {\n    // Split large categories by level first\n    const levels = ['A1', 'A2', 'B1', 'B2'];\n    \n    for (const level of levels) {\n      const levelEntries = entries.filter(entry => entry.level === level);\n      \n      if (levelEntries.length > 0) {\n        const fileName = `${baseFileName.replace('.json', '')}-${level}.json`;\n        await this.saveSplitFileDirect(fileName, levelEntries, `${description} (${level})`);\n      }\n    }\n    \n    // Handle remaining entries\n    const remainingEntries = entries.filter(entry => !entry.level || !levels.includes(entry.level));\n    if (remainingEntries.length > 0) {\n      const fileName = `${baseFileName.replace('.json', '')}-other.json`;\n      await this.saveSplitFileDirect(fileName, remainingEntries, `${description} (other)`);\n    }\n  }\n\n  private async saveSplitFileDirect(fileName: string, entries: VocabularyEntry[], description: string) {\n    const filePath = join(this.vocabDir, fileName);\n    const content = JSON.stringify(entries, null, 2);\n    const sizeKB = Math.round(Buffer.byteLength(content, 'utf8') / 1024);\n    \n    await writeFile(filePath, content);\n    \n    this.splitResults.push({\n      file: fileName,\n      entryCount: entries.length,\n      sizeKB,\n      categories: [...new Set(entries.map(e => e.category).filter(Boolean))] as string[]\n    });\n    \n    console.log(`✅ ${description}: ${entries.length} entries, ${sizeKB}KB`);\n  }\n\n  private sanitizeFileName(name: string): string {\n    return name\n      .toLowerCase()\n      .replaceAll(/[^\\da-zßäöü]/g, '-')\n      .replaceAll(/-+/g, '-')\n      .replaceAll(/^-|-$/g, '');\n  }\n\n  private async generateIndex() {\n    console.log('\\n📋 Generating vocabulary index...');\n    \n    const index = {\n      generated: new Date().toISOString(),\n      totalEntries: this.vocabulary.length,\n      splitFiles: this.splitResults.map(result => ({\n        file: result.file,\n        entryCount: result.entryCount,\n        sizeKB: result.sizeKB,\n        categories: result.categories\n      })),\n      summary: {\n        totalFiles: this.splitResults.length,\n        totalSizeKB: this.splitResults.reduce((sum, result) => sum + result.sizeKB, 0),\n        averageSizeKB: Math.round(this.splitResults.reduce((sum, result) => sum + result.sizeKB, 0) / this.splitResults.length),\n        largestFile: this.splitResults.reduce((max, result) => result.sizeKB > max!.sizeKB ? result : max, this.splitResults[0]),\n        smallestFile: this.splitResults.reduce((min, result) => result.sizeKB < min!.sizeKB ? result : min, this.splitResults[0])\n      }\n    };\n    \n    const indexPath = join(this.vocabDir, 'index.json');\n    await writeFile(indexPath, JSON.stringify(index, null, 2));\n    \n    console.log('✅ Vocabulary index generated');\n  }\n\n  private async validateSplitFiles() {\n    console.log('\\n🔍 Validating split files...');\n    \n    let totalEntries = 0;\n    \n    for (const result of this.splitResults) {\n      const filePath = join(this.vocabDir, result.file);\n      const content = await readFile(filePath, 'utf8');\n      const entries: VocabularyEntry[] = JSON.parse(content);\n      \n      totalEntries += entries.length;\n      \n      // Check for duplicate IDs within the same file\n      const fileIds = new Set<string>();\n      for (const entry of entries) {\n        if (fileIds.has(entry.id)) {\n          console.error(`❌ Duplicate ID found within file: ${entry.id} in ${result.file}`);\n          throw new Error(`Duplicate vocabulary ID within file: ${entry.id}`);\n        }\n        fileIds.add(entry.id);\n      }\n      \n      // Validate schema compliance\n      for (const entry of entries) {\n        if (!this.validateEntrySchema(entry)) {\n          console.error(`❌ Invalid entry schema in ${result.file}: ${entry.id}`);\n          throw new Error(`Invalid vocabulary entry schema: ${entry.id}`);\n        }\n      }\n    }\n    \n    // Verify no data loss (note: entries can appear in multiple files, so we expect totalEntries >= vocabulary.length)\n    if (totalEntries < this.vocabulary.length) {\n      console.error(`❌ Data loss detected: expected at least ${this.vocabulary.length}, got ${totalEntries}`);\n      throw new Error('Vocabulary data loss during splitting');\n    }\n    \n    console.log('✅ All split files validated successfully');\n    console.log(`📊 Total entries across all files: ${totalEntries} (entries can appear in multiple files)`);\n  }\n\n  private validateEntrySchema(entry: VocabularyEntry): boolean {\n    // Basic required fields\n    if (!entry.id || typeof entry.id !== 'string') return false;\n    if (!entry.word || typeof entry.word !== 'string') return false;\n    if (!entry.translation || typeof entry.translation !== 'string') return false;\n    if (!entry.source_lang || typeof entry.source_lang !== 'string') return false;\n    if (!entry.target_lang || typeof entry.target_lang !== 'string') return false;\n    \n    // Optional fields type checking\n    if (entry.category && typeof entry.category !== 'string') return false;\n    if (entry.level && typeof entry.level !== 'string') return false;\n    if (entry.difficulty && (typeof entry.difficulty !== 'number' || entry.difficulty < 1 || entry.difficulty > 5)) return false;\n    if (entry.frequency && (typeof entry.frequency !== 'number' || entry.frequency < 0 || entry.frequency > 100)) return false;\n    \n    // Examples validation\n    if (entry.examples && !Array.isArray(entry.examples)) return false;\n    if (entry.examples) {\n      for (const example of entry.examples) {\n        if (!example.sentence || typeof example.sentence !== 'string') return false;\n        if (!example.translation || typeof example.translation !== 'string') return false;\n      }\n    }\n    \n    return true;\n  }\n\n  private printResults() {\n    console.log('\\n📊 Splitting Results Summary:');\n    console.log('='.repeat(50));\n    \n    console.log(`Total vocabulary entries: ${this.vocabulary.length}`);\n    console.log(`Number of split files: ${this.splitResults.length}`);\n    console.log(`Total size of split files: ${this.splitResults.reduce((sum, r) => sum + r.sizeKB, 0)}KB`);\n    console.log(`Average file size: ${Math.round(this.splitResults.reduce((sum, r) => sum + r.sizeKB, 0) / this.splitResults.length)}KB`);\n    \n    console.log('\\n📁 Generated files:');\n    for (const result of this.splitResults) {\n      console.log(`  ${result.file.padEnd(20)} ${result.entryCount.toString().padStart(3)} entries, ${result.sizeKB.toString().padStart(3)}KB`);\n    }\n    \n    const oversizedFiles = this.splitResults.filter(r => r.sizeKB > this.maxFileSizeKB);\n    if (oversizedFiles.length > 0) {\n      console.log('\\n⚠️  Files exceeding size limit:');\n      for (const file of oversizedFiles) {\n        console.log(`  ${file.file}: ${file.sizeKB}KB (limit: ${this.maxFileSizeKB}KB)`);\n      }\n    }\n  }\n}\n\n// Run the splitter\nif (require.main === module) {\n  new VocabularySplitter().run();\n}\n\nexport { VocabularySplitter, VocabularyEntry };","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/test-vocabulary-api.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'validFiles' is assigned a value but never used.","line":45,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":45,"endColumn":19},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":106,"column":5,"nodeType":"Identifier","messageId":"error/identifier","endLine":106,"endColumn":12},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"module\".","line":106,"column":22,"nodeType":"Identifier","messageId":"error/identifier","endLine":106,"endColumn":28},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over an async function `testVocabularyFiles` call.","line":107,"column":3,"nodeType":"CallExpression","messageId":"identifier","endLine":107,"endColumn":24,"suggestions":[{"messageId":"add-await","fix":{"range":[3804,3804],"text":"await "},"data":{"name":"testVocabularyFiles"},"desc":"Insert `await`."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * Test Script for Modular Vocabulary API\n * Tests lazy loading functionality and performance\n */\n\n// Note: This test requires the TypeScript file to be compiled first\n// For now, we'll test the functionality through the existing JavaScript modules\n// that have been updated to use the modular API\n\nconsole.log('🧪 Testing Modular Vocabulary API through updated modules...\\n');\n\n// We'll test by checking if the vocabulary files exist and are accessible\nimport { readFile } from 'node:fs/promises';\nimport { existsSync } from 'node:fs';\nimport { join } from 'node:path';\n\nconst vocabDir = join(process.cwd(), 'data', 'vocab');\n\nasync function testVocabularyFiles() {\n  try {\n    // Test 1: Check if index file exists\n    console.log('📋 Test 1: Checking vocabulary index...');\n    const indexPath = join(vocabDir, 'index.json');\n    if (existsSync(indexPath)) {\n      const indexContent = await readFile(indexPath, 'utf8');\n      const index = JSON.parse(indexContent);\n      console.log(`✅ Index found with ${index.totalEntries} entries across ${index.splitFiles.length} files`);\n    } else {\n      throw new Error('Vocabulary index not found');\n    }\n    \n    // Test 2: Check if key vocabulary files exist\n    console.log('\\n📁 Test 2: Checking key vocabulary files...');\n    const keyFiles = ['A1-A1.json', 'begrüßung.json', 'verben-A1.json'];\n    let validFiles = 0;\n    \n    for (const file of keyFiles) {\n      const filePath = join(vocabDir, file);\n      if (existsSync(filePath)) {\n        const content = await readFile(filePath, 'utf8');\n        const entries = JSON.parse(content);\n        console.log(`✅ ${file}: ${entries.length} entries`);\n        validFiles++;\n      } else {\n        console.log(`❌ ${file}: Not found`);\n      }\n    }\n    \n    // Test 3: Verify data structure\n    console.log('\\n🔍 Test 3: Verifying data structure...');\n    const sampleFile = join(vocabDir, 'begrüßung.json');\n    if (existsSync(sampleFile)) {\n      const content = await readFile(sampleFile, 'utf8');\n      const entries = JSON.parse(content);\n      \n      if (Array.isArray(entries) && entries.length > 0) {\n        const sampleEntry = entries[0];\n        const requiredFields = ['id', 'word', 'translation', 'source_lang', 'target_lang'];\n        const hasAllFields = requiredFields.every(field => field in sampleEntry);\n        \n        if (hasAllFields) {\n          console.log(`✅ Data structure valid: ${requiredFields.join(', ')} fields present`);\n        } else {\n          throw new Error('Missing required fields in vocabulary entry');\n        }\n      } else {\n        throw new Error('Invalid data format in vocabulary file');\n      }\n    }\n    \n    // Test 4: Check file sizes\n    console.log('\\n💾 Test 4: Checking file sizes...');\n    const indexContent2 = await readFile(indexPath, 'utf8');\n    const index = JSON.parse(indexContent2);\n    \n    let smallFiles = 0;\n    let largeFiles = 0;\n    \n    for (const fileInfo of index.splitFiles) {\n      if (fileInfo.sizeKB <= 50) {\n        smallFiles++;\n      } else {\n        largeFiles++;\n      }\n    }\n    \n    console.log(`📊 Files under 50KB: ${smallFiles}`);\n    console.log(`📊 Files over 50KB: ${largeFiles}`);\n    console.log(`📊 Largest file: ${index.summary.largestFile.file} (${index.summary.largestFile.sizeKB}KB)`);\n    \n    console.log('\\n🎉 Basic file structure tests completed successfully!');\n    console.log('\\n💡 Next steps:');\n    console.log('   - Compile TypeScript modules with: npx tsc');\n    console.log('   - Test browser functionality with the updated JavaScript modules');\n    console.log('   - Run performance tests to measure improvements');\n    \n  } catch (error) {\n    console.error('❌ Test failed:', error);\n    process.exit(1);\n  }\n}\n\n// Run the test\nif (require.main === module) {\n  testVocabularyFiles();\n}","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/validate-data.mjs","messages":[{"ruleId":"no-unused-vars","severity":2,"message":"'validateGrammarArray' is defined but never used.","line":126,"column":10,"nodeType":"Identifier","messageId":"unusedVar","endLine":126,"endColumn":30},{"ruleId":"unicorn/prefer-top-level-await","severity":2,"message":"Prefer top-level await over using a promise chain.","line":208,"column":8,"nodeType":"Identifier","messageId":"promise","endLine":208,"endColumn":13}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\nimport { readFile } from 'node:fs/promises';\n\nfunction isString(x) {\n  return typeof x === 'string' && x.trim().length > 0; \n}\nfunction isOptionalString(x) {\n  return x === null || x === undefined || typeof x === 'string'; \n}\nfunction isOptionalNumberIn(x, min, max) {\n  if (x === null || x === undefined) {\n    return true;\n  }\n  const n = Number(x);\n  return Number.isFinite(n) && n >= min && n <= max;\n}\n\nfunction validateExamples(examples, ctx, errs) {\n  if (examples === undefined) {\n    return;\n  }\n  if (!Array.isArray(examples)) {\n    errs.push(`${ctx}: examples must be an array`);\n    return;\n  }\n  for (const [i, ex] of examples.entries()) {\n    if (!ex || typeof ex !== 'object') {\n      errs.push(`${ctx}: examples[${i}] must be an object`);\n      continue;\n    }\n    if (!isString(ex.sentence)) {\n      errs.push(`${ctx}: examples[${i}].sentence is required string`);\n    }\n    if (!isString(ex.translation)) {\n      errs.push(`${ctx}: examples[${i}].translation is required string`);\n    }\n    if (!isOptionalString(ex.context) && !isOptionalString(ex.note)) {\n      // allow either context (vocab) or note (grammar) optionally\n      errs.push(`${ctx}: examples[${i}] optional context/note must be string/null if present`);\n    }\n  }\n}\n\nfunction validateVocabularyArray(arr) {\n  const errs = [];\n  if (!Array.isArray(arr)) {\n    return ['vocabulary.json root must be an array'];\n  }\n  const ids = new Set();\n  for (const [idx, it] of arr.entries()) {\n    const ctx = `vocabulary[${idx}] (id=${it?.id ?? 'n/a'})`;\n    if (!it || typeof it !== 'object') {\n      errs.push(`${ctx}: entry must be object`); continue; \n    }\n    if (!isString(it.id)) {\n      errs.push(`${ctx}: id is required string`);\n    }\n    if (ids.has(it.id)) {\n      errs.push(`${ctx}: id must be unique (duplicate)`);\n    } else {\n      ids.add(it.id);\n    }\n    if (!isString(it.word)) {\n      errs.push(`${ctx}: word is required string`);\n    }\n    if (!isString(it.translation)) {\n      errs.push(`${ctx}: translation is required string`);\n    }\n    if (!isString(it.source_lang)) {\n      errs.push(`${ctx}: source_lang is required string`);\n    }\n    if (!isString(it.target_lang)) {\n      errs.push(`${ctx}: target_lang is required string`);\n    }\n    if (!isOptionalString(it.category)) {\n      errs.push(`${ctx}: category must be string/null if present`);\n    }\n    if (!isOptionalString(it.level)) {\n      errs.push(`${ctx}: level must be string/null if present`);\n    }\n    if (!isOptionalString(it.notes)) {\n      errs.push(`${ctx}: notes must be string/null if present`);\n    }\n    if (!isOptionalString(it.notes_bg_to_de)) {\n      errs.push(`${ctx}: notes_bg_to_de must be string/null if present`);\n    }\n    if (!isOptionalString(it.notes_de_to_bg)) {\n      errs.push(`${ctx}: notes_de_to_bg must be string/null if present`);\n    }\n    if (it.notes_bg_to_de && !/[ЁЄІЇА-яёєіїҐґ]/.test(it.notes_bg_to_de)) {\n      errs.push(`${ctx}: notes_bg_to_de should contain Bulgarian Cyrillic text`);\n    }\n    if (it.notes_de_to_bg && !/[A-Za-zÄÖÜßäöü]/.test(it.notes_de_to_bg)) {\n      errs.push(`${ctx}: notes_de_to_bg should contain German/Latin text`);\n    }\n    if (!isOptionalString(it.etymology)) {\n      errs.push(`${ctx}: etymology must be string/null if present`);\n    }\n    if (!isOptionalString(it.cultural_note)) {\n      errs.push(`${ctx}: cultural_note must be string/null if present`);\n    }\n    if (!isOptionalString(it.linguistic_note)) {\n      errs.push(`${ctx}: linguistic_note must be string/null if present`);\n    }\n    // Warn if directional notes are missing but generic notes exist\n    if (isString(it.notes) && !it.notes_bg_to_de && !it.notes_de_to_bg) {\n      console.warn(`⚠ ${ctx}: has generic notes but missing directional notes (notes_bg_to_de, notes_de_to_bg)`);\n    }\n    if (!isOptionalNumberIn(it.difficulty, 1, 5)) {\n      errs.push(`${ctx}: difficulty must be number 1..5 if present`);\n    }\n    if (!isOptionalNumberIn(it.frequency, 0, 100)) {\n      errs.push(`${ctx}: frequency must be number 0..100 if present`);\n    }\n    if (isString(it.source_lang) && it.source_lang !== 'bg') {\n      errs.push(`${ctx}: source_lang should be 'bg'`);\n    }\n    if (isString(it.target_lang) && it.target_lang !== 'de') {\n      errs.push(`${ctx}: target_lang should be 'de'`);\n    }\n    validateExamples(it.examples, ctx, errs);\n  }\n  return errs;\n}\n\nfunction validateGrammarArray(arr) {\n  const errs = [];\n  if (!Array.isArray(arr)) {\n    return ['grammar.json root must be an array'];\n  }\n  const ids = new Set();\n  for (const [idx, it] of arr.entries()) {\n    const ctx = `grammar[${idx}] (id=${it?.id ?? 'n/a'})`;\n    if (!it || typeof it !== 'object') {\n      errs.push(`${ctx}: entry must be object`); continue; \n    }\n    if (!isString(it.id)) {\n      errs.push(`${ctx}: id is required string`);\n    }\n    if (ids.has(it.id)) {\n      errs.push(`${ctx}: id must be unique (duplicate)`);\n    } else {\n      ids.add(it.id);\n    }\n    if (!isString(it.title)) {\n      errs.push(`${ctx}: title is required string`);\n    }\n    if (!isString(it.summary)) {\n      errs.push(`${ctx}: summary is required string`);\n    }\n    if (!isString(it.content)) {\n      errs.push(`${ctx}: content is required string`);\n    }\n    if (!isOptionalString(it.category)) {\n      errs.push(`${ctx}: category must be string/null if present`);\n    }\n    if (!isOptionalString(it.level)) {\n      errs.push(`${ctx}: level must be string/null if present`);\n    }\n    validateExamples(it.examples, ctx, errs);\n  }\n  return errs;\n}\n\nasync function main() {\n  const vocabPath = 'data/vocabulary.json';\n  const outputs = [];\n\n  // Validate vocabulary.json\n  try {\n    const vocabRaw = await readFile(vocabPath, 'utf8');\n    const vocab = JSON.parse(vocabRaw);\n    const vErrs = validateVocabularyArray(vocab);\n    if (vErrs.length > 0) {\n      outputs.push({ file: vocabPath, ok: false, errors: vErrs });\n    } else {\n      outputs.push({ file: vocabPath, ok: true });\n    }\n  } catch (error) {\n    outputs.push({ file: vocabPath, ok: false, errors: [error.message] });\n  }\n\n  // Grammar is now in Markdown files (content/grammar/*.md)\n  // Grammar structure is validated by:\n  // 1. Hugo's markdown parsing (automatically)\n  // 2. Go CLI tool: ./hugo-bg-de validate (checks MD files exist)\n  console.log('ℹ Grammar content in Markdown format (validated by Go CLI tool)');\n\n  let exitCode = 0;\n  for (const out of outputs) {\n    if (out.ok) {\n      console.log(`✔ ${out.file}: OK`);\n    } else {\n      exitCode = 1;\n      console.error(`✖ ${out.file}: ${out.errors.length} issue(s)`);\n      for (const err of out.errors.slice(0, 50)) {\n        console.error('  -', err);\n      }\n      if (out.errors.length > 50) {\n        console.error(`  ... and ${out.errors.length - 50} more`);\n      }\n    }\n  }\n\n  process.exit(exitCode);\n}\n\nmain().catch(error => {\n  console.error('Validator crashed:', error);\n  process.exit(1);\n});\n","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"/Users/dinz/Coding Projects/BulgariaLearn/BulgarianApp-Fresh/scripts/validate-split-vocabulary.ts","messages":[{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"require\".","line":215,"column":5,"nodeType":"Identifier","messageId":"error/identifier","endLine":215,"endColumn":12},{"ruleId":"unicorn/prefer-module","severity":2,"message":"Do not use \"module\".","line":215,"column":22,"nodeType":"Identifier","messageId":"error/identifier","endLine":215,"endColumn":28}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"#!/usr/bin/env node\n\n/**\n * Validation Script for Split Vocabulary Files\n * Validates data integrity and schema compliance for modular vocabulary chunks\n */\n\nimport { readFile } from 'node:fs/promises';\nimport { existsSync } from 'node:fs';\nimport { join } from 'node:path';\n\ninterface VocabularyEntry {\n  id: string;\n  word: string;\n  translation: string;\n  source_lang: string;\n  target_lang: string;\n  category?: string;\n  level?: string;\n  notes?: string;\n  notes_bg_to_de?: string;\n  notes_de_to_bg?: string;\n  etymology?: string;\n  cultural_note?: string;\n  linguistic_note?: string;\n  difficulty?: number;\n  frequency?: number;\n  examples?: Array<{\n    sentence: string;\n    translation: string;\n    context?: string;\n    note?: string;\n  }>;\n}\n\ninterface ValidationResult {\n  file: string;\n  valid: boolean;\n  errors: string[];\n  entryCount: number;\n  duplicateIds: string[];\n  schemaErrors: number;\n}\n\nclass VocabularyValidator {\n  private vocabDir: string;\n  private results: ValidationResult[] = [];\n  // private allIds: Set<string> = new Set(); // Removed unused variable\n\n  constructor() {\n    this.vocabDir = join(process.cwd(), 'data', 'vocab');\n  }\n\n  async run() {\n    console.log('🔍 Starting vocabulary validation...\\n');\n    \n    try {\n      await this.validateAllFiles();\n      this.printResults();\n      \n      const hasErrors = this.results.some(result => !result.valid);\n      if (hasErrors) {\n        console.error('❌ Validation completed with errors');\n        process.exit(1);\n      } else {\n        console.log('✅ All vocabulary files validated successfully!');\n      }\n    } catch (error) {\n      console.error('❌ Error during validation:', error);\n      process.exit(1);\n    }\n  }\n\n  private async validateAllFiles() {\n    const indexPath = join(this.vocabDir, 'index.json');\n    \n    if (!existsSync(indexPath)) {\n      throw new Error('Vocabulary index not found. Run split-vocabulary.ts first.');\n    }\n\n    const indexContent = await readFile(indexPath, 'utf8');\n    const index = JSON.parse(indexContent);\n\n    for (const fileInfo of index.splitFiles) {\n      await this.validateFile(fileInfo.file);\n    }\n  }\n\n  private async validateFile(fileName: string) {\n    const filePath = join(this.vocabDir, fileName);\n    const result: ValidationResult = {\n      file: fileName,\n      valid: true,\n      errors: [],\n      entryCount: 0,\n      duplicateIds: [],\n      schemaErrors: 0\n    };\n\n    try {\n      const content = await readFile(filePath, 'utf8');\n      const entries: VocabularyEntry[] = JSON.parse(content);\n      \n      result.entryCount = entries.length;\n\n      // Check for duplicate IDs within the file\n      const fileIds = new Set<string>();\n      for (const entry of entries) {\n        if (fileIds.has(entry.id)) {\n          result.duplicateIds.push(entry.id);\n          result.valid = false;\n        }\n        fileIds.add(entry.id);\n      }\n\n      // Validate schema for each entry\n      for (const entry of entries) {\n        if (!this.validateEntrySchema(entry)) {\n          result.schemaErrors++;\n          result.valid = false;\n        }\n      }\n\n      // Check file size (should be under 50KB for optimal performance)\n      const sizeKB = Math.round(Buffer.byteLength(content, 'utf8') / 1024);\n      if (sizeKB > 50) {\n        result.errors.push(`File size ${sizeKB}KB exceeds 50KB limit`);\n      }\n\n      if (result.duplicateIds.length > 0) {\n        result.errors.push(`Duplicate IDs found: ${result.duplicateIds.join(', ')}`);\n      }\n\n      if (result.schemaErrors > 0) {\n        result.errors.push(`${result.schemaErrors} schema validation errors`);\n      }\n\n    } catch (error) {\n      result.valid = false;\n      result.errors.push(`Failed to read/parse file: ${(error as Error).message}`);\n    }\n\n    this.results.push(result);\n  }\n\n  private validateEntrySchema(entry: VocabularyEntry): boolean {\n    // Basic required fields\n    if (!entry.id || typeof entry.id !== 'string') return false;\n    if (!entry.word || typeof entry.word !== 'string') return false;\n    if (!entry.translation || typeof entry.translation !== 'string') return false;\n    if (!entry.source_lang || typeof entry.source_lang !== 'string') return false;\n    if (!entry.target_lang || typeof entry.target_lang !== 'string') return false;\n    \n    // Optional fields type checking\n    if (entry.category && typeof entry.category !== 'string') return false;\n    if (entry.level && typeof entry.level !== 'string') return false;\n    if (entry.difficulty && (typeof entry.difficulty !== 'number' || entry.difficulty < 1 || entry.difficulty > 5)) return false;\n    if (entry.frequency && (typeof entry.frequency !== 'number' || entry.frequency < 0 || entry.frequency > 100)) return false;\n    \n    // Examples validation\n    if (entry.examples && !Array.isArray(entry.examples)) return false;\n    if (entry.examples) {\n      for (const example of entry.examples) {\n        if (!example.sentence || typeof example.sentence !== 'string') return false;\n        if (!example.translation || typeof example.translation !== 'string') return false;\n      }\n    }\n    \n    return true;\n  }\n\n  private printResults() {\n    console.log('📊 Validation Results Summary:');\n    console.log('='.repeat(60));\n    \n    const totalFiles = this.results.length;\n    const validFiles = this.results.filter(r => r.valid).length;\n    const totalEntries = this.results.reduce((sum, r) => sum + r.entryCount, 0);\n    const totalErrors = this.results.reduce((sum, r) => sum + r.errors.length, 0);\n    \n    console.log(`Total files: ${totalFiles}`);\n    console.log(`Valid files: ${validFiles}`);\n    console.log(`Files with errors: ${totalFiles - validFiles}`);\n    console.log(`Total vocabulary entries: ${totalEntries}`);\n    console.log(`Total validation errors: ${totalErrors}`);\n    \n    console.log('\\n📁 File Details:');\n    for (const result of this.results) {\n      const status = result.valid ? '✅' : '❌';\n      console.log(`${status} ${result.file.padEnd(25)} ${result.entryCount.toString().padStart(3)} entries`);\n      \n      if (!result.valid) {\n        for (const error of result.errors) {\n          console.log(`   └─ ${error}`);\n        }\n      }\n    }\n    \n    // Performance analysis\n    const oversizedFiles = this.results.filter(r => \n      r.errors.some(e => e.includes('exceeds 50KB limit'))\n    );\n    \n    if (oversizedFiles.length > 0) {\n      console.log('\\n⚠️  Performance Warnings:');\n      for (const file of oversizedFiles) {\n        const sizeError = file.errors.find(e => e.includes('KB limit'));\n        console.log(`   ${file.file}: ${sizeError}`);\n      }\n    }\n  }\n}\n\n// Run the validator\nif (require.main === module) {\n  new VocabularyValidator().run();\n}\n\nexport { VocabularyValidator };","usedDeprecatedRules":[{"ruleId":"brace-style","replacedBy":[]},{"ruleId":"quotes","replacedBy":[]},{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]},{"ruleId":"no-multiple-empty-lines","replacedBy":[]},{"ruleId":"indent","replacedBy":[]},{"ruleId":"semi","replacedBy":[]},{"ruleId":"comma-dangle","replacedBy":[]},{"ruleId":"object-curly-spacing","replacedBy":[]},{"ruleId":"arrow-spacing","replacedBy":[]}]}]
