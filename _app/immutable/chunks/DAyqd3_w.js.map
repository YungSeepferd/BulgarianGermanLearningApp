{"version":3,"file":"DAyqd3_w.js","sources":["../../../../../../src/lib/services/localization.ts"],"sourcesContent":["/**\n * Localization Service for bilingual support\n *\n * This service provides translation functionality for the application,\n * supporting both German and Bulgarian languages.\n */\n\nimport { base } from '$app/paths';\nimport { appState } from '../state/app-state';\nimport { browser } from '$app/environment';\n\n// Define the structure of our translation files\n// type TranslationValue = string | { [key: string]: TranslationValue };\n\n// Define the structure for our translations\ninterface Translations {\n    navigation: {\n      dashboard: string;\n      vocabulary: string;\n      grammar: string;\n      practice: string;\n      learn: string;\n      home: string;\n      app_name: string;\n      user_settings: string;\n    };\n    common: {\n        check_answer: string;\n        next_word: string;\n        show_examples: string;\n        hide_examples: string;\n        retry: string;\n        cancel: string;\n        generate_lesson: string;\n        correct: string;\n        streak: string;\n        accuracy: string;\n        avg_time: string;\n        favorite: string;\n        favorited: string;\n        practice_this: string;\n        search: string;\n        loading: string;\n        error_loading: string;\n        try_again: string;\n        reload_page: string;\n    };\n    feedback: {\n        correct: string;\n        incorrect: string;\n        your_answer: string;\n    };\n    sections: {\n        learning_objectives: string;\n        vocabulary: string;\n        practice_exercises: string;\n        recommended_for_practice: string;\n    };\n    directions: {\n        de_to_bg: string;\n        bg_to_de: string;\n    };\n    search: {\n        no_results: string;\n        no_results_hint: string;\n        found_words: string;\n        found_word: string;\n        search_placeholder: string;\n        search_vocabulary: string;\n    };\n    practice: {\n        tandem_learning: string;\n        practice_mode: string;\n        search_mode: string;\n        quick_practice: string;\n        type_answer: string;\n        response_time: string;\n    };\n    lesson: {\n        example: string;\n        examples: string;\n    };\n    dashboard: {\n        title: string;\n        total_vocabulary: string;\n        favorited: string;\n        recent_searches: string;\n    };\n    languages: {\n        german: string;\n        bulgarian: string;\n    }\n}\n\n// Current language state\nlet _currentLanguage: 'de' | 'bg' = 'de';\nlet translations: Translations = {} as Translations;\nlet _isLoading = true;\n\n// Create a reactive store for translation changes\nconst translationChangeListeners: (() => void)[] = [];\n\n// Event system for language changes\ntype LanguageChangeListener = (language: 'de' | 'bg') => void;\nconst languageChangeListeners: LanguageChangeListener[] = [];\n\n/**\n * LocalizationService class for handling translations and language changes\n */\nexport class LocalizationService {\n    /**\n     * Check if translations are currently loading\n     */\n    static isLoading(): boolean {\n        return _isLoading;\n    }\n\n    /**\n     * Notify all listeners that translations have changed\n     */\n    private static notifyTranslationChange(): void {\n        for (const listener of translationChangeListeners) {\n            try {\n                listener();\n            } catch (error) {\n                console.error('Error in translation change listener:', error);\n            }\n        }\n    }\n    /**\n     * Initialize the localization service\n     */\n    static async init(): Promise<void> {\n        if (browser) {\n            // Determine the current language based on app state\n            this.updateCurrentLanguage();\n            this.loadTranslations();\n\n            // Set up language change listener\n            this.onLanguageChange(() => {\n                this.updateCurrentLanguage();\n                this.loadTranslations();\n            });\n        }\n    }\n\n    /**\n     * Update the current language based on app state\n     */\n    private static updateCurrentLanguage(): void {\n        // Default to German\n        _currentLanguage = 'de';\n\n        // If language mode is BG_DE, use Bulgarian\n        if (appState.languageMode === 'BG_DE') {\n            _currentLanguage = 'bg';\n        }\n    }\n\n    /**\n     * Load translations for the current language\n     */\n    private static async loadTranslations(): Promise<void> {\n        _isLoading = true;\n        try {\n            const lang = _currentLanguage;\n            const response = await fetch(`${base}/translations/${lang}.json`);\n            if (!response.ok) {\n                throw new Error(`Failed to load translations for ${lang}`);\n            }\n            const loadedTranslations = await response.json();\n            console.log('Loaded translations:', JSON.stringify(loadedTranslations, null, 2));\n            translations = loadedTranslations;\n            this.notifyTranslationChange(); // Notify that translations have changed\n        } catch (error) {\n            console.error('Failed to load translations:', error);\n            // Fallback to German if loading fails\n            _currentLanguage = 'de';\n            try {\n                const response = await fetch(`${base}/translations/de.json`);\n                if (response.ok) {\n                    translations = await response.json();\n                    this.notifyTranslationChange(); // Notify that translations have changed\n                }\n            } catch (fallbackError) {\n                console.error('Failed to load fallback translations:', fallbackError);\n            }\n        } finally {\n            _isLoading = false;\n            this.notifyTranslationChange(); // Notify that loading state has changed\n        }\n    }\n\n    /**\n     * Get the current language\n     */\n    static getCurrentLanguage(): 'de' | 'bg' {\n        return _currentLanguage;\n    }\n\n    /**\n     * Get a translation for a specific key\n     * @param key The translation key in dot notation (e.g., 'common.check_answer')\n     * @param params Optional parameters for dynamic values\n     */\n    static t(key: string, params?: Record<string, string>): string {\n        try {\n            // If translations are still loading, return the key with loading indicator\n            if (_isLoading) {\n                return ''; // Return empty string during loading\n            }\n\n            // If no translations are loaded, return the key as fallback\n            if (!translations || Object.keys(translations).length === 0) {\n                console.warn(`Translation key '${key}' not available - no translations loaded`);\n                return key;\n            }\n\n            // Split the key by dots to navigate the nested structure\n            const keys = key.split('.');\n            let value: any = translations;\n\n            for (const k of keys) {\n                if (value && typeof value === 'object' && k in value) {\n                    value = value[k];\n                } else {\n                    console.warn(`Translation key '${key}' not found`);\n                    return key; // Return the key itself as fallback\n                }\n            }\n\n            if (typeof value === 'string') {\n                // Handle parameter substitution\n                if (params) {\n                    let result = value;\n                    for (const [paramKey, paramValue] of Object.entries(params)) {\n                        result = result.replace(`{${paramKey}}`, paramValue);\n                    }\n                    return result;\n                }\n                return value;\n            }\n\n            console.warn(`Translation key '${key}' is not a string`);\n            return key; // Return the key itself as fallback\n        } catch (error) {\n            console.error(`Error getting translation for key '${key}':`, error);\n            return key; // Return the key itself as fallback\n        }\n    }\n\n    /**\n     * Get the current direction text based on language mode\n     */\n    static getDirectionText(): string {\n        return appState.languageMode === 'DE_BG'\n            ? this.t('directions.de_to_bg')\n            : this.t('directions.bg_to_de');\n    }\n\n    /**\n     * Get the opposite direction text\n     */\n    static getOppositeDirectionText(): string {\n        return appState.languageMode === 'DE_BG'\n            ? this.t('directions.bg_to_de')\n            : this.t('directions.de_to_bg');\n    }\n\n    /**\n     * Register a listener for language changes\n     * @param listener The function to call when language changes\n     */\n    static onLanguageChange(listener: LanguageChangeListener): void {\n        languageChangeListeners.push(listener);\n    }\n\n    /**\n     * Remove a language change listener\n     * @param listener The function to remove\n     */\n    static offLanguageChange(listener: LanguageChangeListener): void {\n        const index = languageChangeListeners.indexOf(listener);\n        if (index !== -1) {\n            languageChangeListeners.splice(index, 1);\n        }\n    }\n\n    /**\n     * Notify all listeners that the language has changed\n     */\n    static notifyLanguageChange(): void {\n        for (const listener of languageChangeListeners) {\n            try {\n                listener(_currentLanguage);\n            } catch (error) {\n                console.error('Error in language change listener:', error);\n            }\n        }\n        this.notifyTranslationChange(); // Also notify about translation changes\n    }\n\n    /**\n     * Get the current language code for HTML lang attribute\n     */\n    static getHtmlLang(): string {\n        return _currentLanguage;\n    }\n}\n\n// Initialize the service when the module is loaded\nif (browser) {\n    LocalizationService.init();\n}\n\n// Export a reactive version of the translation function\nexport function t(key: string, params?: Record<string, string>): string {\n    return LocalizationService.t(key, params);\n}\n\n// Export a function to check loading state\nexport function isTranslationsLoading(): boolean {\n    return _isLoading;\n}\n\n/**\n * Register a listener for translation changes\n * @param listener The function to call when translations change\n */\nexport function onTranslationsChange(listener: () => void): void {\n    translationChangeListeners.push(listener);\n}\n\n/**\n * Remove a translation change listener\n * @param listener The function to remove\n */\nexport function offTranslationsChange(listener: () => void): void {\n    const index = translationChangeListeners.indexOf(listener);\n    if (index !== -1) {\n        translationChangeListeners.splice(index, 1);\n    }\n}\n\n// Export a reactive version of the current language\n// Export a reactive version of the current language\nexport function getCurrentLanguage(): 'de' | 'bg' {\n    return LocalizationService.getCurrentLanguage();\n}"],"names":["_currentLanguage","translations","_isLoading","translationChangeListeners","languageChangeListeners","LocalizationService","isLoading","notifyTranslationChange","listener","error","console","init","this","updateCurrentLanguage","loadTranslations","onLanguageChange","appState","languageMode","lang","response","fetch","base","ok","Error","loadedTranslations","json","log","JSON","stringify","fallbackError","getCurrentLanguage","t","key","params","Object","keys","length","warn","split","value","k","result","paramKey","paramValue","entries","replace","getDirectionText","getOppositeDirectionText","push","offLanguageChange","index","indexOf","splice","notifyLanguageChange","getHtmlLang","isTranslationsLoading","onTranslationsChange","offTranslationsChange"],"mappings":"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"}