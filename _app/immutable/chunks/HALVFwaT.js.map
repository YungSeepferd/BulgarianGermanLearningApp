{"version":3,"file":"HALVFwaT.js","sources":["../../../../../../node_modules/.pnpm/svelte@5.45.8/node_modules/svelte/src/internal/client/dom/blocks/each.js","../../../../../../node_modules/.pnpm/svelte@5.45.8/node_modules/svelte/src/internal/client/dom/elements/attachments.js","../../../../../../node_modules/.pnpm/svelte@5.45.8/node_modules/svelte/src/internal/shared/attributes.js","../../../../../../node_modules/.pnpm/svelte@5.45.8/node_modules/svelte/src/internal/client/dom/elements/class.js","../../../../../../node_modules/.pnpm/svelte@5.45.8/node_modules/svelte/src/internal/client/dom/elements/style.js","../../../../../../node_modules/.pnpm/svelte@5.45.8/node_modules/svelte/src/internal/client/dom/elements/bindings/select.js","../../../../../../node_modules/.pnpm/svelte@5.45.8/node_modules/svelte/src/internal/client/dom/elements/attributes.js"],"sourcesContent":["/** @import { EachItem, EachOutroGroup, EachState, Effect, EffectNodes, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\n/** @import { Batch } from '../../reactivity/batch.js'; */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tread_hydration_instruction,\n\tskip_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling,\n\tshould_defer_append\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { COMMENT_NODE, EFFECT_OFFSCREEN, INERT } from '#client/constants';\nimport { queue_micro_task } from '../task.js';\nimport { get } from '../../runtime.js';\nimport { DEV } from 'esm-env';\nimport { derived_safe_equal } from '../../reactivity/deriveds.js';\nimport { current_batch } from '../../reactivity/batch.js';\n\n// When making substantive changes to this file, validate them with the each block stress test:\n// https://svelte.dev/playground/1972b2cf46564476ad8c8c6405b23b7b\n// This test also exists in this repo, as `packages/svelte/tests/manual/each-stress-test`\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {Effect[]} to_destroy\n * @param {null | Node} controlled_anchor\n */\nfunction pause_effects(state, to_destroy, controlled_anchor) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = to_destroy.length;\n\n\t/** @type {EachOutroGroup} */\n\tvar group;\n\tvar remaining = to_destroy.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tlet effect = to_destroy[i];\n\n\t\tpause_effect(\n\t\t\teffect,\n\t\t\t() => {\n\t\t\t\tif (group) {\n\t\t\t\t\tgroup.pending.delete(effect);\n\t\t\t\t\tgroup.done.add(effect);\n\n\t\t\t\t\tif (group.pending.size === 0) {\n\t\t\t\t\t\tvar groups = /** @type {Set<EachOutroGroup>} */ (state.outrogroups);\n\n\t\t\t\t\t\tdestroy_effects(array_from(group.done));\n\t\t\t\t\t\tgroups.delete(group);\n\n\t\t\t\t\t\tif (groups.size === 0) {\n\t\t\t\t\t\t\tstate.outrogroups = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tremaining -= 1;\n\t\t\t\t}\n\t\t\t},\n\t\t\tfalse\n\t\t);\n\t}\n\n\tif (remaining === 0) {\n\t\t// If we're in a controlled each block (i.e. the block is the only child of an\n\t\t// element), and we are removing all items, _and_ there are no out transitions,\n\t\t// we can use the fast path — emptying the element and replacing the anchor\n\t\tvar fast_path = transitions.length === 0 && controlled_anchor !== null;\n\n\t\tif (fast_path) {\n\t\t\tvar anchor = /** @type {Element} */ (controlled_anchor);\n\t\t\tvar parent_node = /** @type {Element} */ (anchor.parentNode);\n\n\t\t\tclear_text_content(parent_node);\n\t\t\tparent_node.append(anchor);\n\n\t\t\tstate.items.clear();\n\t\t}\n\n\t\tdestroy_effects(to_destroy, !fast_path);\n\t} else {\n\t\tgroup = {\n\t\t\tpending: new Set(to_destroy),\n\t\t\tdone: new Set()\n\t\t};\n\n\t\t(state.outrogroups ??= new Set()).add(group);\n\t}\n}\n\n/**\n * @param {Effect[]} to_destroy\n * @param {boolean} remove_dom\n */\nfunction destroy_effects(to_destroy, remove_dom = true) {\n\t// TODO only destroy effects if no pending batch needs them. otherwise,\n\t// just re-add the `EFFECT_OFFSCREEN` flag\n\tfor (var i = 0; i < to_destroy.length; i++) {\n\t\tdestroy_effect(to_destroy[i], remove_dom);\n\t}\n}\n\n/** @type {TemplateNode} */\nvar offscreen_anchor;\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {Map<any, EachItem>} */\n\tvar items = new Map();\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(get_first_child(parent_node))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\t// TODO: ideally we could use derived for runes mode but because of the ability\n\t// to use a store which can be mutated, we can't do that here as mutating a store\n\t// will still result in the collection array being the same from the store\n\tvar each_array = derived_safe_equal(() => {\n\t\tvar collection = get_collection();\n\n\t\treturn is_array(collection) ? collection : collection == null ? [] : array_from(collection);\n\t});\n\n\t/** @type {V[]} */\n\tvar array;\n\n\tvar first_run = true;\n\n\tfunction commit() {\n\t\tstate.fallback = fallback;\n\t\treconcile(state, array, anchor, flags, get_key);\n\n\t\tif (fallback !== null) {\n\t\t\tif (array.length === 0) {\n\t\t\t\tif ((fallback.f & EFFECT_OFFSCREEN) === 0) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback.f ^= EFFECT_OFFSCREEN;\n\t\t\t\t\tmove(fallback, null, anchor);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\t// TODO only null out if no pending batch needs it,\n\t\t\t\t\t// otherwise re-add `fallback.fragment` and move the\n\t\t\t\t\t// effect into it\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tvar effect = block(() => {\n\t\tarray = /** @type {V[]} */ (get(each_array));\n\t\tvar length = array.length;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch — remove the server-rendered DOM and start over\n\t\t\t\tanchor = skip_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\tvar keys = new Set();\n\t\tvar batch = /** @type {Batch} */ (current_batch);\n\t\tvar defer = should_defer_append();\n\n\t\tfor (var index = 0; index < length; index += 1) {\n\t\t\tif (\n\t\t\t\thydrating &&\n\t\t\t\thydrate_node.nodeType === COMMENT_NODE &&\n\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t) {\n\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\tmismatch = true;\n\t\t\t\tset_hydrating(false);\n\t\t\t}\n\n\t\t\tvar value = array[index];\n\t\t\tvar key = get_key(value, index);\n\n\t\t\tvar item = first_run ? null : items.get(key);\n\n\t\t\tif (item) {\n\t\t\t\t// update before reconciliation, to trigger any async updates\n\t\t\t\tif (item.v) internal_set(item.v, value);\n\t\t\t\tif (item.i) internal_set(item.i, index);\n\n\t\t\t\tif (defer) {\n\t\t\t\t\tbatch.skipped_effects.delete(item.e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\titem = create_item(\n\t\t\t\t\titems,\n\t\t\t\t\tfirst_run ? anchor : (offscreen_anchor ??= create_text()),\n\t\t\t\t\tvalue,\n\t\t\t\t\tkey,\n\t\t\t\t\tindex,\n\t\t\t\t\trender_fn,\n\t\t\t\t\tflags,\n\t\t\t\t\tget_collection\n\t\t\t\t);\n\n\t\t\t\tif (!first_run) {\n\t\t\t\t\titem.e.f |= EFFECT_OFFSCREEN;\n\t\t\t\t}\n\n\t\t\t\titems.set(key, item);\n\t\t\t}\n\n\t\t\tkeys.add(key);\n\t\t}\n\n\t\tif (length === 0 && fallback_fn && !fallback) {\n\t\t\tif (first_run) {\n\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t} else {\n\t\t\t\tfallback = branch(() => fallback_fn((offscreen_anchor ??= create_text())));\n\t\t\t\tfallback.f |= EFFECT_OFFSCREEN;\n\t\t\t}\n\t\t}\n\n\t\t// remove excess nodes\n\t\tif (hydrating && length > 0) {\n\t\t\tset_hydrate_node(skip_nodes());\n\t\t}\n\n\t\tif (!first_run) {\n\t\t\tif (defer) {\n\t\t\t\tfor (const [key, item] of items) {\n\t\t\t\t\tif (!keys.has(key)) {\n\t\t\t\t\t\tbatch.skipped_effects.add(item.e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbatch.oncommit(commit);\n\t\t\t\tbatch.ondiscard(() => {\n\t\t\t\t\t// TODO presumably we need to do something here?\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcommit();\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget(each_array);\n\t});\n\n\t/** @type {EachState} */\n\tvar state = { effect, flags, items, outrogroups: null, fallback };\n\n\tfirst_run = false;\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {EachState} state\n * @param {Array<V>} array\n * @param {Element | Comment | Text} anchor\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @returns {void}\n */\nfunction reconcile(state, array, anchor, flags, get_key) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar current = state.effect.first;\n\n\t/** @type {undefined | Set<Effect>} */\n\tvar seen;\n\n\t/** @type {Effect | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<Effect>} */\n\tvar to_animate;\n\n\t/** @type {Effect[]} */\n\tvar matched = [];\n\n\t/** @type {Effect[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {Effect | undefined} */\n\tvar effect;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\teffect = /** @type {EachItem} */ (items.get(key)).e;\n\n\t\t\t// offscreen == coming in now, no animation in that case,\n\t\t\t// else this would happen https://github.com/sveltejs/svelte/issues/17181\n\t\t\tif ((effect.f & EFFECT_OFFSCREEN) === 0) {\n\t\t\t\teffect.nodes?.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(effect);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\n\t\teffect = /** @type {EachItem} */ (items.get(key)).e;\n\n\t\tif (state.outrogroups !== null) {\n\t\t\tfor (const group of state.outrogroups) {\n\t\t\t\tgroup.pending.delete(effect);\n\t\t\t\tgroup.done.delete(effect);\n\t\t\t}\n\t\t}\n\n\t\tif ((effect.f & EFFECT_OFFSCREEN) !== 0) {\n\t\t\teffect.f ^= EFFECT_OFFSCREEN;\n\n\t\t\tif (effect === current) {\n\t\t\t\tmove(effect, null, anchor);\n\t\t\t} else {\n\t\t\t\tvar next = prev ? prev.next : current;\n\n\t\t\t\tif (effect === state.effect.last) {\n\t\t\t\t\tstate.effect.last = effect.prev;\n\t\t\t\t}\n\n\t\t\t\tif (effect.prev) effect.prev.next = effect.next;\n\t\t\t\tif (effect.next) effect.next.prev = effect.prev;\n\t\t\t\tlink(state, prev, effect);\n\t\t\t\tlink(state, effect, next);\n\n\t\t\t\tmove(effect, next, anchor);\n\t\t\t\tprev = effect;\n\n\t\t\t\tmatched = [];\n\t\t\t\tstashed = [];\n\n\t\t\t\tcurrent = prev.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif ((effect.f & INERT) !== 0) {\n\t\t\tresume_effect(effect);\n\t\t\tif (is_animated) {\n\t\t\t\teffect.nodes?.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(effect);\n\t\t\t}\n\t\t}\n\n\t\tif (effect !== current) {\n\t\t\tif (seen !== undefined && seen.has(effect)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(effect);\n\t\t\t\t\tmove(effect, current, anchor);\n\n\t\t\t\t\tlink(state, effect.prev, effect.next);\n\t\t\t\t\tlink(state, effect, prev === null ? state.effect.first : prev.next);\n\t\t\t\t\tlink(state, prev, effect);\n\n\t\t\t\t\tprev = effect;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current !== effect) {\n\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif ((effect.f & EFFECT_OFFSCREEN) === 0) {\n\t\t\tmatched.push(effect);\n\t\t}\n\n\t\tprev = effect;\n\t\tcurrent = effect.next;\n\t}\n\n\tif (state.outrogroups !== null) {\n\t\tfor (const group of state.outrogroups) {\n\t\t\tif (group.pending.size === 0) {\n\t\t\t\tdestroy_effects(array_from(group.done));\n\t\t\t\tstate.outrogroups?.delete(group);\n\t\t\t}\n\t\t}\n\n\t\tif (state.outrogroups.size === 0) {\n\t\t\tstate.outrogroups = null;\n\t\t}\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\t/** @type {Effect[]} */\n\t\tvar to_destroy = [];\n\n\t\tif (seen !== undefined) {\n\t\t\tfor (effect of seen) {\n\t\t\t\tif ((effect.f & INERT) === 0) {\n\t\t\t\t\tto_destroy.push(effect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (current !== null) {\n\t\t\t// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif ((current.f & INERT) === 0 && current !== state.fallback) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].nodes?.a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].nodes?.a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (effect of to_animate) {\n\t\t\t\teffect.nodes?.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @template V\n * @param {Map<any, EachItem>} items\n * @param {Node} anchor\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @returns {EachItem}\n */\nfunction create_item(items, anchor, value, key, index, render_fn, flags, get_collection) {\n\tvar v =\n\t\t(flags & EACH_ITEM_REACTIVE) !== 0\n\t\t\t? (flags & EACH_ITEM_IMMUTABLE) === 0\n\t\t\t\t? mutable_source(value, false, false)\n\t\t\t\t: source(value)\n\t\t\t: null;\n\n\tvar i = (flags & EACH_INDEX_REACTIVE) !== 0 ? source(index) : null;\n\n\tif (DEV && v) {\n\t\t// For tracing purposes, we need to link the source signal we create with the\n\t\t// collection + index so that tracing works as intended\n\t\tv.trace = () => {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\t\t\tget_collection()[i?.v ?? index];\n\t\t};\n\t}\n\n\treturn {\n\t\tv,\n\t\ti,\n\t\te: branch(() => {\n\t\t\trender_fn(anchor, v ?? value, i ?? index, get_collection);\n\n\t\t\treturn () => {\n\t\t\t\titems.delete(key);\n\t\t\t};\n\t\t})\n\t};\n}\n\n/**\n * @param {Effect} effect\n * @param {Effect | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(effect, next, anchor) {\n\tif (!effect.nodes) return;\n\n\tvar node = effect.nodes.start;\n\tvar end = effect.nodes.end;\n\n\tvar dest =\n\t\tnext && (next.f & EFFECT_OFFSCREEN) === 0\n\t\t\t? /** @type {EffectNodes} */ (next.nodes).start\n\t\t\t: anchor;\n\n\twhile (node !== null) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\n\t\tif (node === end) {\n\t\t\treturn;\n\t\t}\n\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {Effect | null} prev\n * @param {Effect | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.effect.first = next;\n\t} else {\n\t\tprev.next = next;\n\t}\n\n\tif (next === null) {\n\t\tstate.effect.last = prev;\n\t} else {\n\t\tnext.prev = prev;\n\t}\n}\n","/** @import { Effect } from '#client' */\nimport { branch, effect, destroy_effect, managed } from '../../reactivity/effects.js';\n\n// TODO in 6.0 or 7.0, when we remove legacy mode, we can simplify this by\n// getting rid of the block/branch stuff and just letting the effect rip.\n// see https://github.com/sveltejs/svelte/pull/15962\n\n/**\n * @param {Element} node\n * @param {() => (node: Element) => void} get_fn\n */\nexport function attach(node, get_fn) {\n\t/** @type {false | undefined | ((node: Element) => void)} */\n\tvar fn = undefined;\n\n\t/** @type {Effect | null} */\n\tvar e;\n\n\tmanaged(() => {\n\t\tif (fn !== (fn = get_fn())) {\n\t\t\tif (e) {\n\t\t\t\tdestroy_effect(e);\n\t\t\t\te = null;\n\t\t\t}\n\n\t\t\tif (fn) {\n\t\t\t\te = branch(() => {\n\t\t\t\t\teffect(() => /** @type {(node: Element) => void} */ (fn)(node));\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n}\n","import { escape_html } from '../../escaping.js';\nimport { clsx as _clsx } from 'clsx';\n\n/**\n * `<div translate={false}>` should be rendered as `<div translate=\"no\">` and _not_\n * `<div translate=\"false\">`, which is equivalent to `<div translate=\"yes\">`. There\n * may be other odd cases that need to be added to this list in future\n * @type {Record<string, Map<any, string>>}\n */\nconst replacements = {\n\ttranslate: new Map([\n\t\t[true, 'yes'],\n\t\t[false, 'no']\n\t])\n};\n\n/**\n * @template V\n * @param {string} name\n * @param {V} value\n * @param {boolean} [is_boolean]\n * @returns {string}\n */\nexport function attr(name, value, is_boolean = false) {\n\t// attribute hidden for values other than \"until-found\" behaves like a boolean attribute\n\tif (name === 'hidden' && value !== 'until-found') {\n\t\tis_boolean = true;\n\t}\n\tif (value == null || (!value && is_boolean)) return '';\n\tconst normalized = (name in replacements && replacements[name].get(value)) || value;\n\tconst assignment = is_boolean ? '' : `=\"${escape_html(normalized, true)}\"`;\n\treturn ` ${name}${assignment}`;\n}\n\n/**\n * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.\n * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)\n * @param  {any} value\n */\nexport function clsx(value) {\n\tif (typeof value === 'object') {\n\t\treturn _clsx(value);\n\t} else {\n\t\treturn value ?? '';\n\t}\n}\n\nconst whitespace = [...' \\t\\n\\r\\f\\u00a0\\u000b\\ufeff'];\n\n/**\n * @param {any} value\n * @param {string | null} [hash]\n * @param {Record<string, boolean>} [directives]\n * @returns {string | null}\n */\nexport function to_class(value, hash, directives) {\n\tvar classname = value == null ? '' : '' + value;\n\n\tif (hash) {\n\t\tclassname = classname ? classname + ' ' + hash : hash;\n\t}\n\n\tif (directives) {\n\t\tfor (var key in directives) {\n\t\t\tif (directives[key]) {\n\t\t\t\tclassname = classname ? classname + ' ' + key : key;\n\t\t\t} else if (classname.length) {\n\t\t\t\tvar len = key.length;\n\t\t\t\tvar a = 0;\n\n\t\t\t\twhile ((a = classname.indexOf(key, a)) >= 0) {\n\t\t\t\t\tvar b = a + len;\n\n\t\t\t\t\tif (\n\t\t\t\t\t\t(a === 0 || whitespace.includes(classname[a - 1])) &&\n\t\t\t\t\t\t(b === classname.length || whitespace.includes(classname[b]))\n\t\t\t\t\t) {\n\t\t\t\t\t\tclassname = (a === 0 ? '' : classname.substring(0, a)) + classname.substring(b + 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ta = b;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn classname === '' ? null : classname;\n}\n\n/**\n *\n * @param {Record<string,any>} styles\n * @param {boolean} important\n */\nfunction append_styles(styles, important = false) {\n\tvar separator = important ? ' !important;' : ';';\n\tvar css = '';\n\n\tfor (var key in styles) {\n\t\tvar value = styles[key];\n\t\tif (value != null && value !== '') {\n\t\t\tcss += ' ' + key + ': ' + value + separator;\n\t\t}\n\t}\n\n\treturn css;\n}\n\n/**\n * @param {string} name\n * @returns {string}\n */\nfunction to_css_name(name) {\n\tif (name[0] !== '-' || name[1] !== '-') {\n\t\treturn name.toLowerCase();\n\t}\n\treturn name;\n}\n\n/**\n * @param {any} value\n * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [styles]\n * @returns {string | null}\n */\nexport function to_style(value, styles) {\n\tif (styles) {\n\t\tvar new_style = '';\n\n\t\t/** @type {Record<string,any> | undefined} */\n\t\tvar normal_styles;\n\n\t\t/** @type {Record<string,any> | undefined} */\n\t\tvar important_styles;\n\n\t\tif (Array.isArray(styles)) {\n\t\t\tnormal_styles = styles[0];\n\t\t\timportant_styles = styles[1];\n\t\t} else {\n\t\t\tnormal_styles = styles;\n\t\t}\n\n\t\tif (value) {\n\t\t\tvalue = String(value)\n\t\t\t\t.replaceAll(/\\s*\\/\\*.*?\\*\\/\\s*/g, '')\n\t\t\t\t.trim();\n\n\t\t\t/** @type {boolean | '\"' | \"'\"} */\n\t\t\tvar in_str = false;\n\t\t\tvar in_apo = 0;\n\t\t\tvar in_comment = false;\n\n\t\t\tvar reserved_names = [];\n\n\t\t\tif (normal_styles) {\n\t\t\t\treserved_names.push(...Object.keys(normal_styles).map(to_css_name));\n\t\t\t}\n\t\t\tif (important_styles) {\n\t\t\t\treserved_names.push(...Object.keys(important_styles).map(to_css_name));\n\t\t\t}\n\n\t\t\tvar start_index = 0;\n\t\t\tvar name_index = -1;\n\n\t\t\tconst len = value.length;\n\t\t\tfor (var i = 0; i < len; i++) {\n\t\t\t\tvar c = value[i];\n\n\t\t\t\tif (in_comment) {\n\t\t\t\t\tif (c === '/' && value[i - 1] === '*') {\n\t\t\t\t\t\tin_comment = false;\n\t\t\t\t\t}\n\t\t\t\t} else if (in_str) {\n\t\t\t\t\tif (in_str === c) {\n\t\t\t\t\t\tin_str = false;\n\t\t\t\t\t}\n\t\t\t\t} else if (c === '/' && value[i + 1] === '*') {\n\t\t\t\t\tin_comment = true;\n\t\t\t\t} else if (c === '\"' || c === \"'\") {\n\t\t\t\t\tin_str = c;\n\t\t\t\t} else if (c === '(') {\n\t\t\t\t\tin_apo++;\n\t\t\t\t} else if (c === ')') {\n\t\t\t\t\tin_apo--;\n\t\t\t\t}\n\n\t\t\t\tif (!in_comment && in_str === false && in_apo === 0) {\n\t\t\t\t\tif (c === ':' && name_index === -1) {\n\t\t\t\t\t\tname_index = i;\n\t\t\t\t\t} else if (c === ';' || i === len - 1) {\n\t\t\t\t\t\tif (name_index !== -1) {\n\t\t\t\t\t\t\tvar name = to_css_name(value.substring(start_index, name_index).trim());\n\n\t\t\t\t\t\t\tif (!reserved_names.includes(name)) {\n\t\t\t\t\t\t\t\tif (c !== ';') {\n\t\t\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tvar property = value.substring(start_index, i).trim();\n\t\t\t\t\t\t\t\tnew_style += ' ' + property + ';';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstart_index = i + 1;\n\t\t\t\t\t\tname_index = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (normal_styles) {\n\t\t\tnew_style += append_styles(normal_styles);\n\t\t}\n\n\t\tif (important_styles) {\n\t\t\tnew_style += append_styles(important_styles, true);\n\t\t}\n\n\t\tnew_style = new_style.trim();\n\t\treturn new_style === '' ? null : new_style;\n\t}\n\n\treturn value == null ? null : String(value);\n}\n","import { to_class } from '../../../shared/attributes.js';\nimport { hydrating } from '../hydration.js';\n\n/**\n * @param {Element} dom\n * @param {boolean | number} is_html\n * @param {string | null} value\n * @param {string} [hash]\n * @param {Record<string, any>} [prev_classes]\n * @param {Record<string, any>} [next_classes]\n * @returns {Record<string, boolean> | undefined}\n */\nexport function set_class(dom, is_html, value, hash, prev_classes, next_classes) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev = dom.__className;\n\n\tif (\n\t\thydrating ||\n\t\tprev !== value ||\n\t\tprev === undefined // for edge case of `class={undefined}`\n\t) {\n\t\tvar next_class_name = to_class(value, hash, next_classes);\n\n\t\tif (!hydrating || next_class_name !== dom.getAttribute('class')) {\n\t\t\t// Removing the attribute when the value is only an empty string causes\n\t\t\t// performance issues vs simply making the className an empty string. So\n\t\t\t// we should only remove the class if the value is nullish\n\t\t\t// and there no hash/directives :\n\t\t\tif (next_class_name == null) {\n\t\t\t\tdom.removeAttribute('class');\n\t\t\t} else if (is_html) {\n\t\t\t\tdom.className = next_class_name;\n\t\t\t} else {\n\t\t\t\tdom.setAttribute('class', next_class_name);\n\t\t\t}\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = value;\n\t} else if (next_classes && prev_classes !== next_classes) {\n\t\tfor (var key in next_classes) {\n\t\t\tvar is_present = !!next_classes[key];\n\n\t\t\tif (prev_classes == null || is_present !== !!prev_classes[key]) {\n\t\t\t\tdom.classList.toggle(key, is_present);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn next_classes;\n}\n","import { to_style } from '../../../shared/attributes.js';\nimport { hydrating } from '../hydration.js';\n\n/**\n * @param {Element & ElementCSSInlineStyle} dom\n * @param {Record<string, any>} prev\n * @param {Record<string, any>} next\n * @param {string} [priority]\n */\nfunction update_styles(dom, prev = {}, next, priority) {\n\tfor (var key in next) {\n\t\tvar value = next[key];\n\n\t\tif (prev[key] !== value) {\n\t\t\tif (next[key] == null) {\n\t\t\t\tdom.style.removeProperty(key);\n\t\t\t} else {\n\t\t\t\tdom.style.setProperty(key, value, priority);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} dom\n * @param {string | null} value\n * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [prev_styles]\n * @param {Record<string, any> | [Record<string, any>, Record<string, any>]} [next_styles]\n */\nexport function set_style(dom, value, prev_styles, next_styles) {\n\t// @ts-expect-error\n\tvar prev = dom.__style;\n\n\tif (hydrating || prev !== value) {\n\t\tvar next_style_attr = to_style(value, next_styles);\n\n\t\tif (!hydrating || next_style_attr !== dom.getAttribute('style')) {\n\t\t\tif (next_style_attr == null) {\n\t\t\t\tdom.removeAttribute('style');\n\t\t\t} else {\n\t\t\t\tdom.style.cssText = next_style_attr;\n\t\t\t}\n\t\t}\n\n\t\t// @ts-expect-error\n\t\tdom.__style = value;\n\t} else if (next_styles) {\n\t\tif (Array.isArray(next_styles)) {\n\t\t\tupdate_styles(dom, prev_styles?.[0], next_styles[0]);\n\t\t\tupdate_styles(dom, prev_styles?.[1], next_styles[1], 'important');\n\t\t} else {\n\t\t\tupdate_styles(dom, prev_styles, next_styles);\n\t\t}\n\t}\n\n\treturn next_styles;\n}\n","import { effect, teardown } from '../../../reactivity/effects.js';\nimport { listen_to_event_and_reset_event } from './shared.js';\nimport { is } from '../../../proxy.js';\nimport { is_array } from '../../../../shared/utils.js';\nimport * as w from '../../../warnings.js';\nimport { Batch, current_batch, previous_batch } from '../../../reactivity/batch.js';\n\n/**\n * Selects the correct option(s) (depending on whether this is a multiple select)\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n * @param {boolean} mounting\n */\nexport function select_option(select, value, mounting = false) {\n\tif (select.multiple) {\n\t\t// If value is null or undefined, keep the selection as is\n\t\tif (value == undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If not an array, warn and keep the selection as is\n\t\tif (!is_array(value)) {\n\t\t\treturn w.select_multiple_invalid_value();\n\t\t}\n\n\t\t// Otherwise, update the selection\n\t\tfor (var option of select.options) {\n\t\t\toption.selected = value.includes(get_option_value(option));\n\t\t}\n\n\t\treturn;\n\t}\n\n\tfor (option of select.options) {\n\t\tvar option_value = get_option_value(option);\n\t\tif (is(option_value, value)) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * Selects the correct option(s) if `value` is given,\n * and then sets up a mutation observer to sync the\n * current selection to the dom when it changes. Such\n * changes could for example occur when options are\n * inside an `#each` block.\n * @param {HTMLSelectElement} select\n */\nexport function init_select(select) {\n\tvar observer = new MutationObserver(() => {\n\t\t// @ts-ignore\n\t\tselect_option(select, select.__value);\n\t\t// Deliberately don't update the potential binding value,\n\t\t// the model should be preserved unless explicitly changed\n\t});\n\n\tobserver.observe(select, {\n\t\t// Listen to option element changes\n\t\tchildList: true,\n\t\tsubtree: true, // because of <optgroup>\n\t\t// Listen to option element value attribute changes\n\t\t// (doesn't get notified of select value changes,\n\t\t// because that property is not reflected as an attribute)\n\t\tattributes: true,\n\t\tattributeFilter: ['value']\n\t});\n\n\tteardown(() => {\n\t\tobserver.disconnect();\n\t});\n}\n\n/**\n * @param {HTMLSelectElement} select\n * @param {() => unknown} get\n * @param {(value: unknown) => void} set\n * @returns {void}\n */\nexport function bind_select_value(select, get, set = get) {\n\tvar batches = new WeakSet();\n\tvar mounting = true;\n\n\tlisten_to_event_and_reset_event(select, 'change', (is_reset) => {\n\t\tvar query = is_reset ? '[selected]' : ':checked';\n\t\t/** @type {unknown} */\n\t\tvar value;\n\n\t\tif (select.multiple) {\n\t\t\tvalue = [].map.call(select.querySelectorAll(query), get_option_value);\n\t\t} else {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option =\n\t\t\t\tselect.querySelector(query) ??\n\t\t\t\t// will fall back to first non-disabled option if no option is selected\n\t\t\t\tselect.querySelector('option:not([disabled])');\n\t\t\tvalue = selected_option && get_option_value(selected_option);\n\t\t}\n\n\t\tset(value);\n\n\t\tif (current_batch !== null) {\n\t\t\tbatches.add(current_batch);\n\t\t}\n\t});\n\n\t// Needs to be an effect, not a render_effect, so that in case of each loops the logic runs after the each block has updated\n\teffect(() => {\n\t\tvar value = get();\n\n\t\tif (select === document.activeElement) {\n\t\t\t// we need both, because in non-async mode, render effects run before previous_batch is set\n\t\t\tvar batch = /** @type {Batch} */ (previous_batch ?? current_batch);\n\n\t\t\t// Don't update the <select> if it is focused. We can get here if, for example,\n\t\t\t// an update is deferred because of async work depending on the select:\n\t\t\t//\n\t\t\t// <select bind:value={selected}>...</select>\n\t\t\t// <p>{await find(selected)}</p>\n\t\t\tif (batches.has(batch)) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tselect_option(select, value, mounting);\n\n\t\t// Mounting and value undefined -> take selection from dom\n\t\tif (mounting && value === undefined) {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option = select.querySelector(':checked');\n\t\t\tif (selected_option !== null) {\n\t\t\t\tvalue = get_option_value(selected_option);\n\t\t\t\tset(value);\n\t\t\t}\n\t\t}\n\n\t\t// @ts-ignore\n\t\tselect.__value = value;\n\t\tmounting = false;\n\t});\n\n\tinit_select(select);\n}\n\n/** @param {HTMLOptionElement} option */\nfunction get_option_value(option) {\n\t// __value only exists if the <option> has a value attribute\n\tif ('__value' in option) {\n\t\treturn option.__value;\n\t} else {\n\t\treturn option.value;\n\t}\n}\n","/** @import { Effect } from '#client' */\nimport { DEV } from 'esm-env';\nimport { hydrating, set_hydrating } from '../hydration.js';\nimport { get_descriptors, get_prototype_of } from '../../../shared/utils.js';\nimport { create_event, delegate } from './events.js';\nimport { add_form_reset_listener, autofocus } from './misc.js';\nimport * as w from '../../warnings.js';\nimport { LOADING_ATTR_SYMBOL } from '#client/constants';\nimport { queue_micro_task } from '../task.js';\nimport { is_capture_event, can_delegate_event, normalize_attribute } from '../../../../utils.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tget,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\nimport { attach } from './attachments.js';\nimport { clsx } from '../../../shared/attributes.js';\nimport { set_class } from './class.js';\nimport { set_style } from './style.js';\nimport { ATTACHMENT_KEY, NAMESPACE_HTML, UNINITIALIZED } from '../../../../constants.js';\nimport { branch, destroy_effect, effect, managed } from '../../reactivity/effects.js';\nimport { init_select, select_option } from './bindings/select.js';\nimport { flatten } from '../../reactivity/async.js';\n\nexport const CLASS = Symbol('class');\nexport const STYLE = Symbol('style');\n\nconst IS_CUSTOM_ELEMENT = Symbol('is custom element');\nconst IS_HTML = Symbol('is html');\n\n/**\n * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLInputElement} input\n * @returns {void}\n */\nexport function remove_input_defaults(input) {\n\tif (!hydrating) return;\n\n\tvar already_removed = false;\n\n\t// We try and remove the default attributes later, rather than sync during hydration.\n\t// Doing it sync during hydration has a negative impact on performance, but deferring the\n\t// work in an idle task alleviates this greatly. If a form reset event comes in before\n\t// the idle callback, then we ensure the input defaults are cleared just before.\n\tvar remove_defaults = () => {\n\t\tif (already_removed) return;\n\t\talready_removed = true;\n\n\t\t// Remove the attributes but preserve the values\n\t\tif (input.hasAttribute('value')) {\n\t\t\tvar value = input.value;\n\t\t\tset_attribute(input, 'value', null);\n\t\t\tinput.value = value;\n\t\t}\n\n\t\tif (input.hasAttribute('checked')) {\n\t\t\tvar checked = input.checked;\n\t\t\tset_attribute(input, 'checked', null);\n\t\t\tinput.checked = checked;\n\t\t}\n\t};\n\n\t// @ts-expect-error\n\tinput.__on_r = remove_defaults;\n\tqueue_micro_task(remove_defaults);\n\tadd_form_reset_listener();\n}\n\n/**\n * @param {Element} element\n * @param {any} value\n */\nexport function set_value(element, value) {\n\tvar attributes = get_attributes(element);\n\n\tif (\n\t\tattributes.value ===\n\t\t\t(attributes.value =\n\t\t\t\t// treat null and undefined the same for the initial value\n\t\t\t\tvalue ?? undefined) ||\n\t\t// @ts-expect-error\n\t\t// `progress` elements always need their value set when it's `0`\n\t\t(element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS'))\n\t) {\n\t\treturn;\n\t}\n\n\t// @ts-expect-error\n\telement.value = value ?? '';\n}\n\n/**\n * @param {Element} element\n * @param {boolean} checked\n */\nexport function set_checked(element, checked) {\n\tvar attributes = get_attributes(element);\n\n\tif (\n\t\tattributes.checked ===\n\t\t(attributes.checked =\n\t\t\t// treat null and undefined the same for the initial value\n\t\t\tchecked ?? undefined)\n\t) {\n\t\treturn;\n\t}\n\n\t// @ts-expect-error\n\telement.checked = checked;\n}\n\n/**\n * Sets the `selected` attribute on an `option` element.\n * Not set through the property because that doesn't reflect to the DOM,\n * which means it wouldn't be taken into account when a form is reset.\n * @param {HTMLOptionElement} element\n * @param {boolean} selected\n */\nexport function set_selected(element, selected) {\n\tif (selected) {\n\t\t// The selected option could've changed via user selection, and\n\t\t// setting the value without this check would set it back.\n\t\tif (!element.hasAttribute('selected')) {\n\t\t\telement.setAttribute('selected', '');\n\t\t}\n\t} else {\n\t\telement.removeAttribute('selected');\n\t}\n}\n\n/**\n * Applies the default checked property without influencing the current checked property.\n * @param {HTMLInputElement} element\n * @param {boolean} checked\n */\nexport function set_default_checked(element, checked) {\n\tconst existing_value = element.checked;\n\telement.defaultChecked = checked;\n\telement.checked = existing_value;\n}\n\n/**\n * Applies the default value property without influencing the current value property.\n * @param {HTMLInputElement | HTMLTextAreaElement} element\n * @param {string} value\n */\nexport function set_default_value(element, value) {\n\tconst existing_value = element.value;\n\telement.defaultValue = value;\n\telement.value = existing_value;\n}\n\n/**\n * @param {Element} element\n * @param {string} attribute\n * @param {string | null} value\n * @param {boolean} [skip_warning]\n */\nexport function set_attribute(element, attribute, value, skip_warning) {\n\tvar attributes = get_attributes(element);\n\n\tif (hydrating) {\n\t\tattributes[attribute] = element.getAttribute(attribute);\n\n\t\tif (\n\t\t\tattribute === 'src' ||\n\t\t\tattribute === 'srcset' ||\n\t\t\t(attribute === 'href' && element.nodeName === 'LINK')\n\t\t) {\n\t\t\tif (!skip_warning) {\n\t\t\t\tcheck_src_in_dev_hydration(element, attribute, value ?? '');\n\t\t\t}\n\n\t\t\t// If we reset these attributes, they would result in another network request, which we want to avoid.\n\t\t\t// We assume they are the same between client and server as checking if they are equal is expensive\n\t\t\t// (we can't just compare the strings as they can be different between client and server but result in the\n\t\t\t// same url, so we would need to create hidden anchor elements to compare them)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (attributes[attribute] === (attributes[attribute] = value)) return;\n\n\tif (attribute === 'loading') {\n\t\t// @ts-expect-error\n\t\telement[LOADING_ATTR_SYMBOL] = value;\n\t}\n\n\tif (value == null) {\n\t\telement.removeAttribute(attribute);\n\t} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {\n\t\t// @ts-ignore\n\t\telement[attribute] = value;\n\t} else {\n\t\telement.setAttribute(attribute, value);\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {string} value\n */\nexport function set_xlink_attribute(dom, attribute, value) {\n\tdom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @param {string} prop\n * @param {any} value\n */\nexport function set_custom_element_data(node, prop, value) {\n\t// We need to ensure that setting custom element props, which can\n\t// invoke lifecycle methods on other custom elements, does not also\n\t// associate those lifecycle methods with the current active reaction\n\t// or effect\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\n\t// If we're hydrating but the custom element is from Svelte, and it already scaffolded,\n\t// then it might run block logic in hydration mode, which we have to prevent.\n\tlet was_hydrating = hydrating;\n\tif (hydrating) {\n\t\tset_hydrating(false);\n\t}\n\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\n\ttry {\n\t\tif (\n\t\t\t// `style` should use `set_attribute` rather than the setter\n\t\t\tprop !== 'style' &&\n\t\t\t// Don't compute setters for custom elements while they aren't registered yet,\n\t\t\t// because during their upgrade/instantiation they might add more setters.\n\t\t\t// Instead, fall back to a simple \"an object, then set as property\" heuristic.\n\t\t\t(setters_cache.has(node.getAttribute('is') || node.nodeName) ||\n\t\t\t// customElements may not be available in browser extension contexts\n\t\t\t!customElements ||\n\t\t\tcustomElements.get(node.getAttribute('is') || node.tagName.toLowerCase())\n\t\t\t\t? get_setters(node).includes(prop)\n\t\t\t\t: value && typeof value === 'object')\n\t\t) {\n\t\t\t// @ts-expect-error\n\t\t\tnode[prop] = value;\n\t\t} else {\n\t\t\t// We did getters etc checks already, stringify before passing to set_attribute\n\t\t\t// to ensure it doesn't invoke the same logic again, and potentially populating\n\t\t\t// the setters cache too early.\n\t\t\tset_attribute(node, prop, value == null ? value : String(value));\n\t\t}\n\t} finally {\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t\tif (was_hydrating) {\n\t\t\tset_hydrating(true);\n\t\t}\n\t}\n}\n\n/**\n * Spreads attributes onto a DOM element, taking into account the currently set attributes\n * @param {Element & ElementCSSInlineStyle} element\n * @param {Record<string | symbol, any> | undefined} prev\n * @param {Record<string | symbol, any>} next New attributes - this function mutates this object\n * @param {string} [css_hash]\n * @param {boolean} [should_remove_defaults]\n * @param {boolean} [skip_warning]\n * @returns {Record<string, any>}\n */\nfunction set_attributes(\n\telement,\n\tprev,\n\tnext,\n\tcss_hash,\n\tshould_remove_defaults = false,\n\tskip_warning = false\n) {\n\tif (hydrating && should_remove_defaults && element.tagName === 'INPUT') {\n\t\tvar input = /** @type {HTMLInputElement} */ (element);\n\t\tvar attribute = input.type === 'checkbox' ? 'defaultChecked' : 'defaultValue';\n\n\t\tif (!(attribute in next)) {\n\t\t\tremove_input_defaults(input);\n\t\t}\n\t}\n\n\tvar attributes = get_attributes(element);\n\n\tvar is_custom_element = attributes[IS_CUSTOM_ELEMENT];\n\tvar preserve_attribute_case = !attributes[IS_HTML];\n\n\t// If we're hydrating but the custom element is from Svelte, and it already scaffolded,\n\t// then it might run block logic in hydration mode, which we have to prevent.\n\tlet is_hydrating_custom_element = hydrating && is_custom_element;\n\tif (is_hydrating_custom_element) {\n\t\tset_hydrating(false);\n\t}\n\n\tvar current = prev || {};\n\tvar is_option_element = element.tagName === 'OPTION';\n\n\tfor (var key in prev) {\n\t\tif (!(key in next)) {\n\t\t\tnext[key] = null;\n\t\t}\n\t}\n\n\tif (next.class) {\n\t\tnext.class = clsx(next.class);\n\t} else if (css_hash || next[CLASS]) {\n\t\tnext.class = null; /* force call to set_class() */\n\t}\n\n\tif (next[STYLE]) {\n\t\tnext.style ??= null; /* force call to set_style() */\n\t}\n\n\tvar setters = get_setters(element);\n\n\t// since key is captured we use const\n\tfor (const key in next) {\n\t\t// let instead of var because referenced in a closure\n\t\tlet value = next[key];\n\n\t\t// Up here because we want to do this for the initial value, too, even if it's undefined,\n\t\t// and this wouldn't be reached in case of undefined because of the equality check below\n\t\tif (is_option_element && key === 'value' && value == null) {\n\t\t\t// The <option> element is a special case because removing the value attribute means\n\t\t\t// the value is set to the text content of the option element, and setting the value\n\t\t\t// to null or undefined means the value is set to the string \"null\" or \"undefined\".\n\t\t\t// To align with how we handle this case in non-spread-scenarios, this logic is needed.\n\t\t\t// There's a super-edge-case bug here that is left in in favor of smaller code size:\n\t\t\t// Because of the \"set missing props to null\" logic above, we can't differentiate\n\t\t\t// between a missing value and an explicitly set value of null or undefined. That means\n\t\t\t// that once set, the value attribute of an <option> element can't be removed. This is\n\t\t\t// a very rare edge case, and removing the attribute altogether isn't possible either\n\t\t\t// for the <option value={undefined}> case, so we're not losing any functionality here.\n\t\t\t// @ts-ignore\n\t\t\telement.value = element.__value = '';\n\t\t\tcurrent[key] = value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key === 'class') {\n\t\t\tvar is_html = element.namespaceURI === 'http://www.w3.org/1999/xhtml';\n\t\t\tset_class(element, is_html, value, css_hash, prev?.[CLASS], next[CLASS]);\n\t\t\tcurrent[key] = value;\n\t\t\tcurrent[CLASS] = next[CLASS];\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (key === 'style') {\n\t\t\tset_style(element, value, prev?.[STYLE], next[STYLE]);\n\t\t\tcurrent[key] = value;\n\t\t\tcurrent[STYLE] = next[STYLE];\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar prev_value = current[key];\n\n\t\t// Skip if value is unchanged, unless it's `undefined` and the element still has the attribute\n\t\tif (value === prev_value && !(value === undefined && element.hasAttribute(key))) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tcurrent[key] = value;\n\n\t\tvar prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)\n\t\tif (prefix === '$$') continue;\n\n\t\tif (prefix === 'on') {\n\t\t\t/** @type {{ capture?: true }} */\n\t\t\tconst opts = {};\n\t\t\tconst event_handle_key = '$$' + key;\n\t\t\tlet event_name = key.slice(2);\n\t\t\tvar delegated = can_delegate_event(event_name);\n\n\t\t\tif (is_capture_event(event_name)) {\n\t\t\t\tevent_name = event_name.slice(0, -7);\n\t\t\t\topts.capture = true;\n\t\t\t}\n\n\t\t\tif (!delegated && prev_value) {\n\t\t\t\t// Listening to same event but different handler -> our handle function below takes care of this\n\t\t\t\t// If we were to remove and add listeners in this case, it could happen that the event is \"swallowed\"\n\t\t\t\t// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler\n\t\t\t\t// https://github.com/sveltejs/svelte/issues/11903\n\t\t\t\tif (value != null) continue;\n\n\t\t\t\telement.removeEventListener(event_name, current[event_handle_key], opts);\n\t\t\t\tcurrent[event_handle_key] = null;\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tif (!delegated) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @this {any}\n\t\t\t\t\t * @param {Event} evt\n\t\t\t\t\t */\n\t\t\t\t\tfunction handle(evt) {\n\t\t\t\t\t\tcurrent[key].call(this, evt);\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrent[event_handle_key] = create_event(event_name, element, handle, opts);\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\telement[`__${event_name}`] = value;\n\t\t\t\t\tdelegate([event_name]);\n\t\t\t\t}\n\t\t\t} else if (delegated) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[`__${event_name}`] = undefined;\n\t\t\t}\n\t\t} else if (key === 'style') {\n\t\t\t// avoid using the setter\n\t\t\tset_attribute(element, key, value);\n\t\t} else if (key === 'autofocus') {\n\t\t\tautofocus(/** @type {HTMLElement} */ (element), Boolean(value));\n\t\t} else if (!is_custom_element && (key === '__value' || (key === 'value' && value != null))) {\n\t\t\t// @ts-ignore We're not running this for custom elements because __value is actually\n\t\t\t// how Lit stores the current value on the element, and messing with that would break things.\n\t\t\telement.value = element.__value = value;\n\t\t} else if (key === 'selected' && is_option_element) {\n\t\t\tset_selected(/** @type {HTMLOptionElement} */ (element), value);\n\t\t} else {\n\t\t\tvar name = key;\n\t\t\tif (!preserve_attribute_case) {\n\t\t\t\tname = normalize_attribute(name);\n\t\t\t}\n\n\t\t\tvar is_default = name === 'defaultValue' || name === 'defaultChecked';\n\n\t\t\tif (value == null && !is_custom_element && !is_default) {\n\t\t\t\tattributes[key] = null;\n\n\t\t\t\tif (name === 'value' || name === 'checked') {\n\t\t\t\t\t// removing value/checked also removes defaultValue/defaultChecked — preserve\n\t\t\t\t\tlet input = /** @type {HTMLInputElement} */ (element);\n\t\t\t\t\tconst use_default = prev === undefined;\n\t\t\t\t\tif (name === 'value') {\n\t\t\t\t\t\tlet previous = input.defaultValue;\n\t\t\t\t\t\tinput.removeAttribute(name);\n\t\t\t\t\t\tinput.defaultValue = previous;\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tinput.value = input.__value = use_default ? previous : null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet previous = input.defaultChecked;\n\t\t\t\t\t\tinput.removeAttribute(name);\n\t\t\t\t\t\tinput.defaultChecked = previous;\n\t\t\t\t\t\tinput.checked = use_default ? previous : false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telement.removeAttribute(key);\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tis_default ||\n\t\t\t\t(setters.includes(name) && (is_custom_element || typeof value !== 'string'))\n\t\t\t) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[name] = value;\n\t\t\t\t// remove it from attributes's cache\n\t\t\t\tif (name in attributes) attributes[name] = UNINITIALIZED;\n\t\t\t} else if (typeof value !== 'function') {\n\t\t\t\tset_attribute(element, name, value, skip_warning);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (is_hydrating_custom_element) {\n\t\tset_hydrating(true);\n\t}\n\n\treturn current;\n}\n\n/**\n * @param {Element & ElementCSSInlineStyle} element\n * @param {(...expressions: any) => Record<string | symbol, any>} fn\n * @param {Array<() => any>} sync\n * @param {Array<() => Promise<any>>} async\n * @param {Array<Promise<void>>} blockers\n * @param {string} [css_hash]\n * @param {boolean} [should_remove_defaults]\n * @param {boolean} [skip_warning]\n */\nexport function attribute_effect(\n\telement,\n\tfn,\n\tsync = [],\n\tasync = [],\n\tblockers = [],\n\tcss_hash,\n\tshould_remove_defaults = false,\n\tskip_warning = false\n) {\n\tflatten(blockers, sync, async, (values) => {\n\t\t/** @type {Record<string | symbol, any> | undefined} */\n\t\tvar prev = undefined;\n\n\t\t/** @type {Record<symbol, Effect>} */\n\t\tvar effects = {};\n\n\t\tvar is_select = element.nodeName === 'SELECT';\n\t\tvar inited = false;\n\n\t\tmanaged(() => {\n\t\t\tvar next = fn(...values.map(get));\n\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\tvar current = set_attributes(\n\t\t\t\telement,\n\t\t\t\tprev,\n\t\t\t\tnext,\n\t\t\t\tcss_hash,\n\t\t\t\tshould_remove_defaults,\n\t\t\t\tskip_warning\n\t\t\t);\n\n\t\t\tif (inited && is_select && 'value' in next) {\n\t\t\t\tselect_option(/** @type {HTMLSelectElement} */ (element), next.value);\n\t\t\t}\n\n\t\t\tfor (let symbol of Object.getOwnPropertySymbols(effects)) {\n\t\t\t\tif (!next[symbol]) destroy_effect(effects[symbol]);\n\t\t\t}\n\n\t\t\tfor (let symbol of Object.getOwnPropertySymbols(next)) {\n\t\t\t\tvar n = next[symbol];\n\n\t\t\t\tif (symbol.description === ATTACHMENT_KEY && (!prev || n !== prev[symbol])) {\n\t\t\t\t\tif (effects[symbol]) destroy_effect(effects[symbol]);\n\t\t\t\t\teffects[symbol] = branch(() => attach(element, () => n));\n\t\t\t\t}\n\n\t\t\t\tcurrent[symbol] = n;\n\t\t\t}\n\n\t\t\tprev = current;\n\t\t});\n\n\t\tif (is_select) {\n\t\t\tvar select = /** @type {HTMLSelectElement} */ (element);\n\n\t\t\teffect(() => {\n\t\t\t\tselect_option(select, /** @type {Record<string | symbol, any>} */ (prev).value, true);\n\t\t\t\tinit_select(select);\n\t\t\t});\n\t\t}\n\n\t\tinited = true;\n\t});\n}\n\n/**\n *\n * @param {Element} element\n */\nfunction get_attributes(element) {\n\treturn /** @type {Record<string | symbol, unknown>} **/ (\n\t\t// @ts-expect-error\n\t\telement.__attributes ??= {\n\t\t\t[IS_CUSTOM_ELEMENT]: element.nodeName.includes('-'),\n\t\t\t[IS_HTML]: element.namespaceURI === NAMESPACE_HTML\n\t\t}\n\t);\n}\n\n/** @type {Map<string, string[]>} */\nvar setters_cache = new Map();\n\n/** @param {Element} element */\nfunction get_setters(element) {\n\tvar cache_key = element.getAttribute('is') || element.nodeName;\n\tvar setters = setters_cache.get(cache_key);\n\tif (setters) return setters;\n\tsetters_cache.set(cache_key, (setters = []));\n\n\tvar descriptors;\n\tvar proto = element; // In the case of custom elements there might be setters on the instance\n\tvar element_proto = Element.prototype;\n\n\t// Stop at Element, from there on there's only unnecessary setters we're not interested in\n\t// Do not use contructor.name here as that's unreliable in some browser environments\n\twhile (element_proto !== proto) {\n\t\tdescriptors = get_descriptors(proto);\n\n\t\tfor (var key in descriptors) {\n\t\t\tif (descriptors[key].set) {\n\t\t\t\tsetters.push(key);\n\t\t\t}\n\t\t}\n\n\t\tproto = get_prototype_of(proto);\n\t}\n\n\treturn setters;\n}\n\n/**\n * @param {any} element\n * @param {string} attribute\n * @param {string} value\n */\nfunction check_src_in_dev_hydration(element, attribute, value) {\n\tif (!DEV) return;\n\tif (attribute === 'srcset' && srcset_url_equal(element, value)) return;\n\tif (src_url_equal(element.getAttribute(attribute) ?? '', value)) return;\n\n\tw.hydration_attribute_changed(\n\t\tattribute,\n\t\telement.outerHTML.replace(element.innerHTML, element.innerHTML && '...'),\n\t\tString(value)\n\t);\n}\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nfunction src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\treturn new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element\n * @param {string} srcset\n * @returns {boolean}\n */\nfunction srcset_url_equal(element, srcset) {\n\tvar element_urls = split_srcset(element.srcset);\n\tvar urls = split_srcset(srcset);\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n"],"names":["index","_","i","destroy_effects","to_destroy","remove_dom","length","destroy_effect","offscreen_anchor","each","node","flags","get_collection","get_key","render_fn","fallback_fn","anchor","items","Map","EACH_IS_CONTROLLED","parent_node","hydrating","set_hydrate_node","get_first_child","appendChild","create_text","hydrate_next","array","fallback","each_array","derived_safe_equal","collection","is_array","array_from","first_run","commit","state","seen","to_animate","key","effect","is_animated","EACH_IS_ANIMATED","current","first","prev","matched","stashed","get","e","f","EFFECT_OFFSCREEN","nodes","a","measure","Set","add","outrogroups","group","pending","delete","done","next","last","link","move","INERT","resume_effect","unfix","has","j","start","b","push","size","destroy_length","controlled_anchor","fix","remaining","pause_effect","groups","fast_path","clear_text_content","append","clear","pause_effects","queue_micro_task","apply","reconcile","block","mismatch","read_hydration_instruction","HYDRATION_START_ELSE","skip_nodes","set_hydrating","keys","batch","defer","should_defer_append","hydrate_node","nodeType","COMMENT_NODE","data","HYDRATION_END","value","item","v","internal_set","skipped_effects","create_item","set","branch","oncommit","ondiscard","EACH_ITEM_REACTIVE","EACH_ITEM_IMMUTABLE","mutable_source","source","EACH_INDEX_REACTIVE","end","dest","next_node","get_next_sibling","before","attach","get_fn","fn","managed","clsx","_clsx","whitespace","append_styles","styles","important","separator","css","to_css_name","name","toLowerCase","set_class","dom","is_html","hash","prev_classes","next_classes","__className","next_class_name","directives","classname","len","indexOf","includes","substring","to_class","getAttribute","removeAttribute","className","setAttribute","is_present","classList","toggle","update_styles","priority","style","removeProperty","setProperty","set_style","prev_styles","next_styles","__style","next_style_attr","normal_styles","important_styles","new_style","Array","isArray","String","replaceAll","trim","in_str","in_apo","in_comment","reserved_names","Object","map","start_index","name_index","c","to_style","cssText","select_option","select","mounting","multiple","w.select_multiple_invalid_value","option","options","selected","get_option_value","option_value","is","selectedIndex","init_select","observer","MutationObserver","__value","observe","childList","subtree","attributes","attributeFilter","teardown","disconnect","bind_select_value","batches","WeakSet","listen_to_event_and_reset_event","is_reset","query","call","querySelectorAll","selected_option","querySelector","current_batch","document","activeElement","previous_batch","CLASS","Symbol","STYLE","IS_CUSTOM_ELEMENT","IS_HTML","remove_input_defaults","input","already_removed","remove_defaults","hasAttribute","set_attribute","checked","__on_r","add_form_reset_listener","set_checked","element","get_attributes","set_selected","attribute","skip_warning","nodeName","LOADING_ATTR_SYMBOL","get_setters","attribute_effect","sync","async","blockers","css_hash","should_remove_defaults","flatten","values","effects","is_select","inited","tagName","type","is_custom_element","preserve_attribute_case","is_hydrating_custom_element","is_option_element","class","setters","prev_value","prefix","opts","event_handle_key","event_name","slice","delegated","can_delegate_event","is_capture_event","capture","removeEventListener","delegate","handle","evt","this","create_event","autofocus","Boolean","normalize_attribute","is_default","UNINITIALIZED","use_default","previous","defaultValue","defaultChecked","namespaceURI","set_attributes","symbol","getOwnPropertySymbols","n","description","ATTACHMENT_KEY","__attributes","NAMESPACE_HTML","setters_cache","descriptors","cache_key","proto","element_proto","Element","prototype","get_descriptors","get_prototype_of"],"mappings":"ogBAmDO,SAASA,GAAMC,EAAGC,GACxB,OAAOA,CACR,CA6EA,SAASC,GAAgBC,EAAYC,GAAa,GAGjD,IAAA,IAASH,EAAI,EAAGA,EAAIE,EAAWE,OAAQJ,IACtCK,EAAeH,EAAWF,GAAIG,EAEhC,CAGA,IAAIG,GAYG,SAASC,GAAKC,EAAMC,EAAOC,EAAgBC,EAASC,EAAWC,EAAc,MACnF,IAAIC,EAASN,EAGTO,MAAYC,IAIhB,GAFqD,KAAhCP,EAAQQ,GAEV,CAClB,IAAIC,EAAA,EAEJJ,EAASK,EACNC,EAAiBC,EAAgBH,IACjCA,EAAYI,YAAYC,IAC5B,CAEIJ,GACHK,IAID,IAYIC,EAZAC,EAAW,KAKXC,EAAaC,EAAmB,KACnC,IAAIC,EAAanB,IAEjB,OAAOoB,EAASD,GAAcA,EAA2B,MAAdA,EAAqB,GAAKE,EAAWF,KAM7EG,GAAY,EAEhB,SAASC,IACRC,EAAMR,SAAWA,EA+JnB,SAAmBQ,EAAOT,EAAOX,EAAQL,EAAOE,GAC/C,IAOIwB,EAMAC,EAYAC,EAGAC,EAGAtC,EA/BAuC,EAA6C,KAA9B9B,EAAQ+B,GAEvBpC,EAASqB,EAAMrB,OACfW,EAAQmB,EAAMnB,MACd0B,EAAUP,EAAMI,OAAOI,MAMvBC,EAAO,KAMPC,EAAU,GAGVC,EAAU,GAcd,GAAIN,EACH,IAAKvC,EAAI,EAAGA,EAAII,EAAQJ,GAAK,EAE5BqC,EAAM1B,EADEc,EAAMzB,GACOA,GAKiB,MAJtCsC,EAAkCvB,EAAM+B,IAAIT,GAAMU,GAItCC,EAAIC,KACfX,EAAOY,OAAOC,GAAGC,WAChBhB,IAAAA,EAAe,IAAIiB,MAAOC,IAAIhB,IAKlC,IAAKtC,EAAI,EAAGA,EAAII,EAAQJ,GAAK,EAAG,CAM/B,GAJAqC,EAAM1B,EADEc,EAAMzB,GACOA,GAErBsC,EAAkCvB,EAAM+B,IAAIT,GAAMU,EAExB,OAAtBb,EAAMqB,YACT,IAAA,MAAWC,KAAStB,EAAMqB,YACzBC,EAAMC,QAAQC,OAAOpB,GACrBkB,EAAMG,KAAKD,OAAOpB,GAIpB,GAAsC,KAAjCA,EAAOU,EAAIC,GAAyB,CAGxC,GAFAX,EAAOU,GAAKC,EAERX,IAAWG,EAER,CACN,IAAImB,EAAOjB,EAAOA,EAAKiB,KAAOnB,EAE1BH,IAAWJ,EAAMI,OAAOuB,OAC3B3B,EAAMI,OAAOuB,KAAOvB,EAAOK,MAGxBL,EAAOK,OAAML,EAAOK,KAAKiB,KAAOtB,EAAOsB,MACvCtB,EAAOsB,OAAMtB,EAAOsB,KAAKjB,KAAOL,EAAOK,MAC3CmB,GAAK5B,EAAOS,EAAML,GAClBwB,GAAK5B,EAAOI,EAAQsB,GAEpBG,GAAKzB,EAAQsB,EAAM9C,GAGnB8B,EAAU,GACVC,EAAU,GAEVJ,GALAE,EAAOL,GAKQsB,KACf,QACD,CArBCG,GAAKzB,EAAQ,KAAMxB,EAsBrB,CAUA,GAR2B,KAAtBwB,EAAOU,EAAIgB,KACfC,EAAc3B,GACVC,IACHD,EAAOY,OAAOC,GAAGe,SAChB9B,IAAAA,EAAe,IAAIiB,MAAOK,OAAOpB,KAIhCA,IAAWG,EAAS,CACvB,QAAa,IAATN,GAAsBA,EAAKgC,IAAI7B,GAAS,CAC3C,GAAIM,EAAQxC,OAASyC,EAAQzC,OAAQ,CAEpC,IACIgE,EADAC,EAAQxB,EAAQ,GAGpBF,EAAO0B,EAAM1B,KAEb,IAAIQ,EAAIP,EAAQ,GACZ0B,EAAI1B,EAAQA,EAAQxC,OAAS,GAEjC,IAAKgE,EAAI,EAAGA,EAAIxB,EAAQxC,OAAQgE,GAAK,EACpCL,GAAKnB,EAAQwB,GAAIC,EAAOvD,GAGzB,IAAKsD,EAAI,EAAGA,EAAIvB,EAAQzC,OAAQgE,GAAK,EACpCjC,EAAKuB,OAAOb,EAAQuB,IAGrBN,GAAK5B,EAAOiB,EAAER,KAAM2B,EAAEV,MACtBE,GAAK5B,EAAOS,EAAMQ,GAClBW,GAAK5B,EAAOoC,EAAGD,GAEf5B,EAAU4B,EACV1B,EAAO2B,EACPtE,GAAK,EAEL4C,EAAU,GACVC,EAAU,EACX,MAECV,EAAKuB,OAAOpB,GACZyB,GAAKzB,EAAQG,EAAS3B,GAEtBgD,GAAK5B,EAAOI,EAAOK,KAAML,EAAOsB,MAChCE,GAAK5B,EAAOI,EAAiB,OAATK,EAAgBT,EAAMI,OAAOI,MAAQC,EAAKiB,MAC9DE,GAAK5B,EAAOS,EAAML,GAElBK,EAAOL,EAGR,QACD,CAKA,IAHAM,EAAU,GACVC,EAAU,GAES,OAAZJ,GAAoBA,IAAYH,IACrCH,IAAAA,EAAS,IAAIkB,MAAOC,IAAIb,GACzBI,EAAQ0B,KAAK9B,GACbA,EAAUA,EAAQmB,KAGnB,GAAgB,OAAZnB,EACH,QAEF,CAEsC,KAAjCH,EAAOU,EAAIC,IACfL,EAAQ2B,KAAKjC,GAGdK,EAAOL,EACPG,EAAUH,EAAOsB,IAClB,CAEA,GAA0B,OAAtB1B,EAAMqB,YAAsB,CAC/B,IAAA,MAAWC,KAAStB,EAAMqB,YACE,IAAvBC,EAAMC,QAAQe,OACjBvE,GAAgB8B,EAAWyB,EAAMG,OACjCzB,EAAMqB,aAAaG,OAAOF,IAIG,IAA3BtB,EAAMqB,YAAYiB,OACrBtC,EAAMqB,YAAc,KAEtB,CAEA,GAAgB,OAAZd,QAA6B,IAATN,EAAoB,CAE3C,IAAIjC,EAAa,GAEjB,QAAa,IAATiC,EACH,IAAKG,KAAUH,EACa,KAAtBG,EAAOU,EAAIgB,IACf9D,EAAWqE,KAAKjC,GAKnB,KAAmB,OAAZG,GAEsB,KAAvBA,EAAQO,EAAIgB,IAAgBvB,IAAYP,EAAMR,UAClDxB,EAAWqE,KAAK9B,GAGjBA,EAAUA,EAAQmB,KAGnB,IAAIa,EAAiBvE,EAAWE,OAEhC,GAAIqE,EAAiB,EAAG,CACvB,IAAIC,EAAqD,KAAhCjE,EAAQQ,IAAwC,IAAXb,EAAeU,EAAS,KAEtF,GAAIyB,EAAa,CAChB,IAAKvC,EAAI,EAAGA,EAAIyE,EAAgBzE,GAAK,EACpCE,EAAWF,GAAGkD,OAAOC,GAAGC,UAGzB,IAAKpD,EAAI,EAAGA,EAAIyE,EAAgBzE,GAAK,EACpCE,EAAWF,GAAGkD,OAAOC,GAAGwB,KAE1B,EAlfH,SAAuBzC,EAAOhC,EAAYwE,GASzC,IAPA,IAIIlB,EAHApD,EAASF,EAAWE,OAIpBwE,EAAY1E,EAAWE,OAElBJ,EAAI,EAAGA,EAAII,EAAQJ,IAAK,CAChC,IAAIsC,EAASpC,EAAWF,GAExB6E,EACCvC,EACA,KACC,GAAIkB,GAIH,GAHAA,EAAMC,QAAQC,OAAOpB,GACrBkB,EAAMG,KAAKL,IAAIhB,GAEY,IAAvBkB,EAAMC,QAAQe,KAAY,CAC7B,IAAIM,EAA6C5C,EAAM,YAEvDjC,GAAgB8B,EAAWyB,EAAMG,OACjCmB,EAAOpB,OAAOF,GAEM,IAAhBsB,EAAON,OACVtC,EAAMqB,YAAc,KAEtB,OAEAqB,GAAa,IAGf,EAEF,CAEA,GAAkB,IAAdA,EAAiB,CAIpB,IAAIG,EAA8D,OAAtBL,EAE5C,GAAIK,EAAW,CACd,IAAIjE,EAAA,EACAI,EAAsCJ,EAAO,WAEjDkE,EAAmB9D,GACnBA,EAAY+D,OAAOnE,GAEnBoB,EAAMnB,MAAMmE,OACb,CAEAjF,GAAgBC,GAAa6E,EAC9B,MACCvB,EAAQ,CACPC,QAAS,IAAIJ,IAAInD,GACjByD,SAAUN,MAGVnB,EAAMqB,cAANrB,EAAMqB,gBAAoBF,MAAOC,IAAIE,EAExC,CAsbG2B,CAAcjD,EAAOhC,EAAYwE,EAClC,CACD,CAEInC,GACH6C,EAAiB,KAChB,QAAmB,IAAfhD,EACJ,IAAKE,KAAUF,EACdE,EAAOY,OAAOC,GAAGkC,SAIrB,CAhYEC,CAAUpD,EAAOT,EAAOX,EAAQL,EAAOE,GAEtB,OAAbe,IACkB,IAAjBD,EAAMrB,OAC+B,KAAnCsB,EAASsB,EAAIC,GACjBgB,EAAcvC,IAEdA,EAASsB,GAAKC,EACdc,GAAKrC,EAAU,KAAMZ,IAGtB+D,EAAanD,EAAU,KAItBA,EAAW,OAIf,CAEA,IAsHIQ,EAAQ,CAAEI,OAtHDiD,EAAM,KAElB,IAAInF,GADJqB,EAA4BqB,EAAInB,IACbvB,OAGnB,IAAIoF,GAAW,EAEXrE,IACWsE,EAA2B3E,KAAY4E,KAEzB,IAAXtF,KAEhBU,EAAS6E,IAETvE,EAAiBN,GACjB8E,GAAc,GACdJ,GAAW,IAQb,IAJA,IAAIK,MAAWxC,IACXyC,EAAA,EACAC,EAAQC,IAEHlG,EAAQ,EAAGA,EAAQM,EAAQN,GAAS,EAAG,CAE9CqB,GACA8E,EAAaC,WAAaC,GACFF,EAAcG,OAASC,IAI/CvF,EAAiCmF,EACjCT,GAAW,EACXI,GAAc,IAGf,IAAIU,EAAQ7E,EAAM3B,GACduC,EAAM1B,EAAQ2F,EAAOxG,GAErByG,EAAOvE,EAAY,KAAOjB,EAAM+B,IAAIT,GAEpCkE,GAECA,EAAKC,GAAGC,EAAaF,EAAKC,EAAGF,GAC7BC,EAAKvG,GAAGyG,EAAaF,EAAKvG,EAAGF,GAE7BiG,GACHD,EAAMY,gBAAgBhD,OAAO6C,EAAKxD,KAGnCwD,EAAOI,GACN5F,EACAiB,EAAYlB,EAAUR,KAAAA,GAAqBiB,KAC3C+E,EACAjE,EACAvC,EACAc,EACAH,EACAC,GAGIsB,IACJuE,EAAKxD,EAAEC,GAAKC,GAGblC,EAAM6F,IAAIvE,EAAKkE,IAGhBV,EAAKvC,IAAIjB,EACV,CAgBA,GAde,IAAXjC,GAAgBS,IAAgBa,IAC/BM,EACHN,EAAWmF,EAAO,IAAMhG,EAAYC,KAEpCY,EAAWmF,EAAO,IAAMhG,EAAaP,KAAAA,GAAqBiB,QACjDyB,GAAKC,GAKZ9B,GAAaf,EAAS,GACzBgB,EAAiBuE,MAGb3D,EACJ,GAAI+D,EAAO,CACV,IAAA,MAAY1D,EAAKkE,KAASxF,EACpB8E,EAAK1B,IAAI9B,IACbyD,EAAMY,gBAAgBpD,IAAIiD,EAAKxD,GAIjC+C,EAAMgB,SAAS7E,GACf6D,EAAMiB,UAAU,OAGjB,MACC9E,IAIEuD,GAEHI,GAAc,GASf9C,EAAInB,KAIwBZ,QAAOwC,YAAa,KAAM7B,YAEvDM,GAAY,EAERb,IACHL,EAASmF,EAEX,CA4PA,SAASU,GAAY5F,EAAOD,EAAQwF,EAAOjE,EAAKvC,EAAOc,EAAWH,EAAOC,GACxE,IAAI8F,EAC8B,KAAhC/F,EAAQuG,GAC4B,KAAjCvG,EAAQwG,GACRC,EAAeZ,GAAO,GAAO,GAC7Ba,EAAOb,GACR,KAEAtG,EAAsC,KAAjCS,EAAQ2G,GAA6BD,EAAOrH,GAAS,KAW9D,MAAO,CACN0G,IACAxG,IACA+C,EAAG8D,EAAO,KACTjG,EAAUE,EAAQ0F,GAAKF,EAAOtG,GAAKF,EAAOY,GAEnC,KACNK,EAAM2C,OAAOrB,MAIjB,CAOA,SAAS0B,GAAKzB,EAAQsB,EAAM9C,GAC3B,GAAKwB,EAAOY,MAUZ,IARA,IAAI1C,EAAO8B,EAAOY,MAAMmB,MACpBgD,EAAM/E,EAAOY,MAAMmE,IAEnBC,EACH1D,GAAwC,KAA/BA,EAAKZ,EAAIC,GACaW,EAAKV,MAAO,MACxCpC,EAEY,OAATN,GAAe,CACrB,IAAI+G,EAAyCC,EAAiBhH,GAG9D,GAFA8G,EAAKG,OAAOjH,GAERA,IAAS6G,EACZ,OAGD7G,EAAO+G,CACR,CACD,CAOA,SAASzD,GAAK5B,EAAOS,EAAMiB,GACb,OAATjB,EACHT,EAAMI,OAAOI,MAAQkB,EAErBjB,EAAKiB,KAAOA,EAGA,OAATA,EACH1B,EAAMI,OAAOuB,KAAOlB,EAEpBiB,EAAKjB,KAAOA,CAEd,CC9oBO,SAAS+E,GAAOlH,EAAMmH,GAE5B,IAGI5E,EAHA6E,OAAK,EAKTC,EAAQ,KACHD,KAAQA,EAAKD,OACZ5E,IACH1C,EAAe0C,GACfA,EAAI,MAGD6E,IACH7E,EAAI8D,EAAO,KACVvE,EAAO,IAA8CsF,EAAIpH,SAK9D,CCOO,SAASsH,GAAKxB,GACpB,MAAqB,iBAAVA,EACHyB,GAAMzB,GAENA,GAAS,EAElB,CAEA,MAAM0B,GAAa,IAAI,sBA+CvB,SAASC,GAAcC,EAAQC,GAAY,GAC1C,IAAIC,EAAYD,EAAY,eAAiB,IACzCE,EAAM,GAEV,IAAA,IAAShG,KAAO6F,EAAQ,CACvB,IAAI5B,EAAQ4B,EAAO7F,GACN,MAATiE,GAA2B,KAAVA,IACpB+B,GAAO,IAAMhG,EAAM,KAAOiE,EAAQ8B,EAEpC,CAEA,OAAOC,CACR,CAMA,SAASC,GAAYC,GACpB,MAAgB,MAAZA,EAAK,IAA0B,MAAZA,EAAK,GACpBA,EAAKC,cAEND,CACR,CCzGO,SAASE,GAAUC,EAAKC,EAASrC,EAAOsC,EAAMC,EAAcC,GAElE,IAAInG,EAAO+F,EAAIK,YAEf,GACC5H,GACAwB,IAAS2D,QACA,IAAT3D,EACC,CACD,IAAIqG,EDkCC,SAAkB1C,EAAOsC,EAAMK,GACrC,IAAIC,EAAqB,MAAT5C,EAAgB,GAAK,GAAKA,EAM1C,GAJIsC,IACHM,EAAYA,EAAYA,EAAY,IAAMN,EAAOA,GAG9CK,EACH,IAAA,IAAS5G,KAAO4G,EACf,GAAIA,EAAW5G,GACd6G,EAAYA,EAAYA,EAAY,IAAM7G,EAAMA,OACjD,GAAW6G,EAAU9I,OAIpB,IAHA,IAAI+I,EAAM9G,EAAIjC,OACV+C,EAAI,GAEAA,EAAI+F,EAAUE,QAAQ/G,EAAKc,KAAO,GAAG,CAC5C,IAAImB,EAAInB,EAAIgG,EAGJ,IAANhG,IAAW6E,GAAWqB,SAASH,EAAU/F,EAAI,KAC7CmB,IAAM4E,EAAU9I,SAAU4H,GAAWqB,SAASH,EAAU5E,IAIzDnB,EAAImB,EAFJ4E,GAAmB,IAAN/F,EAAU,GAAK+F,EAAUI,UAAU,EAAGnG,IAAM+F,EAAUI,UAAUhF,EAAI,EAInF,CAKH,MAAqB,KAAd4E,EAAmB,KAAOA,CAClC,CClEwBK,CAASjD,EAAOsC,EAAME,GAEvC3H,GAAa6H,IAAoBN,EAAIc,aAAa,WAK/B,MAAnBR,EACHN,EAAIe,gBAAgB,SACVd,EACVD,EAAIgB,UAAYV,EAEhBN,EAAIiB,aAAa,QAASX,IAK5BN,EAAIK,YAAczC,CACnB,MAAA,GAAWwC,GAAgBD,IAAiBC,EAC3C,IAAA,IAASzG,KAAOyG,EAAc,CAC7B,IAAIc,IAAed,EAAazG,GAEZ,MAAhBwG,GAAwBe,MAAiBf,EAAaxG,IACzDqG,EAAImB,UAAUC,OAAOzH,EAAKuH,EAE5B,CAGD,OAAOd,CACR,CCzCA,SAASiB,GAAcrB,EAAK/F,EAAO,CAAA,EAAIiB,EAAMoG,GAC5C,IAAA,IAAS3H,KAAOuB,EAAM,CACrB,IAAI0C,EAAQ1C,EAAKvB,GAEbM,EAAKN,KAASiE,IACA,MAAb1C,EAAKvB,GACRqG,EAAIuB,MAAMC,eAAe7H,GAEzBqG,EAAIuB,MAAME,YAAY9H,EAAKiE,EAAO0D,GAGrC,CACD,CAQO,SAASI,GAAU1B,EAAKpC,EAAO+D,EAAaC,GAElD,IAAI3H,EAAO+F,EAAI6B,QAEf,GAAIpJ,GAAawB,IAAS2D,EAAO,CAChC,IAAIkE,EF0FC,SAAkBlE,EAAO4B,GAC/B,GAAIA,EAAQ,CACX,IAGIuC,EAGAC,EANAC,EAAY,GAehB,GAPIC,MAAMC,QAAQ3C,IACjBuC,EAAgBvC,EAAO,GACvBwC,EAAmBxC,EAAO,IAE1BuC,EAAgBvC,EAGb5B,EAAO,CACVA,EAAQwE,OAAOxE,GACbyE,WAAW,qBAAsB,IACjCC,OAGF,IAAIC,GAAS,EACTC,EAAS,EACTC,GAAa,EAEbC,EAAiB,GAEjBX,GACHW,EAAe7G,QAAQ8G,OAAOxF,KAAK4E,GAAea,IAAIhD,KAEnDoC,GACHU,EAAe7G,QAAQ8G,OAAOxF,KAAK6E,GAAkBY,IAAIhD,KAG1D,IAAIiD,EAAc,EACdC,GAAa,EAEjB,MAAMrC,EAAM7C,EAAMlG,OAClB,IAAA,IAASJ,EAAI,EAAGA,EAAImJ,EAAKnJ,IAAK,CAC7B,IAAIyL,EAAInF,EAAMtG,GAoBd,GAlBImL,EACO,MAANM,GAA8B,MAAjBnF,EAAMtG,EAAI,KAC1BmL,GAAa,GAEJF,EACNA,IAAWQ,IACdR,GAAS,GAEM,MAANQ,GAA8B,MAAjBnF,EAAMtG,EAAI,GACjCmL,GAAa,EACG,MAANM,GAAmB,MAANA,EACvBR,EAASQ,EACO,MAANA,EACVP,IACgB,MAANO,GACVP,KAGIC,IAAyB,IAAXF,GAA+B,IAAXC,EACtC,GAAU,MAANO,IAA4B,IAAfD,EAChBA,EAAaxL,OACd,GAAiB,MAANyL,GAAazL,IAAMmJ,EAAM,EAAG,CACtC,IAAmB,IAAfqC,EAAmB,CACtB,IAAIjD,EAAOD,GAAYhC,EAAMgD,UAAUiC,EAAaC,GAAYR,QAE3DI,EAAe/B,SAASd,KAClB,MAANkD,GACHzL,IAID2K,GAAa,IADErE,EAAMgD,UAAUiC,EAAavL,GAAGgL,OACjB,IAEhC,CAEAO,EAAcvL,EAAI,EAClBwL,GAAa,CACd,CAEF,CACD,CAWA,OATIf,IACHE,GAAa1C,GAAcwC,IAGxBC,IACHC,GAAa1C,GAAcyC,GAAkB,IAIzB,MADrBC,EAAYA,EAAUK,QACI,KAAOL,CAClC,CAEA,OAAgB,MAATrE,EAAgB,KAAOwE,OAAOxE,EACtC,CE5LwBoF,CAASpF,EAAOgE,GAEjCnJ,GAAaqJ,IAAoB9B,EAAIc,aAAa,WAC/B,MAAnBgB,EACH9B,EAAIe,gBAAgB,SAEpBf,EAAIuB,MAAM0B,QAAUnB,GAKtB9B,EAAI6B,QAAUjE,CACf,MAAWgE,IACNM,MAAMC,QAAQP,IACjBP,GAAcrB,EAAK2B,IAAc,GAAIC,EAAY,IACjDP,GAAcrB,EAAK2B,IAAc,GAAIC,EAAY,GAAI,cAErDP,GAAcrB,EAAK2B,EAAaC,IAIlC,OAAOA,CACR,CC1CO,SAASsB,GAAcC,EAAQvF,EAAOwF,GAAW,GACvD,GAAID,EAAOE,SAAX,CAEC,GAAa,MAATzF,EACH,OAID,IAAKxE,EAASwE,GACb,OAAO0F,IAIR,IAAA,IAASC,KAAUJ,EAAOK,QACzBD,EAAOE,SAAW7F,EAAM+C,SAAS+C,GAAiBH,GAIpD,KAjBA,CAmBA,IAAKA,KAAUJ,EAAOK,QAAS,CAC9B,IAAIG,EAAeD,GAAiBH,GACpC,GAAIK,EAAGD,EAAc/F,GAEpB,YADA2F,EAAOE,UAAW,EAGpB,CAEKL,QAAsB,IAAVxF,IAChBuF,EAAOU,eAAgB,EAXxB,CAaD,CAUO,SAASC,GAAYX,GAC3B,IAAIY,EAAW,IAAIC,iBAAiB,KAEnCd,GAAcC,EAAQA,EAAOc,WAK9BF,EAASG,QAAQf,EAAQ,CAExBgB,WAAW,EACXC,SAAS,EAITC,YAAY,EACZC,gBAAiB,CAAC,WAGnBC,EAAS,KACRR,EAASS,cAEX,CAQO,SAASC,GAAkBtB,EAAQ/I,EAAK8D,EAAM9D,GACpD,IAAIsK,MAAcC,QACdvB,GAAW,EAEfwB,EAAgCzB,EAAQ,SAAW0B,IAClD,IAEIjH,EAFAkH,EAAQD,EAAW,aAAe,WAItC,GAAI1B,EAAOE,SACVzF,EAAQ,GAAGgF,IAAImC,KAAK5B,EAAO6B,iBAAiBF,GAAQpB,QAC9C,CAEN,IAAIuB,EACH9B,EAAO+B,cAAcJ,IAErB3B,EAAO+B,cAAc,0BACtBtH,EAAQqH,GAAmBvB,GAAiBuB,EAC7C,CAEA/G,EAAIN,GAEkB,OAAlBuH,GACHT,EAAQ9J,IAAIuK,KAKdvL,EAAO,KACN,IAAIgE,EAAQxD,IAEZ,GAAI+I,IAAWiC,SAASC,cAAe,CAEtC,IAAIjI,EAA8BkI,GAAkBH,EAOpD,GAAIT,EAAQjJ,IAAI2B,GACf,MAEF,CAKA,GAHA8F,GAAcC,EAAQvF,EAAOwF,GAGzBA,QAAsB,IAAVxF,EAAqB,CAEpC,IAAIqH,EAAkB9B,EAAO+B,cAAc,YACnB,OAApBD,IACHrH,EAAQ8F,GAAiBuB,GACzB/G,EAAIN,GAEN,CAGAuF,EAAOc,QAAUrG,EACjBwF,GAAW,IAGZU,GAAYX,EACb,CAGA,SAASO,GAAiBH,GAEzB,MAAI,YAAaA,EACTA,EAAOU,QAEPV,EAAO3F,KAEhB,CCpIO,MAAM2H,GAAQC,OAAO,SACfC,GAAQD,OAAO,SAEtBE,GAAoBF,OAAO,qBAC3BG,GAAUH,OAAO,WAQhB,SAASI,GAAsBC,GACrC,GAAKpN,EAAL,CAEA,IAAIqN,GAAkB,EAMlBC,EAAkB,KACrB,IAAID,EAAJ,CAIA,GAHAA,GAAkB,EAGdD,EAAMG,aAAa,SAAU,CAChC,IAAIpI,EAAQiI,EAAMjI,MAClBqI,GAAcJ,EAAO,QAAS,MAC9BA,EAAMjI,MAAQA,CACf,CAEA,GAAIiI,EAAMG,aAAa,WAAY,CAClC,IAAIE,EAAUL,EAAMK,QACpBD,GAAcJ,EAAO,UAAW,MAChCA,EAAMK,QAAUA,CACjB,CAdqB,GAkBtBL,EAAMM,OAASJ,EACfrJ,EAAiBqJ,GACjBK,GA7BgB,CA8BjB,CA6BO,SAASC,GAAYC,EAASJ,GACpC,IAAI7B,EAAakC,GAAeD,GAG/BjC,EAAW6B,WACV7B,EAAW6B,QAEXA,QAAW,KAMbI,EAAQJ,QAAUA,EACnB,CASO,SAASM,GAAaF,EAAS7C,GACjCA,EAGE6C,EAAQN,aAAa,aACzBM,EAAQrF,aAAa,WAAY,IAGlCqF,EAAQvF,gBAAgB,WAE1B,CA8BO,SAASkF,GAAcK,EAASG,EAAW7I,EAAO8I,GACxD,IAAIrC,EAAakC,GAAeD,GAE5B7N,IACH4L,EAAWoC,GAAaH,EAAQxF,aAAa2F,GAG9B,QAAdA,GACc,WAAdA,GACe,SAAdA,GAA6C,SAArBH,EAAQK,WAc/BtC,EAAWoC,MAAgBpC,EAAWoC,GAAa7I,KAErC,YAAd6I,IAEHH,EAAQM,GAAuBhJ,GAGnB,MAATA,EACH0I,EAAQvF,gBAAgB0F,GACG,iBAAV7I,GAAsBiJ,GAAYP,GAAS3F,SAAS8F,GAErEH,EAAQG,GAAa7I,EAErB0I,EAAQrF,aAAawF,EAAW7I,GAElC,CAmSO,SAASkJ,GACfR,EACApH,EACA6H,EAAO,GACPC,EAAQ,GACRC,EAAW,GACXC,EACAC,GAAyB,EACzBT,GAAe,GAEfU,EAAQH,EAAUF,EAAMC,EAAQK,IAE/B,IAAIpN,OAAO,EAGPqN,EAAU,CAAA,EAEVC,EAAiC,WAArBjB,EAAQK,SACpBa,GAAS,EAoCb,GAlCArI,EAAQ,KACP,IAAIjE,EAAOgE,KAAMmI,EAAOzE,IAAIxI,IAExBL,EA/OP,SACCuM,EACArM,EACAiB,EACAgM,EACAC,GAAyB,GAGzB,GAAI1O,GAAa0O,GAA8C,UAApBb,EAAQmB,QAAqB,CACvE,IAAI5B,EAAA,GAC2B,aAAfA,EAAM6B,KAAsB,iBAAmB,kBAE5CxM,GAClB0K,GAAsBC,EAExB,CAEA,IAAIxB,EAAakC,GAAeD,GAE5BqB,EAAoBtD,EAAWqB,IAC/BkC,GAA2BvD,EAAWsB,IAI1C,IAAIkC,EAA8BpP,GAAakP,EAC3CE,GACH3K,GAAc,GAGf,IAAInD,EAAUE,GAAQ,CAAA,EAClB6N,EAAwC,WAApBxB,EAAQmB,QAEhC,IAAA,IAAS9N,KAAOM,EACTN,KAAOuB,IACZA,EAAKvB,GAAO,MAIVuB,EAAK6M,MACR7M,EAAK6M,MAAQ3I,GAAKlE,EAAK6M,QACbb,GAAYhM,EAAKqK,OAC3BrK,EAAK6M,MAAQ,MAGV7M,EAAKuK,MACRvK,EAAKqG,QAALrG,EAAKqG,MAAU,OAGhB,IAAIyG,EAAUnB,GAAYP,GAG1B,IAAA,MAAW3M,KAAOuB,EAAM,CAEvB,IAAI0C,EAAQ1C,EAAKvB,GAIjB,GAAImO,GAA6B,UAARnO,GAA4B,MAATiE,EAY3C0I,EAAQ1I,MAAQ0I,EAAQrC,QAAU,GAClClK,EAAQJ,GAAOiE,OAIhB,GAAY,UAARjE,EAQJ,GAAY,UAARA,EAAJ,CAOA,IAAIsO,EAAalO,EAAQJ,GAGzB,GAAIiE,IAAUqK,QAA0B,IAAVrK,GAAuB0I,EAAQN,aAAarM,GAA1E,CAIAI,EAAQJ,GAAOiE,EAEf,IAAIsK,EAASvO,EAAI,GAAKA,EAAI,GAC1B,GAAe,OAAXuO,EAEJ,GAAe,OAAXA,EAAiB,CAEpB,MAAMC,EAAO,CAAA,EACPC,EAAmB,KAAOzO,EAChC,IAAI0O,EAAa1O,EAAI2O,MAAM,GAC3B,IAAIC,EAAYC,GAAmBH,GAOnC,GALII,EAAiBJ,KACpBA,EAAaA,EAAWC,MAAM,GAAG,GACjCH,EAAKO,SAAU,IAGXH,GAAaN,EAAY,CAK7B,GAAa,MAATrK,EAAe,SAEnB0I,EAAQqC,oBAAoBN,EAAYtO,EAAQqO,GAAmBD,GACnEpO,EAAQqO,GAAoB,IAC7B,CAEA,GAAa,MAATxK,EACH,GAAK2K,EAYJjC,EAAQ,KAAK+B,KAAgBzK,EAC7BgL,GAAS,CAACP,QAbK,CAKf,IAASQ,EAAT,SAAgBC,GACf/O,EAAQJ,GAAKoL,KAAKgE,KAAMD,EACzB,EAEA/O,EAAQqO,GAAoBY,EAAaX,EAAY/B,EAASuC,EAAQV,EACvE,MAKUI,IAEVjC,EAAQ,KAAK+B,UAAgB,EAE/B,MAAA,GAAmB,UAAR1O,EAEVsM,GAAcK,EAAS3M,EAAKiE,QAC7B,GAAmB,cAARjE,EACVsP,EAAsC3C,EAAU4C,QAAQtL,SACzD,GAAY+J,GAA8B,YAARhO,IAA8B,UAARA,GAA4B,MAATiE,GAI3E,GAAmB,aAARjE,GAAsBmO,EAChCtB,GAA+CF,EAAU1I,OACnD,CACN,IAAIiC,EAAOlG,EACNiO,IACJ/H,EAAOsJ,GAAoBtJ,IAG5B,IAAIuJ,EAAsB,iBAATvJ,GAAoC,mBAATA,EAE5C,GAAa,MAATjC,GAAkB+J,GAAsByB,EAuB3CA,GACCpB,EAAQrH,SAASd,KAAU8H,GAAsC,iBAAV/J,IAGxD0I,EAAQzG,GAAQjC,EAEZiC,KAAQwE,IAAYA,EAAWxE,GAAQwJ,IAChB,mBAAVzL,GACjBqI,GAAcK,EAASzG,EAAMjC,QA5B7B,GAFAyG,EAAW1K,GAAO,KAEL,UAATkG,GAA6B,YAATA,EAAoB,CAE3C,IAAIgG,EAAAA,EACJ,MAAMyD,OAAuB,IAATrP,EACpB,GAAa,UAAT4F,EAAkB,CACrB,IAAI0J,EAAW1D,EAAM2D,aACrB3D,EAAM9E,gBAAgBlB,GACtBgG,EAAM2D,aAAeD,EAErB1D,EAAMjI,MAAQiI,EAAM5B,QAAUqF,EAAcC,EAAW,IACxD,KAAO,CACN,IAAIA,EAAW1D,EAAM4D,eACrB5D,EAAM9E,gBAAgBlB,GACtBgG,EAAM4D,eAAiBF,EACvB1D,EAAMK,UAAUoD,GAAcC,CAC/B,CACD,MACCjD,EAAQvF,gBAAgBpH,EAa3B,MA5CC2M,EAAQ1I,MAAQ0I,EAAQrC,QAAUrG,CA1DnC,CAPA,MAJC8D,GAAU4E,EAAS1I,EAAO3D,IAAOwL,IAAQvK,EAAKuK,KAC9C1L,EAAQJ,GAAOiE,EACf7D,EAAQ0L,IAASvK,EAAKuK,SATtB1F,GAAUuG,EAD6B,iCAAzBA,EAAQoD,aACM9L,EAAOsJ,EAAUjN,IAAOsL,IAAQrK,EAAKqK,KACjExL,EAAQJ,GAAOiE,EACf7D,EAAQwL,IAASrK,EAAKqK,GAuHxB,CAMA,OAJIsC,GACH3K,GAAc,GAGRnD,CACR,CAmCiB4P,CACbrD,EACArM,EACAiB,EACAgM,EACAC,EACAT,GAGGc,GAAUD,GAAa,UAAWrM,GACrCgI,GAAgDoD,EAAUpL,EAAK0C,OAGhE,IAAA,IAASgM,KAAUjH,OAAOkH,sBAAsBvC,GAC1CpM,EAAK0O,IAASjS,EAAe2P,EAAQsC,IAG3C,IAAA,IAASA,KAAUjH,OAAOkH,sBAAsB3O,GAAO,CACtD,IAAI4O,EAAI5O,EAAK0O,GAETA,EAAOG,cAAgBC,GAAoB/P,GAAQ6P,IAAM7P,EAAK2P,KAC7DtC,EAAQsC,IAASjS,EAAe2P,EAAQsC,IAC5CtC,EAAQsC,GAAUzL,EAAO,IAAMa,GAAOsH,EAAS,IAAMwD,KAGtD/P,EAAQ6P,GAAUE,CACnB,CAEA7P,EAAOF,IAGJwN,EAAW,CACd,IAAIpE,EAAA,EAEJvJ,EAAO,KACNsJ,GAAcC,EAAqDlJ,EAAM2D,OAAO,GAChFkG,GAAYX,IAEd,CAEAqE,GAAS,GAEX,CAMA,SAASjB,GAAeD,GACvB,OAECA,EAAQ2D,eAAR3D,EAAQ2D,aAAiB,CACxBvE,CAACA,IAAoBY,EAAQK,SAAShG,SAAS,KAC/CgF,CAACA,IAAUW,EAAQoD,eAAiBQ,GAGvC,CAGA,IAAIC,OAAoB7R,IAGxB,SAASuO,GAAYP,GACpB,IAKI8D,EALAC,EAAY/D,EAAQxF,aAAa,OAASwF,EAAQK,SAClDqB,EAAUmC,GAAc/P,IAAIiQ,GAChC,GAAIrC,EAAS,OAAOA,EACpBmC,GAAcjM,IAAImM,EAAYrC,EAAU,IAQxC,IALA,IAAIsC,EAAQhE,EACRiE,EAAgBC,QAAQC,UAIrBF,IAAkBD,GAAO,CAG/B,IAAA,IAAS3Q,KAFTyQ,EAAcM,EAAgBJ,GAGzBF,EAAYzQ,GAAKuE,KACpB8J,EAAQnM,KAAKlC,GAIf2Q,EAAQK,EAAiBL,EAC1B,CAEA,OAAOtC,CACR","x_google_ignoreList":[0,1,2,3,4,5,6]}