{"version":3,"file":"CGLmHr_6.js","sources":["../../../../../../node_modules/.pnpm/svelte@5.46.0/node_modules/svelte/src/internal/client/dom/blocks/each.js"],"sourcesContent":["/** @import { EachItem, EachOutroGroup, EachState, Effect, EffectNodes, MaybeSource, Source, TemplateNode, TransitionManager, Value } from '#client' */\n/** @import { Batch } from '../../reactivity/batch.js'; */\nimport {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_ITEM_IMMUTABLE,\n\tEACH_ITEM_REACTIVE,\n\tHYDRATION_END,\n\tHYDRATION_START_ELSE\n} from '../../../../constants.js';\nimport {\n\thydrate_next,\n\thydrate_node,\n\thydrating,\n\tread_hydration_instruction,\n\tskip_nodes,\n\tset_hydrate_node,\n\tset_hydrating\n} from '../hydration.js';\nimport {\n\tclear_text_content,\n\tcreate_text,\n\tget_first_child,\n\tget_next_sibling,\n\tshould_defer_append\n} from '../operations.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, internal_set } from '../../reactivity/sources.js';\nimport { array_from, is_array } from '../../../shared/utils.js';\nimport { COMMENT_NODE, EFFECT_OFFSCREEN, INERT } from '#client/constants';\nimport { queue_micro_task } from '../task.js';\nimport { get } from '../../runtime.js';\nimport { DEV } from 'esm-env';\nimport { derived_safe_equal } from '../../reactivity/deriveds.js';\nimport { current_batch } from '../../reactivity/batch.js';\n\n// When making substantive changes to this file, validate them with the each block stress test:\n// https://svelte.dev/playground/1972b2cf46564476ad8c8c6405b23b7b\n// This test also exists in this repo, as `packages/svelte/tests/manual/each-stress-test`\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {EachState} state\n * @param {Effect[]} to_destroy\n * @param {null | Node} controlled_anchor\n */\nfunction pause_effects(state, to_destroy, controlled_anchor) {\n\t/** @type {TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = to_destroy.length;\n\n\t/** @type {EachOutroGroup} */\n\tvar group;\n\tvar remaining = to_destroy.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tlet effect = to_destroy[i];\n\n\t\tpause_effect(\n\t\t\teffect,\n\t\t\t() => {\n\t\t\t\tif (group) {\n\t\t\t\t\tgroup.pending.delete(effect);\n\t\t\t\t\tgroup.done.add(effect);\n\n\t\t\t\t\tif (group.pending.size === 0) {\n\t\t\t\t\t\tvar groups = /** @type {Set<EachOutroGroup>} */ (state.outrogroups);\n\n\t\t\t\t\t\tdestroy_effects(array_from(group.done));\n\t\t\t\t\t\tgroups.delete(group);\n\n\t\t\t\t\t\tif (groups.size === 0) {\n\t\t\t\t\t\t\tstate.outrogroups = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tremaining -= 1;\n\t\t\t\t}\n\t\t\t},\n\t\t\tfalse\n\t\t);\n\t}\n\n\tif (remaining === 0) {\n\t\t// If we're in a controlled each block (i.e. the block is the only child of an\n\t\t// element), and we are removing all items, _and_ there are no out transitions,\n\t\t// we can use the fast path — emptying the element and replacing the anchor\n\t\tvar fast_path = transitions.length === 0 && controlled_anchor !== null;\n\n\t\tif (fast_path) {\n\t\t\tvar anchor = /** @type {Element} */ (controlled_anchor);\n\t\t\tvar parent_node = /** @type {Element} */ (anchor.parentNode);\n\n\t\t\tclear_text_content(parent_node);\n\t\t\tparent_node.append(anchor);\n\n\t\t\tstate.items.clear();\n\t\t}\n\n\t\tdestroy_effects(to_destroy, !fast_path);\n\t} else {\n\t\tgroup = {\n\t\t\tpending: new Set(to_destroy),\n\t\t\tdone: new Set()\n\t\t};\n\n\t\t(state.outrogroups ??= new Set()).add(group);\n\t}\n}\n\n/**\n * @param {Effect[]} to_destroy\n * @param {boolean} remove_dom\n */\nfunction destroy_effects(to_destroy, remove_dom = true) {\n\t// TODO only destroy effects if no pending batch needs them. otherwise,\n\t// just re-add the `EFFECT_OFFSCREEN` flag\n\tfor (var i = 0; i < to_destroy.length; i++) {\n\t\tdestroy_effect(to_destroy[i], remove_dom);\n\t}\n}\n\n/** @type {TemplateNode} */\nvar offscreen_anchor;\n\n/**\n * @template V\n * @param {Element | Comment} node The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: MaybeSource<V>, index: MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(node, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\tvar anchor = node;\n\n\t/** @type {Map<any, EachItem>} */\n\tvar items = new Map();\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (node);\n\n\t\tanchor = hydrating\n\t\t\t? set_hydrate_node(get_first_child(parent_node))\n\t\t\t: parent_node.appendChild(create_text());\n\t}\n\n\tif (hydrating) {\n\t\thydrate_next();\n\t}\n\n\t/** @type {Effect | null} */\n\tvar fallback = null;\n\n\t// TODO: ideally we could use derived for runes mode but because of the ability\n\t// to use a store which can be mutated, we can't do that here as mutating a store\n\t// will still result in the collection array being the same from the store\n\tvar each_array = derived_safe_equal(() => {\n\t\tvar collection = get_collection();\n\n\t\treturn is_array(collection) ? collection : collection == null ? [] : array_from(collection);\n\t});\n\n\t/** @type {V[]} */\n\tvar array;\n\n\tvar first_run = true;\n\n\tfunction commit() {\n\t\tstate.fallback = fallback;\n\t\treconcile(state, array, anchor, flags, get_key);\n\n\t\tif (fallback !== null) {\n\t\t\tif (array.length === 0) {\n\t\t\t\tif ((fallback.f & EFFECT_OFFSCREEN) === 0) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback.f ^= EFFECT_OFFSCREEN;\n\t\t\t\t\tmove(fallback, null, anchor);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\t// TODO only null out if no pending batch needs it,\n\t\t\t\t\t// otherwise re-add `fallback.fragment` and move the\n\t\t\t\t\t// effect into it\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tvar effect = block(() => {\n\t\tarray = /** @type {V[]} */ (get(each_array));\n\t\tvar length = array.length;\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = read_hydration_instruction(anchor) === HYDRATION_START_ELSE;\n\n\t\t\tif (is_else !== (length === 0)) {\n\t\t\t\t// hydration mismatch — remove the server-rendered DOM and start over\n\t\t\t\tanchor = skip_nodes();\n\n\t\t\t\tset_hydrate_node(anchor);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\tvar keys = new Set();\n\t\tvar batch = /** @type {Batch} */ (current_batch);\n\t\tvar defer = should_defer_append();\n\n\t\tfor (var index = 0; index < length; index += 1) {\n\t\t\tif (\n\t\t\t\thydrating &&\n\t\t\t\thydrate_node.nodeType === COMMENT_NODE &&\n\t\t\t\t/** @type {Comment} */ (hydrate_node).data === HYDRATION_END\n\t\t\t) {\n\t\t\t\t// The server rendered fewer items than expected,\n\t\t\t\t// so break out and continue appending non-hydrated items\n\t\t\t\tanchor = /** @type {Comment} */ (hydrate_node);\n\t\t\t\tmismatch = true;\n\t\t\t\tset_hydrating(false);\n\t\t\t}\n\n\t\t\tvar value = array[index];\n\t\t\tvar key = get_key(value, index);\n\n\t\t\tvar item = first_run ? null : items.get(key);\n\n\t\t\tif (item) {\n\t\t\t\t// update before reconciliation, to trigger any async updates\n\t\t\t\tif (item.v) internal_set(item.v, value);\n\t\t\t\tif (item.i) internal_set(item.i, index);\n\n\t\t\t\tif (defer) {\n\t\t\t\t\tbatch.skipped_effects.delete(item.e);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\titem = create_item(\n\t\t\t\t\titems,\n\t\t\t\t\tfirst_run ? anchor : (offscreen_anchor ??= create_text()),\n\t\t\t\t\tvalue,\n\t\t\t\t\tkey,\n\t\t\t\t\tindex,\n\t\t\t\t\trender_fn,\n\t\t\t\t\tflags,\n\t\t\t\t\tget_collection\n\t\t\t\t);\n\n\t\t\t\tif (!first_run) {\n\t\t\t\t\titem.e.f |= EFFECT_OFFSCREEN;\n\t\t\t\t}\n\n\t\t\t\titems.set(key, item);\n\t\t\t}\n\n\t\t\tkeys.add(key);\n\t\t}\n\n\t\tif (length === 0 && fallback_fn && !fallback) {\n\t\t\tif (first_run) {\n\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t} else {\n\t\t\t\tfallback = branch(() => fallback_fn((offscreen_anchor ??= create_text())));\n\t\t\t\tfallback.f |= EFFECT_OFFSCREEN;\n\t\t\t}\n\t\t}\n\n\t\t// remove excess nodes\n\t\tif (hydrating && length > 0) {\n\t\t\tset_hydrate_node(skip_nodes());\n\t\t}\n\n\t\tif (!first_run) {\n\t\t\tif (defer) {\n\t\t\t\tfor (const [key, item] of items) {\n\t\t\t\t\tif (!keys.has(key)) {\n\t\t\t\t\t\tbatch.skipped_effects.add(item.e);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbatch.oncommit(commit);\n\t\t\t\tbatch.ondiscard(() => {\n\t\t\t\t\t// TODO presumably we need to do something here?\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tcommit();\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\n\t\t// When we mount the each block for the first time, the collection won't be\n\t\t// connected to this effect as the effect hasn't finished running yet and its deps\n\t\t// won't be assigned. However, it's possible that when reconciling the each block\n\t\t// that a mutation occurred and it's made the collection MAYBE_DIRTY, so reading the\n\t\t// collection again can provide consistency to the reactive graph again as the deriveds\n\t\t// will now be `CLEAN`.\n\t\tget(each_array);\n\t});\n\n\t/** @type {EachState} */\n\tvar state = { effect, flags, items, outrogroups: null, fallback };\n\n\tfirst_run = false;\n\n\tif (hydrating) {\n\t\tanchor = hydrate_node;\n\t}\n}\n\n/**\n * Add, remove, or reorder items output by an each block as its input changes\n * @template V\n * @param {EachState} state\n * @param {Array<V>} array\n * @param {Element | Comment | Text} anchor\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @returns {void}\n */\nfunction reconcile(state, array, anchor, flags, get_key) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar current = state.effect.first;\n\n\t/** @type {undefined | Set<Effect>} */\n\tvar seen;\n\n\t/** @type {Effect | null} */\n\tvar prev = null;\n\n\t/** @type {undefined | Set<Effect>} */\n\tvar to_animate;\n\n\t/** @type {Effect[]} */\n\tvar matched = [];\n\n\t/** @type {Effect[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {Effect | undefined} */\n\tvar effect;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\teffect = /** @type {EachItem} */ (items.get(key)).e;\n\n\t\t\t// offscreen == coming in now, no animation in that case,\n\t\t\t// else this would happen https://github.com/sveltejs/svelte/issues/17181\n\t\t\tif ((effect.f & EFFECT_OFFSCREEN) === 0) {\n\t\t\t\teffect.nodes?.a?.measure();\n\t\t\t\t(to_animate ??= new Set()).add(effect);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\n\t\teffect = /** @type {EachItem} */ (items.get(key)).e;\n\n\t\tif (state.outrogroups !== null) {\n\t\t\tfor (const group of state.outrogroups) {\n\t\t\t\tgroup.pending.delete(effect);\n\t\t\t\tgroup.done.delete(effect);\n\t\t\t}\n\t\t}\n\n\t\tif ((effect.f & EFFECT_OFFSCREEN) !== 0) {\n\t\t\teffect.f ^= EFFECT_OFFSCREEN;\n\n\t\t\tif (effect === current) {\n\t\t\t\tmove(effect, null, anchor);\n\t\t\t} else {\n\t\t\t\tvar next = prev ? prev.next : current;\n\n\t\t\t\tif (effect === state.effect.last) {\n\t\t\t\t\tstate.effect.last = effect.prev;\n\t\t\t\t}\n\n\t\t\t\tif (effect.prev) effect.prev.next = effect.next;\n\t\t\t\tif (effect.next) effect.next.prev = effect.prev;\n\t\t\t\tlink(state, prev, effect);\n\t\t\t\tlink(state, effect, next);\n\n\t\t\t\tmove(effect, next, anchor);\n\t\t\t\tprev = effect;\n\n\t\t\t\tmatched = [];\n\t\t\t\tstashed = [];\n\n\t\t\t\tcurrent = prev.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif ((effect.f & INERT) !== 0) {\n\t\t\tresume_effect(effect);\n\t\t\tif (is_animated) {\n\t\t\t\teffect.nodes?.a?.unfix();\n\t\t\t\t(to_animate ??= new Set()).delete(effect);\n\t\t\t}\n\t\t}\n\n\t\tif (effect !== current) {\n\t\t\tif (seen !== undefined && seen.has(effect)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(state, a.prev, b.next);\n\t\t\t\t\tlink(state, prev, a);\n\t\t\t\t\tlink(state, b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(effect);\n\t\t\t\t\tmove(effect, current, anchor);\n\n\t\t\t\t\tlink(state, effect.prev, effect.next);\n\t\t\t\t\tlink(state, effect, prev === null ? state.effect.first : prev.next);\n\t\t\t\t\tlink(state, prev, effect);\n\n\t\t\t\t\tprev = effect;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current !== effect) {\n\t\t\t\t(seen ??= new Set()).add(current);\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tif ((effect.f & EFFECT_OFFSCREEN) === 0) {\n\t\t\tmatched.push(effect);\n\t\t}\n\n\t\tprev = effect;\n\t\tcurrent = effect.next;\n\t}\n\n\tif (state.outrogroups !== null) {\n\t\tfor (const group of state.outrogroups) {\n\t\t\tif (group.pending.size === 0) {\n\t\t\t\tdestroy_effects(array_from(group.done));\n\t\t\t\tstate.outrogroups?.delete(group);\n\t\t\t}\n\t\t}\n\n\t\tif (state.outrogroups.size === 0) {\n\t\t\tstate.outrogroups = null;\n\t\t}\n\t}\n\n\tif (current !== null || seen !== undefined) {\n\t\t/** @type {Effect[]} */\n\t\tvar to_destroy = [];\n\n\t\tif (seen !== undefined) {\n\t\t\tfor (effect of seen) {\n\t\t\t\tif ((effect.f & INERT) === 0) {\n\t\t\t\t\tto_destroy.push(effect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\twhile (current !== null) {\n\t\t\t// If the each block isn't inert, then inert effects are currently outroing and will be removed once the transition is finished\n\t\t\tif ((current.f & INERT) === 0 && current !== state.fallback) {\n\t\t\t\tto_destroy.push(current);\n\t\t\t}\n\n\t\t\tcurrent = current.next;\n\t\t}\n\n\t\tvar destroy_length = to_destroy.length;\n\n\t\tif (destroy_length > 0) {\n\t\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\t\tif (is_animated) {\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].nodes?.a?.measure();\n\t\t\t\t}\n\n\t\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\t\tto_destroy[i].nodes?.a?.fix();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpause_effects(state, to_destroy, controlled_anchor);\n\t\t}\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tif (to_animate === undefined) return;\n\t\t\tfor (effect of to_animate) {\n\t\t\t\teffect.nodes?.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @template V\n * @param {Map<any, EachItem>} items\n * @param {Node} anchor\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | Source<V>, index: number | Value<number>, collection: () => V[]) => void} render_fn\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @returns {EachItem}\n */\nfunction create_item(items, anchor, value, key, index, render_fn, flags, get_collection) {\n\tvar v =\n\t\t(flags & EACH_ITEM_REACTIVE) !== 0\n\t\t\t? (flags & EACH_ITEM_IMMUTABLE) === 0\n\t\t\t\t? mutable_source(value, false, false)\n\t\t\t\t: source(value)\n\t\t\t: null;\n\n\tvar i = (flags & EACH_INDEX_REACTIVE) !== 0 ? source(index) : null;\n\n\tif (DEV && v) {\n\t\t// For tracing purposes, we need to link the source signal we create with the\n\t\t// collection + index so that tracing works as intended\n\t\tv.trace = () => {\n\t\t\t// eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\t\t\tget_collection()[i?.v ?? index];\n\t\t};\n\t}\n\n\treturn {\n\t\tv,\n\t\ti,\n\t\te: branch(() => {\n\t\t\trender_fn(anchor, v ?? value, i ?? index, get_collection);\n\n\t\t\treturn () => {\n\t\t\t\titems.delete(key);\n\t\t\t};\n\t\t})\n\t};\n}\n\n/**\n * @param {Effect} effect\n * @param {Effect | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(effect, next, anchor) {\n\tif (!effect.nodes) return;\n\n\tvar node = effect.nodes.start;\n\tvar end = effect.nodes.end;\n\n\tvar dest =\n\t\tnext && (next.f & EFFECT_OFFSCREEN) === 0\n\t\t\t? /** @type {EffectNodes} */ (next.nodes).start\n\t\t\t: anchor;\n\n\twhile (node !== null) {\n\t\tvar next_node = /** @type {TemplateNode} */ (get_next_sibling(node));\n\t\tdest.before(node);\n\n\t\tif (node === end) {\n\t\t\treturn;\n\t\t}\n\n\t\tnode = next_node;\n\t}\n}\n\n/**\n * @param {EachState} state\n * @param {Effect | null} prev\n * @param {Effect | null} next\n */\nfunction link(state, prev, next) {\n\tif (prev === null) {\n\t\tstate.effect.first = next;\n\t} else {\n\t\tprev.next = next;\n\t}\n\n\tif (next === null) {\n\t\tstate.effect.last = prev;\n\t} else {\n\t\tnext.prev = prev;\n\t}\n}\n"],"names":["index","_","i","destroy_effects","to_destroy","remove_dom","length","destroy_effect","offscreen_anchor","each","node","flags","get_collection","get_key","render_fn","fallback_fn","anchor","items","Map","EACH_IS_CONTROLLED","parent_node","hydrating","set_hydrate_node","get_first_child","appendChild","create_text","hydrate_next","array","fallback","each_array","derived_safe_equal","collection","is_array","array_from","first_run","commit","state","seen","to_animate","key","effect","is_animated","EACH_IS_ANIMATED","current","first","prev","matched","stashed","get","e","f","EFFECT_OFFSCREEN","nodes","a","measure","Set","add","outrogroups","group","pending","delete","done","next","last","link","move","INERT","resume_effect","unfix","has","j","start","b","push","size","destroy_length","controlled_anchor","fix","remaining","pause_effect","groups","fast_path","clear_text_content","append","clear","pause_effects","queue_micro_task","apply","reconcile","block","mismatch","read_hydration_instruction","HYDRATION_START_ELSE","skip_nodes","set_hydrating","keys","batch","defer","should_defer_append","hydrate_node","nodeType","COMMENT_NODE","data","HYDRATION_END","value","item","v","internal_set","skipped_effects","create_item","set","branch","oncommit","ondiscard","EACH_ITEM_REACTIVE","EACH_ITEM_IMMUTABLE","mutable_source","source","EACH_INDEX_REACTIVE","end","dest","next_node","get_next_sibling","before"],"mappings":"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","x_google_ignoreList":[0]}