import fs from 'fs';
import path from 'path';
import { z } from 'zod';
import { VocabularyCollectionSchema } from '../src/lib/schemas/vocabulary.js';

// Cyrillic detection regex
const cyrillicPattern = /[\u0400-\u04FF]/;

async function main() {
  const inputPath = path.join(process.cwd(), 'data/vocabulary.json');
  const outputPath = path.join(process.cwd(), 'static/data/vocabulary.json');

  console.log(`Reading from ${inputPath}...`);
  const rawData = fs.readFileSync(inputPath, 'utf-8');
  const data = JSON.parse(rawData);

  // Fix swapped fields
  console.log('Checking for swapped fields...');
  let swappedCount = 0;
  
  if (data.items && Array.isArray(data.items)) {
    data.items = data.items.map((item: any) => {
      // Check if german field contains Cyrillic
      if (item.german && cyrillicPattern.test(item.german)) {
        // Check if bulgarian field contains Latin (and NOT Cyrillic)
        if (item.bulgarian && !cyrillicPattern.test(item.bulgarian)) {
          // Swap them
          const temp = item.german;
          item.german = item.bulgarian;
          item.bulgarian = temp;
          swappedCount++;
        }
      }
      return item;
    });
  }

  console.log(`Fixed ${swappedCount} items with swapped languages.`);

  // Validate against schema
  console.log('Validating against schema...');
  try {
    const validData = VocabularyCollectionSchema.parse(data);
    console.log('Validation SUCCESS!');
    
    // Write fixed data
    console.log(`Writing fixed data to ${outputPath}...`);
    fs.writeFileSync(outputPath, JSON.stringify(validData, null, 2));
    console.log('Done.');
    
  } catch (error) {
    console.error('Validation FAILED:');
    if (error instanceof z.ZodError) {
      error.errors.forEach(err => {
        console.error(`- Path: ${err.path.join('.')}, Message: ${err.message}`);
      });
    } else {
      console.error(error);
    }
    // Write anyway to inspect? No, better to fail.
    process.exit(1);
  }
}

main().catch(console.error);