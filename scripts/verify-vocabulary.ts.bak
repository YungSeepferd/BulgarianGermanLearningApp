import { readFile, writeFile } from 'node:fs/promises';
import { VocabularyItemSchema } from '../src/lib/schemas/vocabulary.js';
import { ProcessingVocabularyItem, VocabularyVerificationCheck, VocabularyIssue, VocabularyVerificationReport } from './types/vocabulary-types';

/**
 * Comprehensive vocabulary data verification system
 * with detailed error reporting and automatic fixes
 */
class VocabularyVerifier {
  private issues: VocabularyIssue[] = [];

  // Verification checks with automatic correction capabilities
  private checks: VocabularyVerificationCheck[] = [
    {
      name: 'ID Uniqueness',
      test: (items: ProcessingVocabularyItem[]) => {
        const idMap = new Map<string, ProcessingVocabularyItem>();
        return items.filter(item => {
          if (idMap.has(item.id)) {
            this.issues.push({
              id: item.id,
              type: 'duplicate_id',
              message: `Duplicate ID found: ${item.id}`,
              severity: 'critical',
              data: { existing: idMap.get(item.id), duplicate: item }
            });
            return false;
          }
          idMap.set(item.id, item);
          return true;
        });
      },
      fix: (items: ProcessingVocabularyItem[]) => {
        const idMap = new Map<string, ProcessingVocabularyItem>();
        return items.map(item => {
          if (idMap.has(item.id)) {
            const newId = `${item.id}-${Date.now()}-${Math.random().toString(36).substring(2, 7)}`;
            this.issues.push({
              id: item.id,
              type: 'duplicate_id_fixed',
              message: `Duplicate ID fixed: ${item.id} ‚Üí ${newId}`,
              severity: 'critical',
              data: { oldId: item.id, newId }
            });
            return { ...item, id: newId };
          }
          idMap.set(item.id, item);
          return item;
        });
      }
    },
    {
      name: 'partOfSpeech Consistency',
      test: (items: ProcessingVocabularyItem[]) => {
        const posMap = new Map<string, Set<string>>();
        items.forEach(item => {
          const baseId = item.id.replace(/_\d+$/, '');
          if (!posMap.has(baseId)) posMap.set(baseId, new Set());
          posMap.get(baseId)?.add(item.partOfSpeech);
        });

        return items.filter(item => {
          const baseId = item.id.replace(/_\d+$/, '');
          const posSet = posMap.get(baseId) || new Set();
          if (posSet.size > 2) { // Allow noun + adjective pairs
            this.issues.push({
              id: item.id,
              type: 'inconsistent_pos',
              message: `Inconsistent partOfSpeech for ${baseId}: ${Array.from(posSet).join(', ')}`,
              severity: 'high',
              data: { baseId, posSet: Array.from(posSet) }
            });
            return false;
          }
          return true;
        });
      },
      fix: (items: ProcessingVocabularyItem[]) => {
        const posRules: Record<string, string[]> = {
          '–±—ä—Ä–∑': ['adjective'],
          '–±–æ–ª–µ–Ω': ['adjective'],
          '–≤–µ—Å–µ–ª': ['adjective'],
          '–∞–∑': ['pronoun'],
          '–∞–∫–æ': ['conjunction'],
          '–≤': ['preposition']
        };

        return items.map(item => {
          const baseId = item.id.replace(/_\d+$/, '');
          if (posRules[baseId] && !posRules[baseId].includes(item.partOfSpeech)) {
            this.issues.push({
              id: item.id,
              type: 'pos_fixed',
              message: `Fixed partOfSpeech for ${item.id}: ${item.partOfSpeech} ‚Üí ${posRules[baseId][0]}`,
              severity: 'high',
              data: { oldPos: item.partOfSpeech, newPos: posRules[baseId][0] }
            });
            return { ...item, partOfSpeech: posRules[baseId][0] };
          }
          return item;
        });
      }
    },
    {
      name: 'Example Completeness',
      test: (items: ProcessingVocabularyItem[]) => {
        return items.filter(item => {
          if (!item.metadata?.examples || item.metadata.examples.length === 0) {
            this.issues.push({
              id: item.id,
              type: 'missing_examples',
              message: `Missing examples for ${item.id}`,
              severity: 'medium'
            });
            return false;
          }
          return true;
        });
      },
      fix: (items: ProcessingVocabularyItem[]) => {
        const exampleTemplates = {
          adjective: [
            { german: 'Er ist {german}.', bulgarian: '–¢–æ–π –µ {bulgarian}.' },
            { german: 'Sie ist {german}.', bulgarian: '–¢—è –µ {bulgarian}.' },
            { german: 'Es ist {german}.', bulgarian: '–¢–æ –µ {bulgarian}.' }
          ],
          noun: [
            { german: 'Ich habe {article} {german}.', bulgarian: '–ò–º–∞–º {bulgarian}.' },
            { german: 'Das ist {article} {german}.', bulgarian: '–¢–æ–≤–∞ –µ {bulgarian}.' }
          ],
          verb: [
            { german: 'Ich {german} jeden Tag.', bulgarian: '–ê–∑ {bulgarian} –≤—Å–µ–∫–∏ –¥–µ–Ω.' },
            { german: 'Er {german} jetzt.', bulgarian: '–¢–æ–π {bulgarian} —Å–µ–≥–∞.' }
          ]
        };

        return items.map(item => {
          if (!item.metadata?.examples || item.metadata.examples.some((e: any) => !e.german)) {
            const templates = exampleTemplates[item.partOfSpeech as keyof typeof exampleTemplates]
              || exampleTemplates.noun;
            const examples = templates.map(template => ({
              german: template.german
                .replace('{german}', item.german)
                .replace('{article}', this.getGermanArticle(item.german)),
              bulgarian: template.bulgarian.replace('{bulgarian}', item.bulgarian),
              context: 'Generated example'
            }));

            this.issues.push({
              id: item.id,
              type: 'examples_generated',
              message: `Generated ${examples.length} examples for ${item.id}`,
              severity: 'medium',
              data: { examples }
            });

            return {
              ...item,
              metadata: {
                ...item.metadata,
                examples
              }
            };
          }
          return item;
        });
      }
    },
    {
      name: 'German Translation Quality',
      test: (items: ProcessingVocabularyItem[]) => {
        const badPatterns = [
          /wenn,\s*falls/i,
          /Sofia\/hier/i,
          /Ich\s+bin\s+\w+\s+\w+/i,
          /dem\s+\w+\s+\w+/i,
          /\/\// // Double slashes
        ];

        return items.filter(item => {
          if (!item.metadata?.examples) return true;

          const hasBadExamples = item.metadata.examples.some((example: any) => {
            return badPatterns.some(pattern => pattern.test(example.german));
          });

          if (hasBadExamples) {
            this.issues.push({
              id: item.id,
              type: 'poor_translation',
              message: `Poor German translation quality in ${item.id}`,
              severity: 'high',
              data: {
                examples: item.metadata.examples.filter((example: any) =>
                  badPatterns.some(pattern => pattern.test(example.german))
                )
              }
            });
            return false;
          }
          return true;
        });
      },
      fix: (items: ProcessingVocabularyItem[]) => {
        // This would be enhanced with proper translation logic
        // For now, we'll just flag these for manual review
        return items;
      }
    }
  ];

  private getGermanArticle(word: string): string {
    // Simple heuristic for German articles
    const firstLetter = word.charAt(0).toLowerCase();
    if (['a', 'o', 'u'].includes(firstLetter)) return 'der';
    if (['e', 'i'].includes(firstLetter)) return 'die';
    return 'das';
  }

  async verify(filePath: string, fix = false): Promise<void> {
    const data = JSON.parse(await readFile(filePath, 'utf-8')) as { items: ProcessingVocabularyItem[] };
    let items = data.items;

    console.log(`üîç Verifying ${items.length} vocabulary items...`);

    // Run tests
    this.checks.forEach(check => {
      items = check.test(items);
    });

    // Generate report
    const report: VocabularyVerificationReport = {
      timestamp: new Date().toISOString(),
      totalItems: data.items.length,
      verifiedItems: items.length,
      issues: this.issues,
      passRate: `${Math.round((items.length / data.items.length) * 100)}%`
    };

    await writeFile(
      'data/vocabulary-verification-report.json',
      JSON.stringify(report, null, 2)
    );

    console.log(`‚úÖ Verification complete. Report saved to data/vocabulary-verification-report.json`);
    console.log(`üìä Pass rate: ${report.passRate}`);
    console.log(`‚ö†Ô∏è  Issues found: ${this.issues.length}`);

    if (fix) {
      console.log('üîß Applying automatic fixes...');
      let fixedItems = [...items];

      this.checks.forEach(check => {
        if (check.fix) {
          fixedItems = check.fix(fixedItems);
        }
      });

      // Update the original file with fixes
      const fixedData = { ...data, items: fixedItems };
      await writeFile(filePath, JSON.stringify(fixedData, null, 2));

      console.log(`üíæ Fixed data saved to ${filePath}`);
    }
  }
}

// CLI Usage
const verifier = new VocabularyVerifier();
const [,, filePath, fixFlag] = process.argv;
verifier.verify(filePath as string, fixFlag === '--fix')
  .catch((error: unknown) => {
    console.error('‚ùå Verification failed:', error instanceof Error ? error.message : String(error));
    process.exit(1);
  });